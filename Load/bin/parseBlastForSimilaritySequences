#! /usr/bin/perl
#vvvvvvvvvvvvvvvvvvvvvvvvv GUS4_STATUS vvvvvvvvvvvvvvvvvvvvvvvvv
  # GUS4_STATUS | SRes.OntologyTerm              | auto   | absent
  # GUS4_STATUS | SRes.SequenceOntology          | auto   | absent
  # GUS4_STATUS | Study.OntologyEntry            | auto   | absent
  # GUS4_STATUS | SRes.GOTerm                    | auto   | absent
  # GUS4_STATUS | Dots.RNAFeatureExon            | auto   | absent
  # GUS4_STATUS | RAD.SageTag                    | auto   | absent
  # GUS4_STATUS | RAD.Analysis                   | auto   | absent
  # GUS4_STATUS | ApiDB.Profile                  | auto   | absent
  # GUS4_STATUS | Study.Study                    | auto   | absent
  # GUS4_STATUS | Dots.Isolate                   | auto   | absent
  # GUS4_STATUS | DeprecatedTables               | auto   | absent
  # GUS4_STATUS | Pathway                        | auto   | absent
  # GUS4_STATUS | DoTS.SequenceVariation         | auto   | absent
  # GUS4_STATUS | RNASeq Junctions               | auto   | absent
  # GUS4_STATUS | Simple Rename                  | auto   | absent
  # GUS4_STATUS | ApiDB Tuning Gene              | auto   | absent
  # GUS4_STATUS | Rethink                        | auto   | absent
  # GUS4_STATUS | dots.gene                      | manual | unreviewed
die 'This file has broken or unreviewed GUS4_STATUS rules.  Please remove this line when all are fixed or absent';
#^^^^^^^^^^^^^^^^^^^^^^^^^ End GUS4_STATUS ^^^^^^^^^^^^^^^^^^^^

use strict;
use lib "$ENV{GUS_HOME}/lib/perl";
use Getopt::Long;
use GUS::ObjRelP::DbiDatabase;
use GUS::Supported::GusConfig;

my ($verbose, $blastInput, $blastOutput, $gusConfigFile);

&GetOptions("verbose!"=> \$verbose,
            "blastInput=s" => \$blastInput,
            "blastOutput=s" => \$blastOutput,
            "gusConfigFile=s" => \$gusConfigFile);

die "USAGE: $0 --blastInput --blastoutput {--verbose} {--gusConfigFile <file>}\n"
  if (!$blastInput|| !$blastOutput);
$| = 1;

print STDERR "Establishing dbi login\n" if $verbose;

my $gusconfig = GUS::Supported::GusConfig->new($gusConfigFile);

my $db = GUS::ObjRelP::DbiDatabase->new($gusconfig->getDbiDsn(),
					$gusconfig->getReadOnlyDatabaseLogin(),
					$gusconfig->getReadOnlyDatabasePassword(),
					$verbose,0,1,
					$gusconfig->getCoreSchemaName());

my $dbh = $db->getQueryHandle();


##############################################################
## Parses the output generated by blastSimilarity:
## >47 (7 subjects)
##   Sum: 47:353:1e-99:1:178:1:178:1:178:178:178:0::178:178:100
##    HSP1: 47:178:178:178:353:1e-99:1:178:1:178:0:
##
## To a form that can be used by sqlldr:
## 47 47 309571 309571 1 -99 100 100
## 47 105324 309571 38558 8 -31 41 92
## 47 61687 309571 177470 6 -26 39 85
##
## see Header below for more info
##############################################################


# -----------------------------------
# Main program
# -----------------------------------

$| = 1;

open (OUT, ">$blastOutput") || die "Can't open $blastOutput for writing\n";

if ($blastInput =~ /gz$/) {
  open(IN, "gunzip -c $blastInput |") || die "Can't gunzip and read $blastInput\n";
} else {
  open(IN,"$blastInput") || die "Can't gunzip and read $blastInput\n";
}

my %taxons;

my $sql = "SELECT aa_sequence_id, taxon_id FROM dots.externalaasequence";

print  STDERR "Getting taxon_ids using $sql\n" if $verbose;

my $sth = $dbh->prepare($sql);
$sth->execute();

while (my ($id,$taxonId) = $sth->fetchrow_array()) {
  $taxons{$id} = $taxonId;
}

$sth->finish();

my $numIds = scalar (keys %taxons);

print STDERR "Taxon ids obtained for $numIds aa_sequence_ids\n" if $verbose;

my $header = <<HEADER;
LOAD DATA
INFILE *
INTO TABLE apidb.similarsequences
FIELDS TERMINATED BY " " OPTIONALLY ENCLOSED BY '"'
TRAILING NULLCOLS
(  query_id,
    subject_id,
    query_taxon_id,
    subject_taxon_id,
    evalue_mant,
    evalue_exp,
    percent_identity,
    percent_match
    query_match_length
    subject_match_length
)
BEGINDATA
HEADER

print OUT "$header";

my $queryId;
my @lines = ();
my $total = 0;
my $date;

while(<IN>){
  chomp;
  if ($_ =~ />(\d+)/ && $total == 0) {
    $queryId  = $1;
    $total++;
  }
  elsif ($_ =~ />(\d+)/ && @lines >= 1) {
    foreach my $line (@lines) {
      print OUT "$line";
    }
    $date = `date`; chomp($date);

    print STDERR "$date: $total query ids processed and printed\n" if ($total > 1 && $total%1000 == 0 and $verbose); 

    $queryId = $1;

    @lines = ();

    $total++;
  }
  elsif ($_ =~ /Sum/) {
    my @arr = split(/\:/,$_);

    $arr[1] =~ s/\s//g;

    my ($mant, $exp);
    if ($arr[3] =~ /e/) {
      $arr[3] = '1' . $arr[3] if ($arr[3] =~ /^e/);
      ($mant, $exp) = split(/e/, $arr[3]);
    } else {
	$mant = int($arr[3]);
	$exp = 0;
    }

    my $perIdent = sprintf("%.0f", (($arr[10]/$arr[9])*100));
    my $perMatch = sprintf("%.0f", $arr[16]);
    my $queryMatchLength = $arr[14];
    my $subjectMatchLength = $arr[15];

    my $str = "$queryId $arr[1] $taxons{$queryId} $taxons{$arr[1]} $mant $exp $perIdent $perMatch $queryMatchLength $subjectMatchLength\n";

    my @arr = split(/\s/,$str);

    print STDERR "Missing attributes in $str" if (@arr != 10);

    push(@lines,$str);
  }
  else {
    next;
  }
}

foreach my $line (@lines) {
  print OUT "$line";
}

my $date = `date`; chomp($date);

print STDERR "$date: $total total query ids processed and printed" if $verbose;

close (OUT);
close(IN);

$dbh->disconnect();
1;


