#!/usr/bin/perl

=head1 NAME

jbrowseDumpAllFeatures - Export genomic features to JBrowse-compatible GFF files

=head1 SYNOPSIS

  jbrowseDumpAllFeatures --output_directory <DIR> [--organism_abbrev_filter=s] [--replace_existing]

=head1 DESCRIPTION

This script exports genomic features from the database to GFF format files suitable for
use with JBrowse. It processes tracks defined in jbrowseQueries.xml and creates compressed,
indexed GFF files for each track and organism.

=head1 OPTIONS

  --output_directory         Directory where output files will be created (required)
  --organism_abbrev_filter   Filter to process only specific organism(s)
  --replace_existing         Replace existing output files
  --help, -h                 Display this help message

=head1 AUTHOR

VEuPathDB

=cut

use strict;
use warnings;

use lib $ENV{GUS_HOME} . "/lib/perl";

use Getopt::Long;
use DBI;
use DBD::Pg;
use XML::Simple;
use GUS::Supported::GusConfig;

# Constants
use constant {
  GFF_SORT_KEY => "-k1,1 -k4,4n",
  RELEASE_DIR_NAME => "release-CURRENT",
  JBROWSE_SUBDIR => "jbrowse",
  GENOMIC_TRACK_TYPE => "genomic",
};

my ($help, $outputDir, $orgFilter, $replaceExisting);

&GetOptions(
  'help|h'                     => \$help,
  'output_directory=s'         => \$outputDir,
  'organism_abbrev_filter=s'   => \$orgFilter,
  'replace_existing'           => \$replaceExisting
);

if ($help || !$outputDir) {
  die "usage:  jbrowseDumpAllFeatures --output_directory <DIR> [--organism_abbrev_filter=s] [--replace_existing]\n";
}

if (!-d $outputDir) {
  die "Error: Output directory not found: $outputDir\n";
}

unless ($ENV{GUS_HOME}) {
  die "Error: GUS_HOME environment variable is not set\n";
}

my $gusConfigFile = "$ENV{GUS_HOME}/config/gus.config";

unless (-f $gusConfigFile) {
  die "Error: GUS config file not found: $gusConfigFile\n";
}

my $gusconfig = GUS::Supported::GusConfig->new($gusConfigFile);
my $dbh = DBI->connect($gusconfig->getDbiDsn(),
                       $gusconfig->getDatabaseLogin(),
                       $gusconfig->getDatabasePassword())
  or die "Cannot connect to database: " . $DBI::errstr;

$dbh->{LongTruncOk} = 0;
$dbh->{LongReadLen} = 10000000;

my $gbrowseXmlFile =  $ENV{GUS_HOME} . "/lib/xml/jbrowseQueries.xml";

unless (-f $gbrowseXmlFile) {
  die "Error: JBrowse queries XML file not found: $gbrowseXmlFile\n";
}

my $xml = XMLin($gbrowseXmlFile, ForceArray => ['trackConfigurations', 'properties']);

my @tracks = keys %{$xml->{track}};

my $organisms = getOrganismInfo($dbh, $orgFilter);

unless (@$organisms) {
  die "Error: No organisms found matching the criteria\n";
}

print "starting dump at " . `date` . "\n";
foreach my $o (@$organisms) {

  my $project = $o->{project_name};
  my $nameForFilenames = $o->{name_for_filenames};

  my $projectDir = "$outputDir/$project";
  my $releaseDir = "$projectDir/" . RELEASE_DIR_NAME;
  my $organismDir = "$releaseDir/$nameForFilenames";
  my $jbrowseDir = "$organismDir/" . JBROWSE_SUBDIR;

  mkdir $projectDir or die "Cannot create directory $projectDir: $!" unless (-d $projectDir);
  mkdir $releaseDir or die "Cannot create directory $releaseDir: $!" unless (-d $releaseDir);
  mkdir $organismDir or die "Cannot create directory $organismDir: $!" unless (-d $organismDir);
  mkdir $jbrowseDir or die "Cannot create directory $jbrowseDir: $!" unless (-d $jbrowseDir);

  my $trackCount = 0;
  foreach my $trackName (@tracks) {
    next if ($trackName =~ /^\s*#/);

    $trackCount++;
    my $startTime = time;

    my $trackType = $xml->{track}->{$trackName}->{type};
    my $fileSuffix = $xml->{track}->{$trackName}->{fileSuffix};

    die "track must provide trackType, fileSuffix, and trackName" unless ($trackType && $fileSuffix && $trackName);

    # Only process genomic tracks (protein tracks have been removed)
    unless ($trackType eq GENOMIC_TRACK_TYPE) {
      die "Error: Only genomic track type is supported, got: $trackType";
    }

    my $fullFileName = "$jbrowseDir/${trackName}.gff";

    my $outFh;

    my $featureSqlRaw = $xml->{track}->{$trackName}->{sql};

    my $queryParams = makeQueryParams($dbh, $trackName, $xml);

    my @existingFiles = glob "${fullFileName}*";
    if (scalar @existingFiles) {
      if ($replaceExisting) {
        print "unlinking existing file(s): " . join(", ", @existingFiles) . "\n";
        unlink @existingFiles;
      }
      else {
        print STDERR "SKIPPING Existing file: $fullFileName\n";
        next;
      }
    }

    my $sortKey = GFF_SORT_KEY;
    open($outFh, "|sort -T $jbrowseDir $sortKey >$fullFileName") or die "Cannot open file $fullFileName for writing: $!";

    my $featureCountTotal = 0;

    foreach my $qp (@$queryParams) {
      my $featureSql = makeSql($featureSqlRaw, $o, $qp);
      my $featureCount = addFeatures($dbh, $featureSql, $outFh);
      $featureCountTotal += $featureCount;
    }

    close $outFh;

    if ($featureCountTotal > 0) {
      my $bgzip_result = system("bgzip $fullFileName");
      if ($bgzip_result != 0) {
        warn "Warning: bgzip failed for $fullFileName\n";
        next;
      }

      my $tabix_result = system("tabix -p gff ${fullFileName}.gz");
      if ($tabix_result != 0) {
        warn "Warning: tabix failed for ${fullFileName}.gz\n";
      }

      my $duration = time - $startTime;
      print "$duration seconds wrote $featureCountTotal records for track $trackName\n";
    }
  }

  print "finished $trackCount tracks\n";
}


$dbh->disconnect();

#-------------------------------------------------------------------------------
# Subroutines
#-------------------------------------------------------------------------------

=head2 addFeatures

Executes a feature query and writes features to a GFF file handle.

Arguments:
  $dbh         - Database handle
  $featureSql  - SQL query to fetch features
  $fh          - File handle to write GFF output

Returns:
  Number of features processed

=cut

sub addFeatures {
  my ($dbh, $featureSql, $fh) = @_;

  my $sh = $dbh->prepare($featureSql);
  $sh->execute();

  my $featureCount = 0;

  # Process each feature from the database query
  while (my $hash = $sh->fetchrow_hashref("NAME_lc")) {
    my $featureId = $hash->{feature_id};
    my $parentId = $hash->{parent_id};

    $hash->{atts} .= ";ID=$featureId";
    $hash->{atts} .= ";Parent=$parentId" if ($parentId);

    print $fh join("\t", ($hash->{sequence_source_id},
                           $hash->{source},
                           $hash->{feature},
                           $hash->{startm},
                           $hash->{end},
                           $hash->{score} || ".",
                           $hash->{strand},
                           $hash->{frame} || ".",
                           $hash->{atts})) . "\n";

    # Handle block-based features (e.g., exons in a transcript)
    if ($hash->{tstarts}) {
      my @tstarts = map { s/\s+//g; $_ - 1 } split /,/, $hash->{tstarts};
      my @blocksizes = map { s/\s+//g; $_ } split /,/, $hash->{blocksizes};
      my $counter = 0;

      foreach my $start (@tstarts) {
        my $end = $start + $blocksizes[$counter] - 1;

        my $subAtts = "ID=" . $featureId . "_$counter;Parent=$featureId";

        print $fh join("\t", ($hash->{sequence_source_id},
                               $hash->{source},
                               "subfeature",
                               $start,
                               $end,
                               $hash->{score} || ".",
                               $hash->{strand},
                               $hash->{frame} || ".",
                               $subAtts)) . "\n";

        $counter++;
      }
    }

    $featureCount++;
  }
  return $featureCount;
}

=head2 makeQueryParams

Extracts query parameters from track configurations in the XML.

Arguments:
  $dbh        - Database handle (unused but passed for consistency)
  $trackName  - Name of the track
  $xml        - Parsed XML configuration

Returns:
  Array reference of query parameter hashes

=cut

sub makeQueryParams {
  my ($dbh, $trackName, $xml) = @_;

  my @rv;
  if (my $trackConfigurations = $xml->{track}->{$trackName}->{trackConfigurations}) {

    foreach my $tc (@$trackConfigurations) {
      foreach my $property (@{$tc->{properties}}) {
        my %hash;
        foreach my $prop (keys %{$property->{prop}}) {
          my $value = $property->{prop}->{$prop}->{content};
          $hash{$prop} = $value;
        }
        push @rv, \%hash;
      }
    }

    return \@rv;
  }

  return [{INTERNAL => "INTERNAL"}];
}

=head2 getOrganismInfo

Fetches organism information from the database.

Arguments:
  $dbh        - Database handle
  $orgFilter  - Optional organism abbreviation filter

Returns:
  Array reference of organism hashes containing project_name, abbrev,
  name_for_filenames, taxon_id, and external_database_release_id

=cut

sub getOrganismInfo {
  my ($dbh, $orgFilter) = @_;

  my $sql = "select o.project_name
     , o.abbrev
     , o.name_for_filenames
     , o.taxon_id
     , r.external_database_release_id
from apidb.datasource ds
   , apidb.organism o
   , sres.externaldatabase d
   , sres.externaldatabaserelease r
where ds.name like '%primary_genome%'
and ds.taxon_id = o.taxon_id
and ds.name = d.name
and d.external_database_id = r.external_database_id";

  if ($orgFilter) {
    $sql .= " and o.abbrev = '$orgFilter'";
  }

  my $sh = $dbh->prepare($sql);
  $sh->execute();

  my @rv;
  while (my $hash = $sh->fetchrow_hashref("NAME_lc")) {
    push @rv, $hash;
  }
  $sh->finish();
  return \@rv;
}

=head2 getGenomicSequences

Fetches genomic sequence information for an organism (REMOVED - no longer used).

This function has been removed as the refactored version no longer iterates
over sequences individually.

=cut

sub getGenomicSequences {
  my ($dbh, $organism) = @_;
  my $extDbRlsId = $organism->{external_database_release_id};

  my $sql = "select source_id as seqname, na_sequence_id as seqid from dots.externalnasequence where external_database_release_id = ?";
  my $sh = $dbh->prepare($sql);
  $sh->execute($extDbRlsId);

  my @rv;
  while (my $hash = $sh->fetchrow_hashref("NAME_lc")) {
    push @rv, $hash;
  }
  $sh->finish();
  return \@rv;
}

=head2 makeSql

Performs variable substitution in SQL templates.

Replaces placeholders in SQL with actual values:
  $dlm                          -> ;
  $org_abbrev                   -> organism abbreviation
  $taxon_id                     -> organism taxon ID
  $external_database_release_id -> external database release ID
  $$KEY$$                       -> custom query parameter values

Arguments:
  $sql         - SQL template with placeholders
  $organism    - Organism hash with abbrev, taxon_id, external_database_release_id
  $queryParams - Hash of additional query parameters

Returns:
  SQL string with substituted values

=cut

sub makeSql {
  my ($sql, $organism, $queryParams) = @_;

  my $org_abbrev = $organism->{abbrev};
  my $taxon_id = $organism->{taxon_id};
  my $external_database_release_id = $organism->{external_database_release_id};
  
  $sql =~ s/\$dlm/;/g;

  $sql =~ s/\$org_abbrev/${org_abbrev}/g;
  $sql =~ s/\$taxon_id/${taxon_id}/g;
  $sql =~ s/\$organism_external_database_release_id/$external_database_release_id/g;

  foreach my $key (keys %$queryParams) {
    my $value = $queryParams->{$key};
    $sql =~ s/\$\$${key}\$\$/${value}/g;
  }

  return $sql;
}


1;
