#!/usr/bin/env perl
use strict;
use warnings;

use lib "$ENV{GUS_HOME}/lib/perl";

use DBI;

use Getopt::Long;

use GUS::Supported::GusConfig;

use File::Basename;

my ($pairDir, $gusConfigFile, $outputFile);
&GetOptions('pairDir=s' => \$pairDir,
            'gusConfigFile=s' => \$gusConfigFile,
            'outputFile=s' => \$outputFile
    );

my $gusconfig = GUS::Supported::GusConfig->new($gusConfigFile);

my $dsn = $gusconfig->getDbiDsn();
my $login = $gusconfig->getDatabaseLogin();
my $password = $gusconfig->getDatabasePassword();

my $dbh = DBI->connect($dsn, $login, $password) or die DBI->errstr;

########################################################################################
my ($syntenyFile, $syntenyCtrl, $syntenicGeneFile, $syntenicGeneCtrl) = qw/synteny.dat synteny.dat.ctrl syntenic_gene.dat syntenic_gene.dat.ctrl/;

my $pair = basename($pairDir);

my $databaseName = "${pair}_Mercator_synteny";

my $sql = "select count(*)
from sres.externaldatabase d
  inner join sres.externaldatabaserelease r
     on d.external_database_id = r.external_database_id
where d.name = '$databaseName'";

my $sh = $dbh->prepare($sql);
$sh->execute();

my ($count) = $sh->fetchrow_array();
$sh->finish();


#if($count > 0) {
if($pair eq "tbruTREU927-ltarParrotTarII") {
  print STDERR "SKIP preveiously loaded pair:  $pair";
}
else  {
  open(OUT, ">$outputFile") or die "Cannot open file $outputFile for writing: $!";
  print OUT "PAIR=$pair was not found in the database, loading....";
  close OUT;
}



# my $dbPluginArgs = "--name '$databaseName' ";
# my $releasePluginArgs = "--databaseName '$databaseName' --databaseVersion dontcare";

# my $insertPluginArgs = join(" ",
#     "--writeSqlldrFiles",
#     "--inputDirectory $pairDir",
#     "--outputSyntenyDatFile synteny.dat",
#     "--outputSyntenyCtrlFile synteny.dat.ctrl",
#     "--outputSyntenicGeneDatFile syntenic_gene.dat",
#     "--outputSyntenicGeneCtrlFile syntenic_gene.dat.ctrl",
#     "--syntenyDbRlsSpec '$databaseName|dontcare'");

# # allow for restart; skip those already in db.   any partially done pair needs to be fully backed out before restart.
# my $skip = 0;
# my $ed = GUS::Model::SRes::ExternalDatabase->new({name => $databaseName});
# my $edIsLoaded = $ed->retrieveFromDB;
# my $edRelIsLoaded;
# if($edIsLoaded){
#   my $edr = GUS::Model::SRes::ExternalDatabaseRelease->new({external_database_id => $ed->getExternalDatabaseId});
#   $edRelIsLoaded = $edr->retrieveFromDB;
#   if($edRelIsLoaded){
#     printf STDERR ("Pair $pair was previously loaded.  Skipping.\n");
#     exit 0;
#   }
#   else{
#     $skip = 1;
#   }
# }
# unless($edIsLoaded){
#   runPlugin($test, $undo, "GUS::Supported::Plugin::InsertExternalDatabase", $dbPluginArgs);
# }
# runPlugin($test, $undo, "GUS::Supported::Plugin::InsertExternalDatabaseRls", $releasePluginArgs) unless($edRelIsLoaded);
# ## Always run in test mode, no GUS::Model submit:
# my $status = runPlugin(1, 0, "ApiCommonData::Load::Plugin::InsertSyntenySpans", $insertPluginArgs) unless($skip);

# exit $status;
# 1;

# sub runPlugin {
#   my ($test, $undo, $plugin, $args) = @_;
#   unless ($test) { $args .= ' --commit' }
#   $args .= " --comment \"$args\"";
#   my $cmd = sprintf("ga %s %s", $plugin, $args);
#   printf STDERR ("Running ga command: $cmd\n");
#   return system($cmd);
# }
