#!/usr/bin/perl

use strict;
use lib "$ENV{GUS_HOME}/lib/perl";
use Data::Dumper;
use XML::Simple;
use DBI;
use Getopt::Long qw(GetOptions);
use ApiCommonData::Load::TuningConfig::InternalTable;
use ApiCommonData::Load::TuningConfig::ExternalTable;
use ApiCommonData::Load::TuningConfig::ExternalTuningTable;
use ApiCommonData::Load::TuningConfig::TuningIndex;
use ApiCommonData::Load::TuningConfig::TuningRegistry;
use ApiCommonData::Load::TuningConfig::Log;
use ApiCommonData::Load::TuningConfig::TableSuffix;
use ApiCommonData::Load::TuningConfig::Utils;

my $subversionDir;
my $props;
my $startTime = time;
my $maxRebuildMinutes = 0;
my $dbaEmail;
my $fromEmail;

my ($sec,$min,$hour,$mday,$mon,$year) = localtime();
my $timestamp = sprintf('%4d-%02d-%02d %02d:%02d:%02d', $year+1900, $mon+1, $mday, $hour, $min, $sec);

my $osUser = `whoami`;
chomp($osUser);
ApiCommonData::Load::TuningConfig::Log::addLogPreamble("Starting tuningManager as OS user \"$osUser\", "
					       . ApiCommonData::Load::TuningConfig::Log::getProcessInfo()
					       . " at $timestamp with arguments:\n"
					       . join(' ', @ARGV));

my $noArgs = !@ARGV; # check for no arguments now, before GetOptions consumes @ARGV

my ($configFile, $propFile, $instance, $schema, $password, $tables,
    $doUpdate, $debug, $notifyEmail, $cleanupWarnOnly, $cleanupAge, $forceUpdate,
    $maxWait, $logfile, $prefix, $filterValue);

GetOptions("configFile=s" => \$configFile,
           "propFile=s" => \$propFile,
           "instance=s" => \$instance,
           "schema=s" => \$schema,
           "password=s" => \$password,
           "tables=s" => \$tables,
           "doUpdate!" => \$doUpdate,
           "forceUpdate!" => \$forceUpdate,
           "notifyEmail=s" => \$notifyEmail,
           "debug!" => \$debug,
           "cleanupAge:i" => \$cleanupAge,
           "cleanupWarnOnly!" => \$debug,
           "maxWait=s" => \$maxWait,
           "logfile=s" => \$logfile,
           "prefix=s" => \$prefix,
           "filterValue=s" => \$filterValue,
	  );

ApiCommonData::Load::TuningConfig::Log::setLogfile($logfile);

ApiCommonData::Load::TuningConfig::Log::setDebugFlag()
  if $debug;

ApiCommonData::Load::TuningConfig::Log::addErrorLog("parameter error: either \"propFile\" or \"password\" must be specified")
  unless ($propFile || $password);
ApiCommonData::Load::TuningConfig::Log::addErrorLog("parameter error: \"instance\" must be specified")
  unless $instance;
ApiCommonData::Load::TuningConfig::Log::addErrorLog("parameter error: \"configFile\" must be specified if \"prefix\" is used")
  unless ($configFile || !$prefix);
&usage unless ($instance && ($propFile || $password) && ($configFile || !$prefix));

exit if ($noArgs); # don't send a log email if they only want usage

$cleanupAge = 0 if !defined $cleanupAge;

$doUpdate = 1 if $forceUpdate;

my ($dbh, $tuningRegistry, $brokenCount, $neededUpdateCount);
eval {
  if ($propFile) {
    my $simple = XML::Simple->new();
    $props = $simple->XMLin($propFile);
    my %permittedProperties = (password => 1, maxRebuildMinutes => 1, dbaEmail => 1, dblink => 1, schema => 1, fromEmail => 1);
    my $badProp;
    foreach my $foundProp (keys(%{$props})) {
      if (!$permittedProperties{$foundProp}) {
	ApiCommonData::Load::TuningConfig::Log::addErrorLog("invalid property \"$foundProp\"");
	$badProp = 1;
      }
    }
    die if $badProp;
  }

  # prefer schema from command line, then prop file, then hardwired default
  $schema = $props->{schema} if !$schema;
  $schema = 'ApidbTuning' if !$schema;

  $maxRebuildMinutes = $props->{maxRebuildMinutes};

  if ($props->{dbaEmail}) {
    $dbaEmail = $props->{dbaEmail} if $props->{dbaEmail};
    $fromEmail = $props->{fromEmail} if $props->{fromEmail};
  } else {
    $dbaEmail = 'tuningMgr@pcbi.upenn.edu';
    $fromEmail = 'tuningMgr@pcbi.upenn.edu';
  }

  ApiCommonData::Load::TuningConfig::Log::addLog("creating tuning tables with the prefix \"$prefix\"")
      if $prefix;

  $SIG{INT} = \&catch_signal;
  $SIG{TERM} = \&catch_signal;

  ($instance, $schema, $password) = ApiCommonData::Load::TuningConfig::Utils::getDbLoginInfo($instance, $propFile, $schema, $password);
  ApiCommonData::Load::TuningConfig::Log::addLog("Logging in to the database as (and creating tuning tables in) the schema \"$schema\".");
  $dbh = ApiCommonData::Load::TuningConfig::Utils::getDbHandle($instance, $schema, $password);

  $tuningRegistry =
    ApiCommonData::Load::TuningConfig::TuningRegistry->new($dbh, $props->{dblink})
	if !$prefix;

  if (!$prefix && (lc($instance) ne lc($tuningRegistry->getInstanceName()))) {
    die("instance name \"$instance\" does not match apidb.InstanceMetaInfo.instance_nickname \"" . $tuningRegistry->getInstanceName() . "\"");
  }

  # get and validate config file
  $configFile = getConfigFileName($configFile, $tuningRegistry, $prefix);
  ApiCommonData::Load::TuningConfig::Log::addLog("Using config file \"$configFile\"");
  my $validationCmd = "validateXmlWithRng $ENV{GUS_HOME}/lib/rng/tuningManager.rng $configFile |";
  ApiCommonData::Load::TuningConfig::Log::addLog("Validating XML:\n" . $validationCmd);
  open(PROGRAM, $validationCmd);
  while (<PROGRAM>) {
    my $line = $_;
    chomp($line);
    ApiCommonData::Load::TuningConfig::Log::addLog($line);
  }
  close(PROGRAM);
  my $exitCode = $? >> 8;
  ApiCommonData::Load::TuningConfig::Log::addErrorLog("invalid config file") if $exitCode;
#   die "invalid config file" if $exitCode;

  my ($config) = &parseConfigFile($configFile);

  # create an object for each <tuningTable> entity
  my %tuningTables;
  my %externalTables;
  my %externalTuningTables;
  my $dblinkSuffix = "";
  $dblinkSuffix = $tuningRegistry->getDblinkSuffix() if !$prefix;

  foreach my $tuningTable (@{$config->{tuningTable}}) {

    $tuningTables{$tuningTable->{name}}
      = ApiCommonData::Load::TuningConfig::InternalTable->
	new($tuningTable->{name}, $tuningTable->{internalDependency}, $tuningTable->{externalDependency},
	    $tuningTable->{externalTuningTableDependency}, $tuningTable->{intermediateTable},
            $tuningTable->{ancillaryTable}, $tuningTable->{sql}, $tuningTable->{perl},
            $tuningTable->{unionization}, $tuningTable->{program}, $dbh, $debug,
            $dblinkSuffix, $tuningTable->{alwaysUpdate}, $tuningTable->{prefixEnabled},
            $maxRebuildMinutes, $instance, $propFile, $schema, $password, $subversionDir);
  }

  if ($doUpdate && !$prefix) {
    clearDeadLock();
    checkLockout($maxWait) if $maxWait;
    $doUpdate = 0 if lockForUpdate($forceUpdate) eq "fail";
  }

  # validate config / check external files
  ApiCommonData::Load::TuningConfig::Log::addLogBanner("Using configuration file and checking external files");
  my $undefinedInternal;
  my $nonexistentExternal;
  my $nonexistentExternalTuningTable;
  my $dependencyCycle;
  foreach my $tableName (keys(%tuningTables)) {

    # check for internalDependencies that aren't in the list of tuningTables
    if ($tuningTables{$tableName}->getInternalDependencyNames()) {
      foreach my $dependency (@{$tuningTables{$tableName}->getInternalDependencyNames()}) {
	if (!$tuningTables{$dependency->{name}}) {
	  ApiCommonData::Load::TuningConfig::Log::addErrorLog("$tableName has an InternalDependency on $dependency->{name}, for which no description is supplied");
	  $undefinedInternal = 1;
	} else {
	  # add object to list of internal dependencies
	  $tuningTables{$tableName}->addInternalDependency($tuningTables{$dependency->{name}});
	}
      }
    }

    # check for externalDependencies that aren't in the database
    if ($tuningTables{$tableName}->getExternalDependencyNames()) {
      foreach my $dependency (@{$tuningTables{$tableName}->getExternalDependencyNames()}) {

	# new ExternalTable instance in the hash, if we haven't seen this
	my $key = $dependency->{name} . '@' . $dependency->{dblink};
	$externalTables{$key}
	  = ApiCommonData::Load::TuningConfig::ExternalTable->
	    new($dependency->{name}, $dependency->{dblink}, $dbh, $doUpdate,
		$dblinkSuffix)
	      unless ($externalTables{$key});

	# add external-table object to list of external dependencies
	$tuningTables{$tableName}->addExternalDependency($externalTables{$key});

	if (!$externalTables{$key}->exists()) {
	  ApiCommonData::Load::TuningConfig::Log::addErrorLog("$tableName has an ExternalDependency on $dependency->{name}, but no such table exists");
	  $nonexistentExternal = 1;
	}
      }
    }

    # check for externalTuningTableDependencies that aren't in the database
    if ($tuningTables{$tableName}->getExternalTuningTableDependencyNames()) {
      foreach my $dependency (@{$tuningTables{$tableName}->getExternalTuningTableDependencyNames()}) {

	# new ExternalTuningTable instance in the hash, if we haven't seen this
	my $key = $dependency->{name} . '@' . $dependency->{dblink};
	$externalTuningTables{$key}
	  = ApiCommonData::Load::TuningConfig::ExternalTuningTable->
	    new($dependency->{name}, $dependency->{dblink}, $dbh, $doUpdate,
		$tuningRegistry->getDblinkSuffix())
	      unless ($externalTuningTables{$key});

	# add externalTuning-table object to list of externalTuning dependencies
	$tuningTables{$tableName}->addExternalTuningTableDependency($externalTuningTables{$key});

	if (!$externalTuningTables{$key}->exists()) {
	  ApiCommonData::Load::TuningConfig::Log::addErrorLog("$tableName has an ExternalTuningDependency on $key, but no such table exists");
	  $nonexistentExternalTuningTable = 1;
	}
      }
    }
  }

  # check for cycles in graph of dependencies
  foreach my $table (keys(%tuningTables)) {
    $dependencyCycle = 1
      if $tuningTables{$table}->hasDependencyCycle([]);
  }

  if ($undefinedInternal || $nonexistentExternal || $nonexistentExternalTuningTable || $dependencyCycle) {
    ApiCommonData::Load::TuningConfig::Log::addErrorLog("INVALID CONFIGURATION -- NOT UPDATING DATABASE");
    $doUpdate = 0;
  } else {
    ApiCommonData::Load::TuningConfig::Log::addLog("Configuration file OK");
  }

  # indexes
  ApiCommonData::Load::TuningConfig::Log::addLogBanner("Checking indexes");
  my $indexesConfigured;
  my $missingIndexes;
  foreach my $tuningIndex (@{$config->{tuningIndex}}) {

    $indexesConfigured++;
    my $indexObject =
      ApiCommonData::Load::TuningConfig::TuningIndex->
	  new($tuningIndex->{name},
	      $tuningIndex->{table},
	      $tuningIndex->{content},
	      $dbh);

    if (!$indexObject->exists()) {
      $missingIndexes++;
      ApiCommonData::Load::TuningConfig::Log::addLog("must " . $indexObject->getCreateStatement());

      $indexObject->create($dbh)
	if $doUpdate;
    }
  }

  # tables
  my $tableCount = 0;
  $brokenCount = 0;
  $neededUpdateCount = 0;
  my $upToDateCount = 0;

  ApiCommonData::Load::TuningConfig::Log::addLogBanner("Checking whether tuning tables are up to date");
  # check (and potentially update) every tuning table
  my @tableList;
  if ($tables) {
    @tableList = split(/,/, $tables);
  } else {
    @tableList = keys(%tuningTables);
  }

  foreach my $table (@tableList) {
    if (!$tuningTables{$table}) {
      ApiCommonData::Load::TuningConfig::Log::addErrorLog("unknown tuning table $table");
      next;
    }

    $tableCount++;
    my $state = $tuningTables{$table}->getState($doUpdate, $dbh, !$cleanupAge, $tuningRegistry, $prefix, $filterValue);

    if ($state eq "broken") {
      $brokenCount++;
    } elsif ($state eq "neededUpdate") {
      $neededUpdateCount++;
    } elsif ($state eq "up-to-date") {
      $upToDateCount++;
    } else {
      ApiCommonData::Load::TuningConfig::Log::addErrorLog("invalid state $state");
    }
  }

  # cleanup
  ApiCommonData::Load::TuningConfig::Log::addLogBanner("Cleanup");
  cleanup($dbh, $cleanupAge, $cleanupWarnOnly, $prefix);

  # summary
  if (!$tableCount) {
    ApiCommonData::Load::TuningConfig::Log::addLog("No tuningTable entities were defined in the config file");
  } else {
    my $summaryString = "\n$tableCount table(s) defined: $upToDateCount up-to-date, $neededUpdateCount "
      . ($doUpdate ? "updated" : "needing update")
	. ", $brokenCount broken";
    $summaryString .= " -- tuningManager ran successfully"
      if !ApiCommonData::Load::TuningConfig::Log::getErrorsEncounteredFlag();
    ApiCommonData::Load::TuningConfig::Log::addLogPreamble($summaryString);
  }

  # list broken tables
  if ($brokenCount) {
    ApiCommonData::Load::TuningConfig::Log::addLogPreamble("   broken table(s):");
    foreach my $table (@tableList) {
      ApiCommonData::Load::TuningConfig::Log::addLogPreamble("     " . $tuningTables{$table}->getName())
	  if $tuningTables{$table}->getState($doUpdate, $dbh) eq "broken";
    }
  }


  # list updated/outdated tables
  if ($neededUpdateCount) {
    if ($doUpdate) {
      ApiCommonData::Load::TuningConfig::Log::addLogPreamble("   table(s) updated:");
    } else {
      ApiCommonData::Load::TuningConfig::Log::addLogPreamble("   table(s) needing update:");
    }
    foreach my $table (@tableList) {
      ApiCommonData::Load::TuningConfig::Log::addLogPreamble("     " . $tuningTables{$table}->getName())
	  if $tuningTables{$table}->getState($doUpdate, $dbh) eq "neededUpdate";
    }
  }

  if (!$indexesConfigured) {
    ApiCommonData::Load::TuningConfig::Log::addLogPreamble("No tuningIndex entities were defined in the config file");
  } elsif ($missingIndexes) {
    ApiCommonData::Load::TuningConfig::Log::addLogPreamble($missingIndexes . " of the "
						   . $indexesConfigured
						   . " indexes configured were found to be missing");
  } else {
    ApiCommonData::Load::TuningConfig::Log::addLogPreamble("All "
						   . $indexesConfigured
						   . " indexes were found to exist.");
  }

  releaseLockForUpdate() if !$prefix;

  # set last updater in registry if we did a successful full update (and made changes)
  $tuningRegistry->setLastUpdater()
    if $doUpdate && $neededUpdateCount && !$tables && !$brokenCount && !$prefix;

  # set last checker
  $tuningRegistry->setLastChecker()
    if !$tables && !$doUpdate && !$prefix;
  $tuningRegistry->setLastUpdater()
    if !$tables && !$doUpdate && !$prefix;

  # set OK if: we looked at everything, nothing was broken, and if updates were needed, we did them.
  $tuningRegistry->setOk()
    if !$tables && !$brokenCount && (!$neededUpdateCount || $doUpdate) && !$prefix;

  # set outdated if: something was broken, or needed an update but didn't get it
  $tuningRegistry->setOutdated()
    if ( ($neededUpdateCount && !$doUpdate) || $brokenCount) && !$prefix;

  # if a temporary config-file dir was checked out from svn, delete it now
  if ($subversionDir && !$prefix) {
    my @cmdLine = ("rm", "-rf", $subversionDir);
    system(@cmdLine) == 0
      or ApiCommonData::Load::TuningConfig::Log::addErrorLog("unable to remove temporary config directory");
  }

  # set notifyEmail (for log email)
  if ($tuningRegistry) {
    $notifyEmail = $tuningRegistry->getNotifyEmails() if !$notifyEmail;
  }

};

# log any errors inside eval
ApiCommonData::Load::TuningConfig::Log::addErrorLog($@)
  if $@;

my $elapsed = time - $startTime;
my $hms = sprintf('%02d:%02d:%02d', $elapsed / 3600, ($elapsed % 3600) / 60, $elapsed % 60);

ApiCommonData::Load::TuningConfig::Log::addLogPreamble(time - $startTime .
					       " seconds to run tuningManager ($hms)\n\n");

$notifyEmail = "tuningMgr\@pcbi.upenn.edu" if !$notifyEmail;

ApiCommonData::Load::TuningConfig::Log::mailLog($notifyEmail, $instance);

ApiCommonData::Load::TuningConfig::Log::mailOutOfSpaceReport($instance, $dbaEmail, $fromEmail)
  if ApiCommonData::Load::TuningConfig::Log::getOutOfSpaceMessage();

die if ApiCommonData::Load::TuningConfig::Log::getErrorsEncounteredFlag();

###############################################################################

sub usage {
  ApiCommonData::Load::TuningConfig::Log::addLog(
q{
Create/update "tuning tables", denormalized copies of data for better web site performance.

Usage: tuningManager {--configFile <configXmlPath>} {--propFile <filename>}
                      --instance <dbInstance> {--password <dbPassword>}
                     {--doUpdate} {--notifyEmail <emailAddressList>} { --debug }
                     {--cleanupWarnOnly} {--cleanupAge <days>} {--forceUpdate}
                     {--prefix <prefix>} {--filterValue <value>}

options:
  configFile      an xml file describing the tables to be created
  propFile        file contains XML tuningProps entity containing password, schema, dblink, dbaEmail, or maxRebuildMinutes entities
  instance        the database instance to login and craete objects in
  schema          the schema (database user) to login and craete objects in
  password        database login password
  tables          check/update only listed tables (and their antecedants)
  doUpdate        update any tables found to be out of date
  notifyEmail     comma-separated list of email addresses to send log to. ("none" to suppress email)
  cleanupWarnOnly name but don't drop obsolete tuning tables
  cleanupAge      specify how long (in days) tuning table must be obsolete before dropping (default 0)
  forceUpdate     perform update even if current_updater flag is set (implies --doUpdate)
  maxWait         limit, in hours, to wait if another tuning manager is updating the database
  debug           print debugging info
  prefix          create tuning tables and synonyms with supplied prefix, by substituting this value
                  for any occurrances of the "&prefix" macro
  filterValue     substitute this value for any occurences in the XML of the "&filterValue" macro

notes:
  1. The --instance parameter is required.
  2. A database password must be supplied, either with the --password parameter or in the file specified with the --propFile parameter
  3. When the --prefix parameter is used, the --configFile parameter is required.

examples:

tuningManager -instance <db instance> -propFile <propFile> # minimal usage, using XML from svn

tuningManager -instance <db instance> -password <password> # password on command line instead of propFile

tuningManager -instance <db instance> -propFile <propFile> -configFile <XML file> -notifyEmail <me@upenn.edu> # typical development usage

The last example shows typical usage for testing new or changed tuning-manager XML.
Specifying the XML file on the command line makes it possible to test the code
before checking it in, and giving your own email address with the -notifyEmail
parameter keeps the log file from being sent to the tuning-manager email list.
});
}

sub getConfigFileName {
  my ($configFile, $tuningRegistry, $suffix) = @_;

  my $configPath;
  if (!$prefix) {
    $subversionDir = "/tmp/tMan." . $$ . "." . time . "/";
    my $subversionUrl = $tuningRegistry->getSubversionUrl();
    my @cmdLine = ("svn", "checkout", $subversionUrl, $subversionDir);
    ApiCommonData::Load::TuningConfig::Log::addLogBanner("Checking out configuration file from Subversion");
    ApiCommonData::Load::TuningConfig::Log::addLog("Subversion URL: \"$subversionUrl\"");
    system(@cmdLine) == 0
      or die "system @cmdLine failed: $?";
  }

  # if no config file was supplied, use one from Subversion
  if (!$configFile) {
    $configFile = $tuningRegistry->getConfigFile();

    # default to component tuning manager
    $configFile = "tuningManager.xml" if !$configFile; 
    $configPath = $subversionDir . '/' . $configFile;
    return $configPath;
  } elsif (substr($configFile, 0, 1) ne "/") {
    $configPath = $subversionDir . '/' . $configFile;
    return $configPath;
  } else {
    return $configFile;
  }

}

sub parseConfigFile {
  my ($configFile) = @_;

  open(FILE, $configFile) || die "can't open configuration file '$configFile' for reading\n";
  my $simple = XML::Simple->new();

  # use forcearray so elements with one child are still arrays
  # and use keyattr so that unions are given as an ordered list
  # rather than a hash
  my $config = $simple->XMLin($configFile,
			    forcearray => 1,
			    KeyAttr => {sqlValue=>'+name'});
  if ($debug) {
    print Dumper($config);
    print "\n\n";
  }

  return ($config);
}

sub cleanup {
  my ($dbh, $cleanupAge, $cleanupWarnOnly, $prefix) = @_;
  my $cleanupCount = 0;

  # drop any tables that are listed as obsolete more than the threshold
  #   and don't have a synonym pointed at them
  my $sql = <<SQL;
select ott.name,
       to_char(sysdate - ott.timestamp, '9.99') as days_old
from apidb.ObsoleteTuningTable ott,
     all_tables at
where ott.timestamp < sysdate - $cleanupAge
  and ott.name = at.owner || '.' || at.table_name
  and lower(ott.name) not in
        (select lower(table_owner || '.' || table_name) from all_synonyms)
SQL
  ApiCommonData::Load::TuningConfig::Log::addLog($sql) if $debug;

  my $select = $dbh->prepare($sql);
  $select->execute()
    or ApiCommonData::Load::TuningConfig::Log::addErrorLog("\n" . $dbh->errstr . "\n");

  # prepare sql to delete ObsoleteTuningTable record when OTT is dropped
  my $sql = <<SQL;
delete from apidb.ObsoleteTuningTable
where name = ?
SQL
  my $delete  = $dbh->prepare($sql);

  while (my ($dropee, $daysOld) = $select->fetchrow_array()) {
    $cleanupCount++;
    my $dropMsg = "$dropee obsolete for $daysOld days.";

    if (!$cleanupWarnOnly) {
      $dropMsg .= " . . .dropping.";
      my $sql = <<SQL;
          drop table $dropee
SQL
      my $drop = $dbh->prepare($sql);
      $drop->execute()
	or ApiCommonData::Load::TuningConfig::Log::addErrorLog("\n" . $dbh->errstr . "\n");
      $drop->finish();

      $delete->execute($dropee)
	or ApiCommonData::Load::TuningConfig::Log::addErrorLog("\n" . $dbh->errstr . "\n");
    }
    ApiCommonData::Load::TuningConfig::Log::addLog($dropMsg);
  }
  $select->finish();
  $delete->finish();

  # check for obsolete tuning tables that begin with $prefix (whether or not
  # that's the empty string) and are not listed in apidb.ObsoleteTuningTable.
  # If $prefix is defined, drop any matching obsolete unlisted tuning tables.
  # (That's safe because the workflow will prevent two instances of the same
  # organism's tuning manager from running at the same time.) If $prefix isn't
  # defined (i.e. we aren't in a workflow), issue a warning.
  my $newTablesTerm = '';
  if (ApiCommonData::Load::TuningConfig::TableSuffix::suffixDefined()) {
    my $suffix = ApiCommonData::Load::TuningConfig::TableSuffix::getSuffix($dbh);
    $newTablesTerm = "and atab.table_name not like '%$suffix%'";
  }
  # note that the backslash in the regex is to protect the dollar-sign from Perl
  # it's really "zero or more digits, followed by end-of-line": [0-9]*$
  $sql = <<SQL;
select owner || '.' || table_name
from (select atab.owner, atab.table_name
      from all_synonyms asyn, all_tables atab
      where asyn.owner = atab.owner
        and regexp_replace(atab.table_name, '[0-9]*\$', '') = asyn.synonym_name
        and atab.table_name like upper('$prefix\%')
        $newTablesTerm
    minus select table_owner, table_name from all_synonyms)
minus select name from apidb.ObsoleteTuningTable
SQL

  my $stmt = $dbh->prepare($sql);
  $stmt->execute()
    or ApiCommonData::Load::TuningConfig::Log::addErrorLog("\n" . $dbh->errstr . "\n");
  while (my ($table) = $stmt->fetchrow_array()) {
    if ($prefix) {
      ApiCommonData::Load::TuningConfig::Log::addLog("Dropping obsolete tuning table $table, which is not listed in apidb.ObsoleteTuningTable.");
      $dbh->do("drop table $table")
	or ApiCommonData::Load::TuningConfig::Log::addErrorLog("\n" . $dbh->errstr . "\n");
    } else {
      ApiCommonData::Load::TuningConfig::Log::addLog("WARNING: Obsolete tuning table $table is not listed in apidb.ObsoleteTuningTable. . . consider dropping it");
    }
  }

  $stmt->finish();

  # check for apidb.ObsoleteTuningTable records whose tables don't exist
  $sql = <<SQL;
select name from apidb.ObsoleteTuningTable
minus select owner || '.' || table_name
from (select atab.owner, atab.table_name
      from all_synonyms asyn, all_tables atab
      where asyn.owner = atab.owner
        and regexp_replace(atab.table_name, '[0-9]*\$', '') = asyn.synonym_name)
SQL

  my $stmt = $dbh->prepare($sql);
  $stmt->execute()
    or ApiCommonData::Load::TuningConfig::Log::addErrorLog("\n" . $dbh->errstr . "\n");
  while (my ($table) = $stmt->fetchrow_array()) {
    ApiCommonData::Load::TuningConfig::Log::addErrorLog("tuning table $table is listed in apidb.ObsoleteTuningTable but does not exist");
  }
  $stmt->finish();

  ApiCommonData::Load::TuningConfig::Log::addLog("$cleanupCount obsolete tables found")
      if $cleanupCount;

  ApiCommonData::Load::TuningConfig::Log::addLog("*** NOTE: obsolete tables retained because --cleanupWarnOnly parameter is set ***")
      if $cleanupCount && $cleanupWarnOnly;
}

sub lockForUpdate {
  my ($forceUpdate) = @_;

  my $processInfo  = ApiCommonData::Load::TuningConfig::Log::getProcessInfo();

  my $sql = <<SQL;
    update apidb.InstanceMetaInfo
    set current_updater = '$processInfo', update_start = sysdate
SQL

  $sql .= " where current_updater is null"
    unless $forceUpdate;

  $dbh->do($sql)
    or ApiCommonData::Load::TuningConfig::Log::addErrorLog("\n" . $dbh->errstr . "\n");

  my $stmt = $dbh->prepare("select current_updater from apidb.InstanceMetaInfo");
  $stmt->execute();
  my ($updater) = $stmt->fetchrow_array();

  if ($updater ne $processInfo) {
    my $updateLockoutMsg = <<MSG;
Another tuningManager process appears to be updating the database. CURRENT_UPDATER is set to "$updater".
Continuing in read-only mode, but not updating tuning tables. If this process ($updater) is not running, you can override this lockout by rerunning tuningManager with the "--forceUpdate" option.
MSG
    ApiCommonData::Load::TuningConfig::Log::addErrorLog($updateLockoutMsg);
    return("fail");
  }
  $stmt->finish();
}

sub releaseLockForUpdate {

  $dbh->do("update apidb.InstanceMetaInfo set current_updater = null, update_start = null where current_updater = '"
	   . ApiCommonData::Load::TuningConfig::Log::getProcessInfo()
	   . "'")
    or ApiCommonData::Load::TuningConfig::Log::addErrorLog("\n" . $dbh->errstr . "\n");
}

sub clearDeadLock {

  my $stmt = $dbh->prepare("select current_updater from apidb.InstanceMetaInfo");
  $stmt->execute();
  my ($updater) = $stmt->fetchrow_array();

  return if !$updater;

  if (!($updater =~ /process \d* on \S*/)) {
    ApiCommonData::Load::TuningConfig::Log::addErrorLog("ERROR: parsing current_updater string: \"" . $updater . "\"");
    return;
  }

  my @parts = split / /, $updater;
  my $pid = $parts[1];
  my $server = $parts[3];
  my $current_server = `uname -n`;
  chomp($current_server);

  if ($current_server ne $server) {
    ApiCommonData::Load::TuningConfig::Log::addErrorLog("can't check for tM process; it's on \"$server\" and I'm on \"$current_server\"");
    return;
  }

  my $pid_test = ` ps -fp $pid|tail -n +2|wc -l`;
  chomp($pid_test);
  if (!$pid_test) {
    # named process no longer exists; null out CURRENT_UPDATER
    ApiCommonData::Load::TuningConfig::Log::addLog("CURRENT_UPDATER process (" . $updater . ") no longer exists; updating InstanceMetaInfo.");
    $dbh->do("update apidb.InstanceMetaInfo set current_updater = null, update_start = null")
    or ApiCommonData::Load::TuningConfig::Log::addErrorLog("\n" . $dbh->errstr . "\n");
  }

  return;
}

sub catch_signal {
        my $signame = shift;
        die "caught signal $signame";
}

sub checkLockout {

  my ($maxWait) = @_;
  my $wait = 0;

  until ($wait > $maxWait) {

    my $stmt = $dbh->prepare(<<SQL);
        select nvl((sysdate - update_start) * 24, $maxWait + 1) -- if we are not locked out, force the wait value to greater than maxWait
        from InstanceMetaInfo
SQL

    $stmt->execute();
    ($wait) = $stmt->fetchrow_array();

    if ($wait < $maxWait) {
      my $dateString = `date`;
      chomp($dateString);
      ApiCommonData::Load::TuningConfig::Log::addLog("Waiting for another tuning manager at $dateString");
      sleep (300);
    }
  }

}
