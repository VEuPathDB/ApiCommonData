#!/usr/bin/perl

use strict;

use lib "$ENV{GUS_HOME}/lib/perl";

use DBI;

use CBIL::Bio::SequenceUtils; #reverseComplementSequence
use CBIL::Util::PropertySet;

my ($gusConfigFile, $organismAbbrev, $projectId, $schema, $mode);
&GetOptions("gusConfigFile=s" => $gusConfigFile,
	    "projectName=s" => \$projectId,
	    "organismAbbrev=s" => \$organismAbbrev,
	    "schema=s" => \$organismAbbrev,
            "mode=s" => \$mode);  # parent or child

my $TABLENAME = "TranscriptGenomicSequence";

my @properties = ();
my $gusconfig = CBIL::Util::PropertySet->new($gusConfigFile, \@properties, 1);

my $u = $gusconfig->{props}->{databaseLogin};
my $pw = $gusconfig->{props}->{databasePassword};
my $dsn = $gusconfig->{props}->{dbiDsn};

my $dbh = DBI->connect($dsn, $u, $pw) or die DBI::errstr;
$dbh->{RaiseError} = 1;
$dbh->{AutoCommit} = 0;

my $createSqlSelect = "
        select '$orgAbbrev' as org_abbrev, '$projectId' as project_id, current_timestamp as modification_date,
               gf.source_id as gene_source_id, t.source_id,
               nas.sequence as genomic_sequence,
               length(nas.sequence) as genomic_sequence_length
        from dots.NaSequence nas, dots.GeneFeature gf, dots.Transcript t
        where 1 = 0
";

if ($mode eq 'parent') {
  createParentTable($dbh, $createSqlSelect, $schema, $projectId, $orgAbbrev);
} else {
  createChildTable($dbh, $createSqlSelect, $schema, $projectId, $orgAbbrev);
  populateChildTable($dbh, $schema, $projectId, $orgAbbrev);
}

#################################################################################################

sub createParentTable {
  my ($dbh, $createSelectSql, $schema, $projectId, $orgAbbrev) = @_;

 $dbh->do("drop table if exists $schema.tgs_temporary");

  my $createTmpSql = "
create table $schema.tgs_temporary as
$createSqlSelect
";
  $dbh->do($createTmpSql);

  my $createSql = "
create table $schema.$TABLENAME (like $schema.tgs_temporary including all)
partition by list(org_abbrev)";

  $dbh->do($createSql);

  $dbh->do("drop table $schema.tgs_temporary");

  $dbh->do("create unique index txgseq_idx on $schema.$TABLENAME (source_id, gene_source_id, project_id)");

}

sub createChildTable {
  my ($dbh, $createSelectSql, $schema, $projectId, $orgAbbrev) = @_;

  my $sql = "
create table $schema.${TABLENAME}_$orgAbbrev
partition of $schema.${TABLENAME}
for values in ('$orgAbbrev')
";

  $dbh->do($sql);
}

sub populateChildTable {
  my ($dbh, $schema, $projectId, $orgAbbrev) = @_;

  my $insertSql = "INSERT INTO $schema.$TABLENAME
    (gene_source_id, source_id, project_id,
     genomic_sequence, genomic_sequence_length)
 VALUES (?,?,?,?,?)";
  my $insertSh = $dbh->prepare($insertSql);

  my $sql = "SELECT ga.source_id AS gene_source_id
     , ga.project_id AS project_id
     , t.source_id
     , tl.start_min
     , tl.end_max
     , tl.is_reversed
     , gss.source_id
     , gss.sequence
FROM apidb.transcriptlocation tl
   , apidbtuning.geneattributes ga
   , dots.transcript t
   , apidbtuning.genomicsequencesequence gss
WHERE t.na_feature_id  = tl.na_feature_id
AND t.parent_id = ga.na_feature_id
AND tl.sequence_source_id = gss.source_id
ORDER BY gss.source_id";


  my $sh = $dbh->prepare($sql)
    or die "Can't prepare SQL statement: " . $dbh->errstr();
  $sh->execute();

  my ($prevSequenceSourceId, $sequence, $count);
  while (my ($geneSourceId, $projectId, $sourceId, $start, $end, $isReversed, $sequenceSourceId, $sequence) = $sh->fetchrow_array()) {

    my $substrStart = $start - 1;
    my $substrLength = $end - $start + 1;

    my $transcriptGenomicSequence = substr($sequence, $substrStart, $substrLength);

    if ($isReversed) {
      $transcriptGenomicSequence = CBIL::Bio::SequenceUtils::reverseComplementSequence($transcriptGenomicSequence);
    }

    $insertSh->execute($geneSourceId, $sourceId, $projectId, $transcriptGenomicSequence, $substrLength);

    if ($count++ % 200000 == 0) {
      print STDERR "Commit point; count = $count\n";
      $dbh->commit();
    }
  }

  $dbh->commit();
}


1;
