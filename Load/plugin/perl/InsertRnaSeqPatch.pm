package ApiCommonData::Load::Plugin::InsertRnaSeqPatch;
@ISA = qw(ApiCommonData::Load::Plugin::InsertStudyResults);

use lib "$ENV{GUS_HOME}/lib/perl";
use ApiCommonData::Load::Plugin::InsertStudyResults;
use GUS::PluginMgr::Plugin;
use GUS::Model::Study::ProtocolAppNode;
use GUS::Model::SRes::OntologyTerm;

use Data::Dumper;

use strict;
use warnings;

my $argsDeclaration =                                                                                                                             
[
    fileArg({name           => 'inputDir',
        descr          => 'Directory in which to find input files',
        reqd           => 1,
        mustExist      => 1,
        format         => '',
        constraintFunc => undef,
        isList         => 0, }),

    stringArg({name => 'extDbSpec',
          descr => 'External database from whence this data came|version',
          constraintFunc=> undef,
          reqd  => 1,
          isList => 0
         }),

    stringArg({name => 'studyName',
          descr => 'Name of the Study;  Will be added if it does not already exist',
          constraintFunc=> undef,
          reqd  => 1,
          isList => 0
         }),

    fileArg({name           => 'configFile',
        descr          => 'Name of config file, describes the profiles being loaded - this is generated by the plugin.',
        reqd           => 1,
        mustExist      => 0,
        format         => 'Tab file with header',
        constraintFunc => undef,
        isList         => 0
      }), # Needs to be here even though always the same as InsertStudyResults uses this value.

];

my $purpose = <<PURPOSE;                                                                                                                          
To update RNAseq profiles after a patch build
PURPOSE

my $purposeBrief = <<PURPOSE_BRIEF;
To update RNAseq profiles after a patch build
PURPOSE_BRIEF

my $notes = <<NOTES;
NOTES

my $tablesAffected = <<TABLES_AFFECTED;
TABLES_AFFECTED

my $tablesDependedOn = <<TABLES_DEPENDED_ON;
TABLES_DEPENDED_ON

my $howToRestart = <<RESTART;
There are no restart facilities for this plugin
RESTART

my $failureCases = <<FAIL_CASES;
FAIL_CASES

my $documentation = {purpose   => $purpose,
              purposeBrief     => $purposeBrief,
              notes            => $notes,
              tablesAffected   => $tablesAffected,
              tablesDependedOn => $tablesDependedOn,
              howToRestart     => $howToRestart,
              failureCases     => $failureCases };

sub new {
    my ($class) = @_;
    my $self = {};
    bless($self, $class);

    $self->initialize({ requiredDbVersion => 4.0,
                        cvsRevision => '$Revision$',
                        name => ref($self),
                        argsDeclaration => $argsDeclaration,
                        documentation => $documentation});
}

sub run {
    my ($self) = @_;
    $self->SUPER::run();
}

sub makeProtocolAppNode {
    my ($self, $nodeName, $existingAppNodes, $nodeOrderNum, $appNodeType) = @_;
    print Dumper "In InsertRnaSeqPatch subclass\n";
       
    my $ontologyTerm = GUS::Model::SRes::OntologyTerm->new({name => $appNodeType});
    unless ($ontologyTerm->retrieveFromDB()) {
        $self->error("Required ontology term \"$appNodeType\" either is not found in the database or returns more than one row from the database");
    }

    foreach my $e (@$existingAppNodes) {
        my $existingName = $e->getName();

        if ($nodeName eq $existingName) {
            $self->log("WARN:  Study already contains ProtocolAppNode Named $nodeName. In the InsertRnaSeqPatch plugin, this is expected for htseq-union and DESeq2Analysis nodes, but should be checked if other node types are reported here\n");
            return $e;
        }
    }
    my $protocolAppNode = GUS::Model::Study::ProtocolAppNode->new({name => $nodeName, node_order_num => $nodeOrderNum, type_id => $ontologyTerm->getId()});
    return $protocolAppNode;
}

# Delete input and output rows to avoid loading duplicates
# these are not in the main undoTables method because we want to constrain by more than just rowAlgInvId
# only want to undo rows associated with profiles and DE results not intron junctions
sub undoPreprocess {
    my ($self, $dbh, $rowAlgInvocationList) = @_;
    my $rowAlgInvocations = join(',', @{$rowAlgInvocationList});

    #get PAN ids for results we are going to back out
    my $panSql = "SELECT DISTINCT protocol_app_node_id
                 FROM (
                     SELECT protocol_app_node_id FROM results.nafeatureexpression WHERE row_alg_invocation_id IN ($rowAlgInvocations)
                     UNION
                     SELECT protocol_app_node_id FROM results.nafeaturediffresult WHERE row_alg_invocation_id IN ($rowAlgInvocations)
                 )";

    my $panSh = $dbh->prepare($panSql);
    $panSh->execute();
    my @panIdList;
    while (my ($panId) = $panSh->fetchrow_array()) {
        push @panIdList, $panId;
    }
    $panSh->finish();
    my $panIds = join(',', @panIdList);

    # delete input and output rows
    my $deleteStudyInputsSql = "DELETE FROM study.input
                                WHERE protocol_app_node_id IN ($panIds)";

    my $deleteStudyOutputsSql = "DELETE FROM study.output
                                 WHERE protocol_app_node_id IN ($panIds)";

    # delete protocol apps
    my $deleteProtocolAppsSql = "DELETE FROM study.protocolapp
                                WHERE protocol_app_id IN (
                                    SELECT DISTINCT protocol_app_id FROM (
                                        SELECT protocol_app_id FROM study.input WHERE protocol_app_node_id IN ($panIds)
                                        UNION
                                        SELECT protocol_app_id FROM study.output WHERE protocol_app_node_id IN ($panIds)
                                    )
                                )";

    $dbh->do($deleteStudyInputsSql);
    $dbh->do($deleteStudyOutputsSql);
    $dbh->do($deleteProtocolAppsSql);

}

#undo using this plugin will only back out profiles and leave everything else
sub undoTables {
    my ($self) = @_;
    
    return (
        'Results.NAFeatureExpression',
        'Results.NAFeatureDiffResult',
        );
}

1;  
