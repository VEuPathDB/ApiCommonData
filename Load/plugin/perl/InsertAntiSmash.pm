package ApiCommonData::Load::Plugin::InsertAntiSmash;

@ISA = qw(GUS::PluginMgr::Plugin);

use strict;
use warnings;
use JSON;
use IO::Zlib;
use Bio::Tools::GFF;
use GUS::PluginMgr::Plugin;
use GUS::Supported::Util;
use GUS::Model::ApiDB::antiSmashCluster;
use GUS::Model::ApiDB::antiSmashFeature;
use GUS::Model::ApiDB::AntismashClusterFeature;
use Data::Dumper;
use ApiCommonData::Load::AnalysisConfigRepeatFinder qw(displayAndBaseName);

my $argsDeclaration =
  [

	   fileArg({ name => 'gffFile',
                     descr => 'gff file generated by talon',
                     constraintFunc=> undef,
                     reqd  => 1,
                     isList => 0,
                     mustExist => 1,
                     format=>'Text',
                   }), 
        stringArg({name => 'extDbSpec',
                     descr => 'External database from whence this data came|version',
                     constraintFunc=> undef,
                     reqd  => 1,
                     isList => 0,
                 }),
        stringArg({name => 'ncbiTaxonId',
                     descr => 'ncbiTaxonId for this dataset',
                     constraintFunc=> undef,
                     reqd  => 1,
                     isList => 0
             })

  ];

my $documentation = { purpose          => "",
                      purposeBrief     => "",
                      notes            => "",
                      tablesAffected   => "",
                      tablesDependedOn => "",
                      howToRestart     => "",
                      failureCases     => "" };

sub new {
    my ($class) = @_;
    my $self = {};
    bless($self,$class);

    $self->initialize({ requiredDbVersion => 4,
                      cvsRevision       => '$Revision$',
                      name              => ref($self),
                      argsDeclaration   => $argsDeclaration,
                      documentation     => $documentation});

    return $self;
}

# ======================================================================                                                                                                                                    

sub run {
    my ($self) = @_;
       
    my $ncbiTaxonId = $self->getArg('ncbiTaxonId');

    my $gffFile = $self->getArg('gffFile');

    my $dbh = $self->getQueryHandle();

    my $foundTaxId = &checkParent($ncbiTaxonId,$dbh);

    my $extDbSpec = $self->getArg('extDbSpec');

    my $extDbRlsId = $self->getExtDbRlsId($extDbSpec) or die "Couldn't find source db: $extDbSpec";    

    if ($foundTaxId) {
	$self->loadClusters($gffFile, $extDbRlsId, $dbh);
    }

    return $self;
}

sub checkParent {
    my ($taxonId,$dbh) = @_;

    my $query = $dbh->prepare(&checkParentSql($taxonId));

    $query->execute();
    my $taxId = $query->fetchrow_array();

    $query->finish();
    return $taxId;
}

sub checkParentSql {
    my ($taxonId) = @_;
    return "
        WITH RECURSIVE taxon_tree AS (
            SELECT t.taxon_id, t.ncbi_tax_id, t.parent_id, t.rank
            FROM sres.taxon t
            WHERE t.ncbi_tax_id = 4751
            UNION ALL
            SELECT c.taxon_id, c.ncbi_tax_id, c.parent_id, c.rank
            FROM sres.taxon c
            JOIN taxon_tree p ON c.parent_id = p.taxon_id
        )
        SELECT ncbi_tax_id
        FROM taxon_tree
        WHERE ncbi_tax_id = $taxonId
    ";
}

sub loadClusters {
    my ($self, $gffFile, $extDbRlsId, $dbh) = @_;

    my $fh;
    if ($gffFile =~ /\.gz$/) {
        open($fh, "-|", "gzip", "-dc", $gffFile)
	    or die "Could not open '$gffFile' via gzip: $!";
    } else {
        open($fh, "<", $gffFile)
	    or die "Could not open '$gffFile': $!";
    }

    my $gffIo = Bio::Tools::GFF->new(-fh => $fh, -gff_version => 3);

    my ($clusterCount, $featureCount) = (0, 0);

    # Collect BioPerl feature objects for later overlap analysis
    my @clusterFeatures;
    my @geneFeatures;

    while (my $feature = $gffIo->next_feature()) {
        my $primaryTag = $feature->primary_tag();

        my ($name) = $feature->has_tag('ID') ? $feature->get_tag_values('ID') : undef;
        next unless defined $name;

        my $start = $feature->start();
        my $end   = $feature->end();

        if ($primaryTag eq 'protocluster') {
            my ($category) = $feature->has_tag('category') ? $feature->get_tag_values('category') : undef;

            my $row_cluster = GUS::Model::ApiDB::antiSmashCluster->new({
                cluster_name                  => $name,
                cluster_start                 => $start,
                cluster_end                   => $end,
                category                      => $category,
                external_database_release_id  => $extDbRlsId
								       });
            $row_cluster->submit();
            $clusterCount++;

            # Store GUS ID as a tag in the BioPerl feature object
            $feature->add_tag_value('gus_id', $row_cluster->getId());
            push @clusterFeatures, $feature;
        }
        elsif ($primaryTag eq 'gene') {
            my ($gene_kind) = $feature->has_tag('gene_kind')
                ? $feature->get_tag_values('gene_kind')
                : "";

	    my $sql = "SELECT na_feature_id FROM dots.nafeatureimp WHERE source_id = ?";
	    my $sth = $dbh->prepare($sql);
	    $sth->execute($name);

	    my ($naFeatureId) = $sth->fetchrow_array();
	    $sth->finish();

	    if (defined $naFeatureId) {
  		my $row_features = GUS::Model::ApiDB::antiSmashFeature->new({na_feature_id => $naFeatureId,
                                                                             antiSmash_annotation => $gene_kind,
                                                                             external_database_release_id => $extDbRlsId
									   });
		$row_features->submit();
		$featureCount++;

                # Store GUS ID as a tag in the BioPerl feature object
                $feature->add_tag_value('gus_id', $row_features->getId());
                push @geneFeatures, $feature;
            }
        }

        # Clear cache periodically
        $self->undefPointerCache() if (($clusterCount + $featureCount) % 500) == 0;
    }

    close $fh;

    # Now iterate over protoclusters and find overlapping gene features
    my $clusterFeatureCount = 0;
    $self->log("Finding overlaps between $clusterCount clusters and $featureCount gene features");

    foreach my $clusterFeature (@clusterFeatures) {
        my ($clusterGusId) = $clusterFeature->get_tag_values('gus_id');

        foreach my $geneFeature (@geneFeatures) {
            # Use BioPerl's overlaps method to check for overlap
            if ($clusterFeature->overlaps($geneFeature)) {
                my ($geneGusId) = $geneFeature->get_tag_values('gus_id');

                # Create association in AntismashClusterFeature table
                my $clusterFeatureRow = GUS::Model::ApiDB::AntismashClusterFeature->new({
                    antismash_cluster_id => $clusterGusId,
                    antismash_feature_id => $geneGusId
                });
                $clusterFeatureRow->submit();
                $clusterFeatureCount++;
            }
        }

        # Clear cache periodically
        $self->undefPointerCache() if ($clusterFeatureCount % 500) == 0;
    }

    $self->undefPointerCache();

    $self->log("Inserted $clusterCount clusters, $featureCount features, and $clusterFeatureCount cluster-feature associations from $gffFile");
    return { clusters => $clusterCount, features => $featureCount, cluster_features => $clusterFeatureCount };
}

sub undoTables {
    my ($self) = @_;

    return (
            'ApiDB.AntismashClusterFeature',
            'ApiDB.antiSmashFeature',
	    'ApiDB.antiSmashCluster'
           );
}

1;
