package ApiCommonData::Load::Plugin::InsertAntiSmash;
use lib "$ENV{GUS_HOME}/lib/perl";
@ISA = qw(GUS::PluginMgr::Plugin);

use strict;
use warnings;
use JSON;
use IO::Zlib;
use Bio::Tools::GFF;
use GUS::PluginMgr::Plugin;
use GUS::Supported::Util;
use GUS::Model::ApiDB::antiSmashCluster;
use GUS::Model::ApiDB::antiSmashFeatures;
use Data::Dumper;
use ApiCommonData::Load::AnalysisConfigRepeatFinder qw(displayAndBaseName);

sub getArgsDeclaration {
    my $argsDeclaration  =
            
       [   

        fileArg({ name => 'gffFile',
                     descr => 'gff file generated by talon',
                     constraintFunc=> undef,
                     reqd  => 1,
                     isList => 0,
                     mustExist => 1,
                     format=>'Text',
                   }), 
        fileArg({ name => 'analysisConfig',
                     descr => 'analysisConfig used for the analysis of the dataset',
                     constraintFunc=> undef,
                     reqd  => 1,
                     isList => 0,
                     mustExist => 1,
                     format=>'Text',
                   }), 
        stringArg({name => 'extDbSpec',
                     descr => 'External database from whence this data came|version',
                     constraintFunc=> undef,
                     reqd  => 1,
                     isList => 0
             })
        ];

    return $argsDeclaration;
}


sub getDocumentation {

    my $description = <<NOTES;
Load long read RNA seq transcript read counts obtained from talon.
NOTES

        my $purpose = <<PURPOSE;
Load long transcripts gene isoforms and read count determine by talon.
PURPOSE

        my $purposeBrief = <<PURPOSEBRIEF;
Load long read RNA seq transcripts counts.
PURPOSEBRIEF

        my $syntax = <<SYNTAX;
SYNTAX

        my $notes = <<NOTES;
NOTES

        my $tablesAffected = <<AFFECT;
ApiDB.longreadtranscript
AFFECT

        my $tablesDependedOn = <<TABD;
TABD

        my $howToRestart = <<RESTART;
There are no restart facilities for this plugin
RESTART

        my $failureCases = <<FAIL;
FAIL

        my $documentation = {purpose=>$purpose, purposeBrief=>$purposeBrief,tablesAffected=>$tablesAffected,tablesDependedOn=>$tablesDependedOn,howToRestart=>$howToRestart,failureCases=>$failureCases,notes=>$notes};

    return ($documentation);
}

sub new {
    my $class = shift;
    my $self = {}; 
    bless($self, $class);
        
    my $documentation = &getDocumentation();
        
    my $args = &getArgsDeclaration();
        
    $self->initialize({requiredDbVersion => 4.0,
                       cvsRevision => '$Revision$',
                       name => ref($self),
                       argsDeclaration   => $args,
                       documentation     => $documentation
                      }); 
    return $self;
}



sub loadClsuters{

	my ($self, $gffFile, $samplesConfig) = @_; 		
        my $extDbSpec = $self->getArg('extDbSpec');
        my $extDbRlsId = $self->getExtDbRlsId($extDbSpec) or die "Couldn't find source db: $extDbSpec";    
        my $samplesData = displayAndBaseName($samplesConfig); 

	
	my $fh = IO::Zlib->new($gff_file, "rb") or die "Cannot open $gff_file: $!\n";
    	while (my $line = <$fh>) {
        	chomp($line);
        	my @lineContent = split('\t', $line);
       		my $geneID = $lineContent[0];
        	my $region = $lineContent[2];
        	my $strand = $lineContent[6];
        	my $cluster_string = '';
        	my $feature_string = '';
        	my $noType = 'None';
        
        	if ($region  eq 'protocluster') {
           		my @region_split = split(';',$lineContent[8]);
            		my @id = split("=",$region_split[0]);
            		my $start = $lineContent[3];
            		my $end = $lineContent[4];
            		my @product = split("=",$region_split[2]);
            		#$cluster_string = "$geneID\t$id[1]\t$start\t$end\t$product[1]\n";
			
			my $row_cluster = GUS::Model::ApiDB::antiSmashCluster->new({
                                                                internal_id => $id[1],
                                                                cluster_start => $start,
                                                                cluster_end => $end,
                                                                category => $product[1],
                                                                external_database_release_id => $extDbRlsId});
                	$row_cluster->submit();
                	$self->undefPointerCache()
            		#print($cluster_string);
            
        	}    

        	if ($region  eq 'gene') {
            		my @region_split = split(';',$lineContent[8]);
            		my $start = $lineContent[3];
            		my $end = $lineContent[4];
            		my @product = split("=",$region_split[2]);
            		my @id = split("=",$region_split[0]);
            		if (my ($item) = grep /gene_kind/, @region_split ) {
                		my @product = split("=",$item);
				$kind = $product[1];
            		} else {
				$kind = 'None'
            		}
		#$feature_string = "$geneID\t$id[1]\t$start\t $end\t$kind\t$strand\n";
            	#print($feature_string);
            	my $row_features = GUS::Model::ApiDB::antiSmashFeatures->new({
                                                                antismash_feature_id => $,
                                                                internal_id => $,
                                                                na_feature_id => $,
                                                                gene_start => $start,
                                                                gene_end => $end,
                                                                antiSmash_annotation => $kind,
                                                                strand => $strand,
                                                                external_database_release_id => $extDbRlsId});
                $row_features->submit();
                $self->undefPointerCache()
        }
    }

}

sub undoTables {
  my ($self) = @_;

  return ('ApiDB.antiSmashCluster');
  return ('ApiDB.antiSmashFeatures');
}

1;
