package ApiCommonData::Load::Plugin::InsertAntiSmash;
use lib "$ENV{GUS_HOME}/lib/perl";
@ISA = qw(GUS::PluginMgr::Plugin);

use strict;
use warnings;
use JSON;
use IO::Zlib;
use Bio::Tools::GFF;
use GUS::PluginMgr::Plugin;
use GUS::Supported::Util;
use GUS::Model::ApiDB::antiSmashCluster;
use GUS::Model::ApiDB::antiSmashFeatures;
use GUS::Model::ApiDB::AntismashClusterFeature;
use Data::Dumper;
use ApiCommonData::Load::AnalysisConfigRepeatFinder qw(displayAndBaseName);

sub getArgsDeclaration {
    my $argsDeclaration  =
            
       [   

        fileArg({ name => 'gffFile',
                     descr => 'gff file generated by talon',
                     constraintFunc=> undef,
                     reqd  => 1,
                     isList => 0,
                     mustExist => 1,
                     format=>'Text',
                   }), 
        stringArg({name => 'extDbSpec',
                     descr => 'External database from whence this data came|version',
                     constraintFunc=> undef,
                     reqd  => 1,
                     isList => 0
             })
        ];

    return $argsDeclaration;
}


sub getDocumentation {

    my $description = <<NOTES;
Load long read RNA seq transcript read counts obtained from talon.
NOTES

        my $purpose = <<PURPOSE;
Load long transcripts gene isoforms and read count determine by talon.
PURPOSE

        my $purposeBrief = <<PURPOSEBRIEF;
Load long read RNA seq transcripts counts.
PURPOSEBRIEF

        my $syntax = <<SYNTAX;
SYNTAX

        my $notes = <<NOTES;
NOTES

        my $tablesAffected = <<AFFECT;
ApiDB.longreadtranscript
AFFECT

        my $tablesDependedOn = <<TABD;
TABD

        my $howToRestart = <<RESTART;
There are no restart facilities for this plugin
RESTART

        my $failureCases = <<FAIL;
FAIL

        my $documentation = {purpose=>$purpose, purposeBrief=>$purposeBrief,tablesAffected=>$tablesAffected,tablesDependedOn=>$tablesDependedOn,howToRestart=>$howToRestart,failureCases=>$failureCases,notes=>$notes};

    return ($documentation);
}

sub new {
    my $class = shift;
    my $self = {}; 
    bless($self, $class);
        
    my $documentation = &getDocumentation();
        
    my $args = &getArgsDeclaration();
        
    $self->initialize({requiredDbVersion => 4.0,
                       cvsRevision => '$Revision$',
                       name => ref($self),
                       argsDeclaration   => $args,
                       documentation     => $documentation
                      }); 
    return $self;
}



sub loadClsuters{

	my ($self, $gffFile) = @_; 		
        my $extDbSpec = $self->getArg('extDbSpec');
        my $extDbRlsId = $self->getExtDbRlsId($extDbSpec) or die "Couldn't find source db: $extDbSpec";    

	
	my $fh;
    	if($gffFile =~ /\.gz$/) {
        	open($fh, "gzip -dc $gffFile |") or die "Could not open '$gffFile': $!";
    	}	
    	else {
        	open($fh, $peptideResultFile) or die "Could not open '$peptideResultFile': $!";
    	}


	 my $gffIo = Bio::Tools::GFF->new(-fh => $fh, -gff_version => 3);

    	while (my $feature = $gffIo->next_feature()) {
        	my $primaryTag = $feature->primary_tag();
        	my $sourceTag = $feature->source_tag();
        	my $SourceId = $feature->seq_id();
        	my ($name) = $feature->get_tag_values('ID');
        	my $start = $feature->start();
        	my $end = $feature->end();
        	if ($primaryTag  eq 'protocluster') {
            		my ($category) = $feature->get_tag_values('category');
            		#print($name, "\t",$start, "\t", $end,"\t", $category, "\n");
			
			my $row_cluster = GUS::Model::ApiDB::antiSmashCluster->new({
                                                                 antismash_cluster_id => $,
								 cluster_name => $name
                                                                 cluster_start => $start,
                                                                 cluster_end => $end,
                                                                 category => $category,
                                                                 external_database_release_id => $extDbRlsId});
                         $row_cluster->submit();                 
                         $self->undefPointerCache()
        	}	

        	if ($primaryTag  eq 'gene') {
            		my ($gene_kind);
            		if ($feature->has_tag('gene_kind')){
                		($gene_kind) = $feature->get_tag_values('gene_kind');
            		} else {
                	($gene_kind) = ""
            	}
            	
			#print($name, "\t",$gene_kind, "\n");
			my $row_features = GUS::Model::ApiDB::antiSmashFeatures->new({
                                                                 antismash_feature_id => $,
                                                                 na_feature_id => $name,
                                                                 antiSmash_annotation => $gene_kind,
                                                                 external_database_release_id => $extDbRlsId});
                	 $row_features->submit();
                 	$self->undefPointerCache()

       	 	}
    	}

}

sub undoTables {
  my ($self) = @_;

  return ('ApiDB.antiSmashCluster');
  return ('ApiDB.antiSmashFeatures');
}

1;
