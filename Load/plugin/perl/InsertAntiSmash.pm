package ApiCommonData::Load::Plugin::InsertAntiSmash;

@ISA = qw(GUS::PluginMgr::Plugin);

use strict;
use warnings;
use JSON;
use IO::Zlib;
use Bio::Tools::GFF;
use GUS::PluginMgr::Plugin;
use GUS::Supported::Util;
use GUS::Model::ApiDB::antiSmashCluster;
use GUS::Model::ApiDB::antiSmashFeature;
use GUS::Model::ApiDB::AntismashClusterFeature;
use Data::Dumper;
use ApiCommonData::Load::AnalysisConfigRepeatFinder qw(displayAndBaseName);

my $argsDeclaration =
  [

	   fileArg({ name => 'gffFile',
                     descr => 'gff file generated by talon',
                     constraintFunc=> undef,
                     reqd  => 1,
                     isList => 0,
                     mustExist => 1,
                     format=>'Text',
                   }), 
        stringArg({name => 'extDbSpec',
                     descr => 'External database from whence this data came|version',
                     constraintFunc=> undef,
                     reqd  => 1,
                     isList => 0,
                 }),
        stringArg({name => 'ncbiTaxonId',
                     descr => 'ncbiTaxonId for this dataset',
                     constraintFunc=> undef,
                     reqd  => 1,
                     isList => 0
             })

  ];

my $documentation = { purpose          => "",
                      purposeBrief     => "",
                      notes            => "",
                      tablesAffected   => "",
                      tablesDependedOn => "",
                      howToRestart     => "",
                      failureCases     => "" };

sub new {
    my ($class) = @_;
    my $self = {};
    bless($self,$class);

    $self->initialize({ requiredDbVersion => 4,
                      cvsRevision       => '$Revision$',
                      name              => ref($self),
                      argsDeclaration   => $argsDeclaration,
                      documentation     => $documentation});

    return $self;
}

# ======================================================================                                                                                                                                    

sub run {
    my ($self) = @_;
       
    my $ncbiTaxonId = $self->getArg('ncbiTaxonId');

    my $gffFile = $self->getArg('gffFile');

    my $dbh = $self->getQueryHandle();

    my $foundTaxId = &checkParent($ncbiTaxonId,$dbh);

    if ($foundTaxId) {
        &loadClusters($gffFile);
    }

    return $self;
}

sub checkParent {
    my ($taxonId,$dbh) = @_;

    my $query = $dbh->prepare(&checkParentSql($taxonId));

    $query->execute();
    my $taxId = $query->fetchrow_array();

    $query->finish();
    return $taxId;
}

sub checkParentSql {
    my ($taxonId) = @_;
    return "
        WITH RECURSIVE taxon_tree AS (
            SELECT t.taxon_id, t.ncbi_tax_id, t.parent_id, t.rank
            FROM sres.taxon t
            WHERE t.ncbi_tax_id = 4751
            UNION ALL
            SELECT c.taxon_id, c.ncbi_tax_id, c.parent_id, c.rank
            FROM sres.taxon c
            JOIN taxon_tree p ON c.parent_id = p.taxon_id
        )
        SELECT ncbi_tax_id
        FROM taxon_tree
        WHERE ncbi_tax_id = $taxonId
    ";
}

sub loadClusters{

    my ($self, $gffFile) = @_; 
    my $extDbSpec = $self->getArg('extDbSpec');
    my $extDbRlsId = $self->getExtDbRlsId($extDbSpec) or die "Couldn't find source db: $extDbSpec";    

    
    my $fh;
    if($gffFile =~ /\.gz$/) {
        open($fh, "gzip -dc $gffFile |") or die "Could not open '$gffFile': $!";
    }
    else {
        open($fh, $gffFile) or die "Could not open '$gffFile': $!";
    }


    my $gffIo = Bio::Tools::GFF->new(-fh => $fh, -gff_version => 3);

    while (my $feature = $gffIo->next_feature()) {
        my $primaryTag = $feature->primary_tag();
        my $sourceTag = $feature->source_tag();
        my $SourceId = $feature->seq_id();
        my ($name) = $feature->get_tag_values('ID');
        my $start = $feature->start();
        my $end = $feature->end();
        if ($primaryTag  eq 'protocluster') {
            my ($category) = $feature->get_tag_values('category');
	    
	    my $row_cluster = GUS::Model::ApiDB::antiSmashCluster->new({
                                                                   cluster_name => $name,
                                                                   cluster_start => $start,
                                                                   cluster_end => $end,
                                                                   category => $category,
		                                                   external_database_release_id => $extDbRlsId
                                                                   });
	    $row_cluster->submit();                 
            $self->undefPointerCache();
	}

        if ($primaryTag  eq 'gene') {
            my ($gene_kind);
            
	    if ($feature->has_tag('gene_kind')){
                ($gene_kind) = $feature->get_tag_values('gene_kind');
	    } else {
                ($gene_kind) = ""
		    
	    }
            
	    my $row_features = GUS::Model::ApiDB::antiSmashFeature->new({
                                                                 na_feature_id => $name,
                                                                 antiSmash_annotation => $gene_kind,
                                                                 external_database_release_id => $extDbRlsId});
	    $row_features->submit();
	    $self->undefPointerCache();

	}
    }
}

sub undoTables {
    my ($self) = @_;

    return ('ApiDB.antiSmashCluster',
            'ApiDB.antiSmashFeatures',
            'ApiDB.AntismashClusterFeature'
           );
}

1;
