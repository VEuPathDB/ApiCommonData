<tracks>

<!--
Each query must return fields which corespond to GFF3 spec (order does not matter)

source - (required) name of the program that generated this feature, or the data source (database or project name)
feature - (required) feature type name, e.g. Gene, Variation, Similarity
startm - (required) Start position* of the feature, with sequence numbering starting at 1.
end - (required) End position* of the feature, with sequence numbering starting at 1.
score - A floating point value.
strand - (required) defined as + (forward) or - (reverse).
frame - One of '0', '1' or '2'. '0' indicates that the first base of the feature is the first base of a codon, '1' that the second base is the first base of a codon, and so on..
atts - A semicolon-separated list of tag-value pairs, providing additional information about each feature.
feature_id - (required) Unique ID for the Feature
parent_id - optional Unique ID of the parent feature
tstarts - optional comma sep list of subfeature starts
blocksizes - optional comma sep list of subfeature lengths
sequence_source_id - (required)
-->

   <!-- TrichDB,UniDB -->
  <track name="transposableElements" type="genomic" fileSuffix="gff">
   <sql>
     <![CDATA[
select l.sequence_source_id, l.na_feature_id as feature_id
     , 'transposableElement' as feature
     , 'VEuPathDB' as source
     , f.source_id as name
     , l.start_min as startm
     , l.end_max as end
     , case
       when l.is_reversed = 0 then '+'
       when l.is_reversed = 1 then '-'
       else '.' end as strand
     , concat('alignLength=', (l.end_max - l.start_min + 1)
            , '$dlm', 'sequence_id=', l.sequence_source_id
            , '$dlm', 'te_name=', f.name
            , '$dlm', 'dataset=', ed.name
            ) atts
from webready.featurelocation_p l, dots.TransposableElement f,
     sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr
where l.org_abbrev = '$org_abbrev'
  and l.na_feature_id = f.na_feature_id
  and f.external_database_release_id = edr.external_database_release_id
  and edr.external_database_id = ed.external_database_id
     ]]>
   </sql>
  </track>

  <track name="centromere" type="genomic" fileSuffix="gff">
  
    <sql>
      <![CDATA[
SELECT fl.sequence_source_id,
       fl.na_sequence_id feature_id,
       'centromere' feature,
       'VEuPathDB' source,
       fl.start_min startm,
       fl.end_max end,
       '+' strand
FROM webready.featurelocation_p fl, sres.OntologyTerm ot
WHERE fl.org_abbrev = '$org_abbrev'
  AND ot.ontology_term_id = fl.sequence_ontology_id
  AND ot.name = 'centromere'
      ]]>
    </sql>
  </track>

     <!-- TriTrypDB,FungiDB,UniDB -->
     <track name="spliceSites" type="genomic" fileSuffix="gff">
   <sql>
     <![CDATA[
 with singleDatasets as (
 SELECT seq.source_id as sequence_source_id
       , ssf.segment_start
       , ssf.strand
       , ssf.count_per_million
       , gtable.gene_source_id
       , ssf.type
       , gtable.dist_to_cds
       , ed.name as dataset
       , pan.name as sample
       , pan.protocol_app_node_id
 FROM study.nodeset s
        join sres.externaldatabaserelease edr
          on s.external_database_release_id = edr.external_database_release_id
        join sres.externaldatabase ed
          on ed.external_database_id = edr.external_database_id
        join study.nodenodeset sl
          on s.node_set_id = sl.node_set_id
        join study.protocolAppNode pan
          on sl.protocol_app_node_id = pan.protocol_app_node_id
        join apidb.spliceSiteFeature ssf
          on pan.protocol_app_NODE_ID = ssf.protocol_app_node_id
        join webready.SpliceSiteTranscript_p gtable
          on (ssf.na_sequence_id = gtable.na_sequence_id AND ssf.type = gtable.type AND ssf.strand=gtable.strand and gtable.location=ssf.segment_start)
        join webready.genomicseqattributes_p seq
          on ssf.na_sequence_id = seq.na_sequence_id
 WHERE ssf.type in ('Poly A', 'Splice Site')
   and ed.name not like '%TSS_raw_data%' -- some fungidb data was loaded as tss (see track below)
   and s.node_type = 'feature_loc'
   and ssf.count_per_million > 0
   and gtable.org_abbrev = '$org_abbrev'
   and seq.org_abbrev = '$org_abbrev'
  )
  select sequence_source_id
       , concat(sequence_source_id, '_' , dataset, '_', protocol_app_node_id, '_', segment_start) as feature_id
       , 'ss_pa_subfeature' as feature
       , concat(sequence_source_id , '_' , segment_start) as parent_id
       , 'VEuPathDB' as source
       , segment_start as startm
       , segment_start as end
       , strand
       , concat('total_count_per_million=', count_per_million
             , '$dlm', 'gene_id=', gene_source_id
             , '$dlm', 'feature_type=', type
             , '$dlm', 'utr_length=', dist_to_cds
             , '$dlm', 'ext_db_name=', dataset
             , '$dlm', 'sample=', sample
             ) as atts
  from singledatasets
  UNION
    select sequence_source_id
       , concat(sequence_source_id , '_' , segment_start) as feature_id
       , 'ss_pa' as feature
       , '' as parent_id
       , 'VEuPathDB' as source
       , segment_start as startm
       , segment_start as end
       , strand
       , concat('total_count_per_million=', sum(count_per_million)
             , '$dlm', 'gene_id=', gene_source_id
             , '$dlm', 'feature_type=', type
             , '$dlm', 'utr_length=', dist_to_cds
             ) as atts
  from singledatasets
  GROUP BY sequence_source_id, segment_start, strand, gene_source_id, dist_to_cds, type
      ]]>
    </sql>
  </track>


<!-- FungiDB,UniDB -->
<!-- One dataset: anidFGSCA4_Sibthorp_TSS_raw_data_rnaSeqSplicedLeaderAndPolyASites_RSRC -->
<!-- TODO this one needs to be bw ?? -->
<track name="sibthorp_tss" type="genomic" fileSuffix="gff">
   <sql>
     <![CDATA[
SELECT distinct concat(seq.source_id,
       ssf.segment_start as  feature_id,
       'sibthorp_tss' as feature,
       'VEuPathDB' as source,
       sum(ssf.count_per_million) as score,
       ssf.segment_start as startm,
       ssf.segment_start as end,
       ssf.strand
 FROM study.NodeSet s
      join sres.externaldatabaserelease edr on s.external_database_release_id = edr.external_database_release_id
      join sres.externaldatabase ed on ed.external_database_id = edr.external_database_id
      join study.NodeNodeSet sl on s.node_set_id = sl.node_set_id
      join apidb.SpliceSiteFeature ssf on ssf.protocol_app_node_id = sl.protocol_app_node_id
      join webready.genomicseqattributes_p seq on seq.na_sequence_id = ssf.na_sequence_id
 WHERE seq.org_abbrev = 'anidFGSCA4'
    and ssf.type = 'Splice Site'
    and s.node_type = 'feature_loc'
   and ed.name = 'anidFGSCA4_Sibthorp_TSS_raw_data_rnaSeqSplicedLeaderAndPolyASites_RSRC'
   and ssf.count_per_million > 1
  GROUP BY  ssf.segment_start, ssf.strand, ssf.na_sequence_id, ssf.strand
     ]]>
   </sql>
  </track>



  <track name="featureBindingSite" type="genomic" fileSuffix="gff">
    <sql>
      <![CDATA[
SELECT fl.sequence_source_id, 
       fl.na_feature_id feature_id,
       'BindingSite' feature,
       'VEuPathDB' source,
       '.' score,
       fl.start_min startm,
       fl.end_max end,
       case
         when fl.is_reversed = 0 then '+'
         when fl.is_reversed = 1 then '-'
         else '.' end as strand,
       concat('Name=', bs.name
            , '$dlm', 'Score=' , to_char(exp(bs.primary_score), '9.99EEEE')
            ) as atts
FROM
       dots.BindingSiteFeature bs,
       webready.featurelocation_p fl
WHERE
       fl.org_abbrev = '$org_abbrev' and
       bs.na_feature_id = fl.na_feature_id and
       fl.feature_type = 'BindingSiteFeature' -- probably redundant
ORDER BY
       fl.start_min
     ]]>
   </sql>
  </track>



  <track name="HaplotypeBlock" type="genomic" fileSuffix="gff">
    <sql>
      <![CDATA[
  SELECT fl.sequence_source_id
       , concat(cef.na_feature_id::varchar, 'liberal') feature_id
       , '' as parent_id
       , 'Haplotype_liberal' feature
       , 'VEuPathDB' source
       , '.' score
       , nl.start_min startm
       , nl.end_max end
       , '.' as strand
       , concat( 'Boundary=Liberal'
              , '$dlm', 'Name=',  cef.name
              , '$dlm', 'SequenceId=', fl.sequence_source_id
              , '$dlm', 'start_max=', nl.start_max
              , '$dlm', 'end_min=', nl.end_min
              , '$dlm', 'start_min=', nl.start_min
              , '$dlm', 'end_max=', nl.end_max
         ) as atts
  FROM dots.ChromosomeElementFeature cef
     , webready.featurelocation_p fl
     , dots.nalocation nl
  WHERE  cef.na_feature_id = nl.na_feature_id
  and nl.na_feature_id = fl.na_feature_id
  and fl.org_abbrev = '$org_abbrev'
UNION ALL
  SELECT fl.sequence_source_id
       , concat(cef.na_feature_id::varchar, 'conservative') feature_id
       , concat(cef.na_feature_id::varchar, 'liberal') parent_id
       , 'Haplotype_conservative' feature
       , 'VEuPathDB' source
       , '.' score
       , nl.start_max as startm
       , nl.end_min end
       , '.' as strand
       , concat( 'Boundary=Conservative'
              , '$dlm', 'Name=',  cef.name
              , '$dlm', 'SequenceId=', fl.sequence_source_id
         ) as atts
  FROM dots.ChromosomeElementFeature cef
     , webready.featurelocation_p fl
     , dots.nalocation nl
  WHERE  cef.na_feature_id = nl.na_feature_id
  and nl.na_feature_id = fl.na_feature_id
  and fl.org_abbrev = '$org_abbrev'
      ]]>
    </sql>
  </track>


   <!-- PlasmoDB,UniDB -->
   <track name="microsatelliteSts" type="genomic" fileSuffix="gff">
   <sql>
     <![CDATA[
 select l.sequence_source_id,
        S.na_feature_id as feature_id,
        'Microsatellite' feature,
        'VEuPathDB' source,
        l.start_min startm,
        l.end_max end,
        case
         when l.is_reversed = 0 then '+'
         when l.is_reversed = 1 then '-'
         else '.' end as strand,
               concat('Name=',  s.name,  '$dlm', 'SequenceId=',  nas.source_id) as  atts
 from dots.Sts s, sres.OntologyTerm ot,
      webready.featurelocation_p l, dots.NaSequence nas
 where l.org_abbrev = '$org_abbrev'
    and s.na_feature_id = l.na_feature_id
   and nas.na_sequence_id = s.na_sequence_id
   and s.sequence_ontology_id = ot.ontology_term_id
   and ot.name = 'microsatellite'
     ]]>
   </sql>
  </track>


<!-- TODO
  <track name="scaffoldGenome" type="genomic" fileSuffix="gff">
   <sql>
     <![CDATA[
select sgf.na_feature_id as feature_id,
     'scaffold' type,
     'genome' source,     
      'gap' as name,
      nal.start_min as startm,
      nal.end_max as end,
      '0' strand,
      'Length=' || (nal.end_max-nal.start_min+1) || '$dlm' ||
      'Type=' ||  'gap'  || '$dlm' ||
      'Note=' ||  ''  atts
from DOTS.scaffoldgapfeature sgf, dots.nalocation nal
where nal.na_feature_id = sgf.na_feature_id
and sgf.na_sequence_id = $srcfeature_id
UNION ALL
select p.agp_piece_id as feature_id, 
     'scaffold' type,
     'genome' source,
      p.piece_id name,
      p.start_min as startm,
      p.end_max as end,
      decode(p.is_reversed, '0', '+1', '1', '-1', '0') strand,
      'Length=' || (p.end_max - p.start_min + 1) || '$dlm' ||
      'Type=scaffold' ||'$dlm' ||
      'Note=' || p.piece_id atts
from webready.genomicseqattributes gsa, apidb.agpPiece p
where gsa.org_abbrev = $org_abbrev
and gsa.source_id = p.source_id
and not p.piece_id is null
and gsa.na_sequence_id = $srcfeature_id
UNION ALL
SELECT sg.na_feature_id as feature_id,
       'gap' type,
       'genome' source,
       sg.source_id name,
       fl.start_min as startm,
       fl.end_max as end,
       '0' as strand,
       'Type=sgap' as atts
FROM   DoTS.ScaffoldGapFeature sg,
       DoTS.NaLocation fl,
       Webready.GenomicSeqAttributes gsa
WHERE  gsa.org_abbrev = $org_abbrev
   AND fl.na_feature_id = sg.na_feature_id
   AND gsa.na_sequence_id = sg.na_sequence_id
   AND gsa.na_sequence_id = $srcfeature_id
     ]]>
   </sql>
  </track>
-->

<!-- TODO
  <track name="gsnapUnifiedIntronJunctionNew" type="genomic" fileSuffix="gff">
   <sql>
     <![CDATA[
                select gij.intron_feature_id as feature_id,
                       gij.na_sequence_id as parent_id,
                       gij.segment_start as startm, gij.segment_end as end,
                       'VEuPathDB' as source, gij.contained,
                       gij.matches_gene_strand as matchesgenestrand,
                       gij.total_unique as score, gij.total_unique as totalscore,
                       gij.total_isrpm as isrpm, gij.intron_feature_id as name,
                       gij.percent_max as intronpercent, gij.annotated_intron,
                       gij.annotated_intron as annotatedintron,
                       gij.gene_source_id as
 genesourceid, gij.gene_na_feature_id, 
                       gij.is_reversed, gij.is_reversed as isreversed,
                       case
                         when gij.annotated_intron = 'Yes'
                              or (gij.total_unique
                                  >= case
                                       when contained = 1
                                         then stats.perc01_annot_score
                                       else 5 * stats.perc01_annot_score
                                     end
                                  and (gij.contained = 0 or gij.percent_max >= 2 /*stats.perc0005_annot_percent_max*/)
                                 )
                           then 'Strong Evidence'
                         else 'Weak Evidence'
                       end as evidence,
                       decode (to_char(is_reversed), 0, '+1', 1, '-1', '.') strand
                from webready.GeneIntronJunction gij, webready.genomicseqjunctionstats stats
                where gij.org_abbrev = $org_abbrev
                  and gij.na_sequence_id = $srcfeature_id
                  and gij.na_sequence_id = stats.na_sequence_id
                  and stats.org_abbrev = $org_abbrev
                  and gij.segment_end - gij.segment_start <= stats.max_intron_length * 4
                  and (gij.annotated_intron = 'Yes'
                       or (gij.total_unique
                           >= case
                                when contained = 1
                                  then stats.min_annot_score
                                else 5 * stats.min_annot_score
                              end
                           and (gij.contained = 0
                                or gij.percent_max >= stats.min_annot_percent_max)
                    )
                   )

     ]]>
   </sql>
  </track>
-->


<!-- TODO
  <track name="gsnapUnifiedintronjunctionHCOnly" type="genomic" fileSuffix="gff">
   <sql>
     <![CDATA[
                select gij.intron_feature_id as feature_id,
                       'gsnap' as feature,
                       to_char(gij.na_sequence_id) as parent_id,
                       gij.segment_start as startm,
                       gij.segment_end as end,
                       'VEuPathDB' as source,
                     gij.contained,
                     gij.matches_gene_strand as matchesgenestrand,
                       gij.total_unique as score,
                     gij.total_unique as totalscore,
                     gij.total_isrpm as isrpm,
                     'Score='||gij.total_unique||', ISRPM='||gij.total_isrpm as name,
                     gij.percent_max as intronpercent,
                     gij.annotated_intron as annotatedintron,
                     gij.gene_source_id as genesourceid,
                     gij.gene_na_feature_id, 
                     gij.is_reversed,
                       decode (to_char(is_reversed), 0, '+1', 1, '-1', '.') strand,
                        null as tstarts, null as blocksizes, null as atts, null as frame
                from webready.GeneIntronJunction gij, webready.genomicseqjunctionstats stats
                where gij.org_abbrev = $org_abbrev
                  and gij.na_sequence_id = $srcfeature_id
                  and gij.na_sequence_id = stats.na_sequence_id
                  and stats.org_abbrev = $org_abbrev
                  and gij.segment_end - gij.segment_start <= stats.max_intron_length * 2
                  and gij.annotated_intron = 'No'
                  and gij.total_unique >=  CASE WHEN contained = 1 THEN stats.perc01_annot_score ELSE 5*stats.perc01_annot_score END
                  and (gij.contained = 0 or gij.percent_max >= 2 
                      )
              UNION ALL

                select intron_feature_id as feature_id,
                       'gsnap' as feature,
                       intron_feature_id as parent_id,
                     'gsnap' as type,
                       segment_start - 10 as startm,
                       segment_end + 10 as end,
                       'VEuPathDB' as source,
                     contained,
                     matches_gene_strand,
                     percent_max,
                       total_unique as score,
                       decode (to_char(is_reversed), 0, '+1', 1, '-1', '.') strand,
                     annotated_intron,
                       to_char(segment_start - 10) || ',' || to_char(segment_end + 1) as tstarts,
                       to_char(10) || ',' || to_char(10) as blocksizes, null as atts, null as frame
                from webready.GeneIntronJunction gij, webready.genomicseqjunctionstats stats
                where gij.org_abbrev = $org_abbrev
                  and gij.na_sequence_id = $srcfeature_id
                  and gij.na_sequence_id = stats.na_sequence_id
                  and stats.org_abbrev = $org_abbrev
                  and gij.segment_end - gij.segment_start <= stats.max_intron_length * 2
                  and gij.annotated_intron = 'No'
                  and gij.total_unique >=  CASE WHEN contained = 1 THEN stats.perc01_annot_score ELSE 5*stats.perc01_annot_score END
                  and (gij.contained = 0 or gij.percent_max >= 2 
                      )
     ]]>
   </sql>
  </track>
-->


<!-- TODO
  <track name="gsnapUnifiedintronjunctionLCOnly" type="genomic" fileSuffix="gff">
   <sql>
     <![CDATA[

                select gij.intron_feature_id as feature_id,
                       'gsnap' as feature,
                       to_char(gij.na_sequence_id) as parent_id,
                       gij.segment_start as startm,
                       gij.segment_end as end,
                       'VEuPathDB' as source,
                       gij.contained,
                       gij.matches_gene_strand as matchesgenestrand,
                       gij.total_unique as score,
                       gij.total_unique as totalscore, gij.total_isrpm as isrpm, 'Score='||gij.total_unique||', ISRPM='||gij.total_isrpm as name, gij.percent_max as intronpercent,gij.annotated_intron as annotatedintron, gij.gene_source_id as genesourceid, gij.gene_na_feature_id, 
                gij.is_reversed,
                       decode (to_char(is_reversed), 0, '+1', 1, '-1', '.') strand,
                  null as tstarts, null as blocksizes, null as atts, null as frame
                from Webready.GeneIntronJunction gij, Webready.Genomicseqjunctionstats stats
                where gij.org_abbrev = $org_abbrev
                and gij.na_sequence_id = $srcfeature_id
                and gij.na_sequence_id = stats.na_sequence_id
                and stats.org_abbrev = $org_abbrev
                AND gij.segment_end - gij.segment_start <= stats.max_intron_length * 4
                AND gij.annotated_intron = 'No'
                AND gij.total_unique >=  CASE WHEN contained = 1 THEN stats.min_annot_score ELSE 5*stats.min_annot_score END
                AND (gij.contained = 0 or gij.percent_max >= stats.min_annot_percent_max)
                AND gij.intron_feature_id not in (
                select gij.intron_feature_id
                from Webready.GeneIntronJunction gij, Webready.Genomicseqjunctionstats stats
                where gij.org_abbrev = $org_abbrev
                and gij.na_sequence_id = $srcfeature_id
                and gij.na_sequence_id = stats.na_sequence_id
                and stats.org_abbrev = $org_abbrev
                AND gij.segment_end - gij.segment_start <= stats.max_intron_length * 2
                AND gij.annotated_intron = 'No'
                AND gij.total_unique >=  CASE WHEN contained = 1 THEN stats.perc01_annot_score ELSE 5*stats.perc01_annot_score END
                AND (gij.contained = 0 or gij.percent_max >= 2 
                    )
               )
            UNION ALL

              select INTRON_FEATURE_ID as feature_id,
                     'gsnap' as feature,
                     intron_feature_id as PARENT_ID,
                     segment_start - 10 as startm,
                     segment_END + 10 as end,
                     'VEuPathDB' as source,
                     CONTAINED,
                     MATCHES_GENE_STRAND,
                     PERCENT_MAX,
                     total_unique as SCORE,
                     ANNOTATED_INTRON,
                     decode (to_char(is_reversed), 0, '+1', 1, '-1', '.') strand,
                     to_char(segment_start - 10) || ',' || to_char(segment_end + 1) as tstarts,
                     to_char(10) || ',' || to_char(10) as blocksizes, null as atts, null as frame
                from Webready.GeneIntronJunction gij, Webready.Genomicseqjunctionstats stats
                where gij.org_abbrev = $org_abbrev
                and gij.na_sequence_id = $srcfeature_id
                and gij.na_sequence_id = stats.na_sequence_id
                and stats.org_abbrev = $org_abbrev
                AND gij.segment_end - gij.segment_start <= stats.max_intron_length * 4
                AND gij.annotated_intron = 'No'
                AND gij.total_unique >=  CASE WHEN contained = 1 THEN stats.min_annot_score ELSE 5*stats.min_annot_score END
                AND (gij.contained = 0 or gij.percent_max >= stats.min_annot_percent_max)
                AND gij.intron_feature_id not in (
                select gij.intron_feature_id
                from Webready.GeneIntronJunction gij, Webready.Genomicseqjunctionstats stats
                where gij.org_abbrev = $org_abbrev
                and gij.na_sequence_id = $srcfeature_id
                and gij.na_sequence_id = stats.na_sequence_id
                and stats.org_abbrev = $org_abbrev
                AND gij.segment_end - gij.segment_start <= stats.max_intron_length * 2
                AND gij.annotated_intron = 'No'
                AND gij.total_unique >=  CASE WHEN contained = 1 THEN stats.perc01_annot_score ELSE 5*stats.perc01_annot_score END
                AND (gij.contained = 0 or gij.percent_max >= 2 
                    )
               )
     ]]>
   </sql>
  </track>

-->

<!-- TODO
  <track name="gsnapUnifiedintronjunctionAnnotatedOnly" type="genomic" fileSuffix="gff">
   <sql>
     <![CDATA[
                select  gij.intron_feature_id as feature_id,
                       'gsnap' as feature,
                       to_char(gij.na_sequence_id) as parent_id,
                       gij.segment_start as startm,
                       gij.segment_end as end,
                       'VEuPathDB' as source,
                     gij.contained, gij.matches_gene_strand as matchesgenestrand,
                       gij.total_unique as score,
                     gij.total_unique as totalscore, gij.total_isrpm as isrpm,
                       'Score=' || gij.total_unique || ', ISRPM='||gij.total_isrpm as name,
                       gij.percent_max as intronpercent,gij.annotated_intron as annotatedintron, gij.gene_source_id as genesourceid, gij.gene_na_feature_id, 
                gij.is_reversed,
                       decode (to_char(is_reversed), 0, '+1', 1, '-1', '.') strand,
                  null as tstarts, null as blocksizes, null as atts, null as frame
                from Webready.GeneIntronJunction gij, Webready.Genomicseqjunctionstats stats
                where gij.org_abbrev = $org_abbrev
                and gij.na_sequence_id= $srcfeature_id
                and gij.na_sequence_id = stats.na_sequence_id
                and stats.org_abbrev = $org_abbrev
                AND gij.segment_end - gij.segment_start <= stats.max_intron_length * 2
                AND gij.annotated_intron = 'Yes'
            UNION ALL

              select INTRON_FEATURE_ID as feature_id,
                     'gsnap' as feature,
                     intron_feature_id as PARENT_ID,
                     segment_start - 10 as startm,
                     segment_END + 10 as end,
                     'VEuPathDB' as source,
                     CONTAINED,
                     MATCHES_GENE_STRAND,
                     PERCENT_MAX,
                     total_unique as SCORE,
                       decode (to_char(is_reversed), 0, '+1', 1, '-1', '.') strand,
                     ANNOTATED_INTRON,
                     to_char(segment_start - 10) || ',' || to_char(segment_end + 1) as tstarts,
                     to_char(10) || ',' || to_char(10) as blocksizes, null as atts, null as frame
                from Webready.GeneIntronJunction gij, Webready.Genomicseqjunctionstats stats
                where gij.org_abbrev = $org_abbrev
                and gij.na_sequence_id= $srcfeature_id
                and gij.na_sequence_id = stats.na_sequence_id
                and stats.org_abbrev = $org_abbrev
                AND gij.segment_end - gij.segment_start <= stats.max_intron_length * 2
                AND gij.annotated_intron = 'Yes'
     ]]>
   </sql>
  </track>
              -->

<!-- TODO
  <track name="unifiedMassSpec" type="genomic" fileSuffix="gff">
   <sql>
     <![CDATA[
select feature_id, type, source, parent_id, min(startm) as startm, max(end) as end, name, atts from (
select msf.aa_feature_id as feature_id,
       'domain' type,
        'UnifiedMassSpecPeptides' source,
       fl.na_sequence_id as Parent_Id,
       fl.start_min as startm,
       fl.end_max as end,
       sdi.sample||'_'||msf.aa_sequence_id||'_'||aaloc.start_min||'_'||aaloc.end_max  as name,
       decode (fl.is_reversed, 0, '+1', 1, '-1', '.') strand,
       'Count=' || msf.spectrum_count || '$dlm' ||
       'ExtDbName=' || d.name || '$dlm' ||
       'Experiment=' || dsp.display_name  || '$dlm' ||
       'Sample=' || sdi.sample_display_name  || '$dlm' ||
       'PepSeq=' || dbms_lob.SUBSTR(aaseq.SEQUENCE, aaloc.end_max - aaloc.start_min + 1, aaloc.start_min) || '$dlm' ||
       'Color=' || sdi.html_Color Atts
from dots.massspecfeature msf
   , apidb.FeatureLocation fl
   , sres.externaldatabase d
   , sres.externaldatabaserelease r
   , APIDB.MASSSPECSUMMARY mss
   , study.protocolappnode pan
   , apidbtuning.sampledisplayinfo sdi
   , apidbtuning.datasetdatasource dd
   , apidbtuning.datasetpresenter dsp
   , dots.aasequence aaseq
   , dots.aalocation aaloc
where msf.na_feature_id = fl.na_feature_id
and msf.EXTERNAL_DATABASE_RELEASE_ID = r.EXTERNAL_DATABASE_RELEASE_ID
and r.EXTERNAL_DATABASE_ID = d.EXTERNAL_DATABASE_ID
and fl.na_sequence_id = $srcfeature_id
and fl.start_min >= $base_start
and fl.end_max <= $rend
and msf.MASS_SPEC_SUMMARY_ID = mss.MASS_SPEC_SUMMARY_ID
and d.name = sdi.DATASET_NAME
and mss.PROTOCOL_APP_NODE_ID = pan.PROTOCOL_APP_NODE_ID
and (pan.name in (sdi.sample, sdi.sample || ' (MS Summary)') or sdi.sample is null)
and d.name = dd.NAME
and dd.DATASET_PRESENTER_ID = dsp.DATASET_PRESENTER_ID
and msf.AA_SEQUENCE_ID = aaseq.aa_sequence_id
and msf.AA_FEATURE_ID = aaloc.aa_feature_id
)
group by feature_id, type, source, parent_id, name, atts
UNION
SELECT  msf.aa_feature_id || fl.start_min || fl.end_max as feature_id,
        'Peptide' type,
        '$source' as source,
        fl.start_min as startm,
        fl.end_max as end,
        msf.aa_feature_id as parent_id,
        decode (fl.is_reversed, 0, '+1', 1, '-1', '.') strand,
        'ExtDbName=' || ed.name atts
 FROM dots.MassSpecFeature msf, apidb.FeatureLocation fl,
       sres.externaldatabaserelease edr, sres.externaldatabase ed
 WHERE msf.na_feature_id = fl.na_feature_id
  AND  fl.start_min >= $base_start
  AND  fl.end_max <= $rend
  AND  fl.na_sequence_id = $srcfeature_id
  AND  msf.external_database_release_id = edr.external_database_release_id
  AND  edr.external_database_id = ed.external_database_id
     ]]>
   </sql>
  </track>
 -->


<!-- 
<track name="unifiedPostTraslationalMod" type="protein" fileSuffix="gff">
   <sql>
     <![CDATA[
se
with peptides as (
select ms.sample
     , ms.sample_display
     , ms.experiment
     , ms.PEPTIDE_AA_FEATURE_ID
     , ms.peptide_sequence
     , ms.spectrum_count
     , listagg(ms.residue_location + 1, ',') within group (order by ms.residue_location) as residues
     , listagg(ms.aa_start_min + 1, ',') within group (order by ms.residue_location) as aa_start_mins
     , listagg(ms.modification_type, ',') within group (order by ms.residue_location) as modification_type
FROM  ApiDBTuning.MSModifiedPeptideSummary ms
group by experiment, sample, sample_display, peptide_aa_feature_id, peptide_sequence, ms.SPECTRUM_COUNT
)
select ms.aa_sequence_id  || '_' || ms.residue_location feature_id
     , 'domain' type
     , 'UnifiedPostTraslationalMod' source
     , ms.residue || ' (location ' || ms.residue_location || ')' name
     , '.' phase
     , '.' score
     , null as parent_id
     ,  ms.residue_location + 1 startm
     ,  ms.residue_location + 1 end
     ,  '.' strand
     , 'Experiments='  || listagg(peptides.experiment, '|') within group (order by peptides.peptide_aa_feature_id) || '$dlm' ||
      'MSCounts='     || listagg(peptides.spectrum_count, '|') within group (order by peptides.peptide_aa_feature_id) || '$dlm' ||
      'Samples='      || listagg(peptides.sample_display, '|') within group (order by peptides.peptide_aa_feature_id) || '$dlm' ||
      'Ontologys='    || listagg(peptides.modification_type, '|') within group (order by peptides.peptide_aa_feature_id) || '$dlm' ||
      'PepSeqs='      || listagg(peptides.peptide_sequence, '|') within group (order by peptides.peptide_aa_feature_id) || '$dlm' ||
      'PepAAFeatIds=' || listagg(peptides.peptide_aa_feature_id, '|') within group (order by peptides.peptide_aa_feature_id) || '$dlm' ||
      'AAStartMins=' || listagg(peptides.aa_start_mins, '|') within group (order by peptides.peptide_aa_feature_id) || '$dlm' ||
      'ModificationType=' || ms.modification_type || '$dlm' ||
      'ResidueLocs=' || listagg(peptides.residues, '|') within group (order by peptides.peptide_aa_feature_id) as atts
from ApiDBTuning.MSModifiedPeptideSummary ms, peptides
where peptides.PEPTIDE_AA_FEATURE_ID = ms.peptide_aa_feature_id
    AND ms.aa_sequence_id = $srcfeature_id
    AND ms.aa_start_min <= $rend
    AND ms.aa_end_max >= $base_start
group by ms.residue_location, ms.residue, ms.aa_sequence_id, ms.modification_type
     ]]>
   </sql>
  </track>
 -->

</tracks>
