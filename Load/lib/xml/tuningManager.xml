<?xml version="1.0" encoding="UTF-8"?>
<tuningConfig>


  <tuningTable name="GoTermSummary">
    <!-- GoTermSummary: each row represents one GO term assignment to one gene.
         (Typically, a gene has multiple such assignments.) This is used for
          finding gene-GO mappings, such as for the gene-page GO table.
      -->
    <externalDependency name="core.TableInfo"/>
    <externalDependency name="dots.GeneFeature"/>
    <externalDependency name="dots.GoAssociation"/>
    <externalDependency name="dots.GoAssociationInstance"/>
    <externalDependency name="dots.GoAssociationInstanceLoe"/>
    <externalDependency name="dots.GoAssocInstEvidCode"/>
    <externalDependency name="dots.Transcript"/>
    <externalDependency name="dots.TranslatedAaFeature"/>
    <externalDependency name="sres.GoEvidenceCode"/>
    <externalDependency name="sres.GoRelationship"/>
    <externalDependency name="sres.GoTerm"/>
    <sql>
      <![CDATA[
CREATE TABLE GoTermSummary&1 NOLOGGING AS
SELECT gf.source_id,
       decode(ga.is_not, 0, '', 1, 'not', ga.is_not) as is_not,
                 gt.go_id, o.ontology, gt.name AS go_term_name,
                  gail.name AS source, gec.name as evidence_code
FROM dots.GeneFeature gf, dots.Transcript t,
     dots.TranslatedAaFeature taf, dots.GoAssociation ga,
     sres.GoTerm gt, dots.GoAssociationInstance gai,
     dots.GoAssociationInstanceLoe gail,
     dots.GoAssocInstEvidCode gaiec, sres.GoEvidenceCode gec,
     (SELECT gr.child_term_id AS go_term_id,
             DECODE(gp.name, 'biological_process', 'Biological Process',
                             'molecular_function', 'Molecular Function',
                             'cellular_component', 'Cellular Component',
                              gp.name)
             AS ontology
      FROM sres.GoRelationship gr, sres.GoTerm gp
      WHERE gr.parent_term_id = gp.go_term_id
        AND gp.go_id in ('GO:0008150','GO:0003674','GO:0005575')) o
WHERE gf.na_feature_id = t.parent_id
  AND t.na_feature_id = taf.na_feature_id
  AND taf.aa_sequence_id = ga.row_id
  AND ga.table_id = (SELECT table_id
                     FROM core.TableInfo
                     WHERE name = 'TranslatedAASequence')
  AND ga.go_term_id = gt.go_term_id
  AND ga.go_association_id = gai.go_association_id
  AND gai.go_assoc_inst_loe_id = gail.go_assoc_inst_loe_id
  AND gai.go_association_instance_id
      = gaiec.go_association_instance_id
  AND gaiec.go_evidence_code_id = gec.go_evidence_code_id
  AND gt.go_term_id = o.go_term_id(+)
ORDER BY o.ontology, gt.go_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index GoTermSum_sourceId_idx&1 ON GoTermSummary&1 (source_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="DatasetExampleSourceId" prefixEnabled="false">
    <!-- Each row maps a dataset onto an ID for which the dataset contains data;
         each dataset gets one such row.
         Used in dataset record queries.
      -->
    <externalDependency name="apidb.ProfileSet"/>
    <externalDependency name="sres.externaldatabase"/>
    <sql>
      <![CDATA[
CREATE TABLE DatasetExampleSourceId&1 NOLOGGING AS
with profiles as (
select p.source_id,
       d.name,
       row_number() over(partition by d.name
                         order by ga.chromosome_order_num, pe.value desc) as rn
from apidb.profileset ps, apidb.profile p, APIDB.profileelement pe,
     sres.externaldatabase d, sres.externaldatabaserelease r, apidbtuning.geneattributes ga
where ps.profile_set_id = p.profile_set_id
and ps.external_database_release_id = r.external_database_release_id
and r.external_database_id = d.external_database_id
and p.profile_id = pe.profile_id
and pe.value is not null
and p.source_id = ga.source_id (+)
)
select p.source_id as example_source_id,
       p.name as dataset
from profiles p
where p.rn = 1
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="OrganismAttributes" prefixEnabled="true">
    <!-- Stores per-organism information. Used by the organism record, as well
         as by project_id(), the function that maps an organism to a project.
      -->
    <internalDependency name="GeneAttributes"/>
    <internalDependency name="GeneId"/>
    <internalDependency name="IsolateAttributes"/>
    <internalDependency name="GoTermSummary"/>
    <internalDependency name="SageTagGene"/>
    <internalDependency name="ChIPchipGene"/>
    <internalDependency name="TFBSGene"/>
    <internalDependency name="EstAlignmentGeneSummary"/>
    <internalDependency name="EstAttributes"/>
    <internalDependency name="SequenceAttributes"/>
    <externalDependency name="apidb.dataSource"/>
    <externalDependency name="sres.externalDatabase"/>
    <externalDependency name="sres.externalDatabaseRelease"/>
    <externalDependency name="apidb.Profile"/>
    <externalDependency name="apidb.ProfileSet"/>
    <externalDependency name="dots.similarity"/>
    <externalDependency name="dots.nasequence"/>
    <externalDependency name="sres.TaxonName"/>
    <externalDependency name="core.TableInfo"/>
    <externalDependency name="dots.nalocation"/>
    <externalDependency name="apidb.phylogeneticprofile"/>
    <externalDependency name="apidb.Organism"/>
    <externalDependency name="apidb.massspecsummary"/>
    <externalDependency name="dots.snpfeature"/>
    <intermediateTable name="DataSourceCount"/>
    <intermediateTable name="CommunityCount"/>
    <intermediateTable name="ProfileCount"/>
    <intermediateTable name="IsolateCount"/>
    <intermediateTable name="GeneCount"/>

    <sql>
      <![CDATA[
CREATE TABLE DataSourceCount&1 nologging as ( 
        SELECT ds.taxon_id,
               max(case when ds.type = 'organellar_genome' 
                     then 1 
                     else 0 end) as isOrganellar,
               max(case when ds.type = 'isolates'
                         AND ds.subtype = 'HTS_SNP' 
                     then 1 
                     else 0 end) as hasHTSIsolate,
               max(case when ds.type = 'isolates'
                         AND ds.subtype = 'sequenceing_types' 
                     then 1 
                     else 0 end) as hasIsolate,      
               max(case when ds.type = 'epitope'
                     then 1 
                     else 0 end) as hasEpitope,     
               max(case when ds.type = 'transcript_expression'
                         AND ds.subtype = 'array'                       
                     then 1 
                     else 0 end) as hasArray                      
        FROM   apidb.DataSource ds
          group by ds.taxon_id
         )
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE CommunityCount&1 nologging as (
             select ga.taxon_id, count (distinct (case when ga.is_deprecated = 0
                  then gi.gene
                  else NULL 
                  end)) communityCount 
          from geneAttributes ga
              left outer join GeneId gi  on ga.source_id = gi.gene
               left outer join comments2.comments@prodn.login_comment lgc on gi.id = lgc.stable_id
          group by ga.taxon_id
        )
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE ProfileCount&1 nologging as (
        select ga.taxon_id,         
              count(distinct(case when lower(ps.name) like '%rt_pcr%' 
                                   and ga.is_deprecated = 0 
                                  then p.source_id
                                  else ''
                                   end)) as rtPCRCount,     
              count(distinct(case when lower(ds.name) like '%rna%' 
                                   and ga.is_deprecated = 0 
                                  then p.source_id
                                  else ''
                                   end)) as rnaSeqCount,
              count(distinct(case when ds.type = 'transcript_expression'
                                   and ds.subtype = 'array'
                                   and ga.is_deprecated = 0 
                                  then p.source_id
                                  else ''
                                   end)) as geneArrayCount
         from Apidb.DataSource ds
              inner join sres.externalDatabase ed on ds.name = ed.name
              inner join sres.externalDatabaseRelease edr on ed.external_database_id = edr.external_database_id
              inner join apidb.ProfileSet ps on ps.external_database_release_id =edr.external_database_release_id
              inner join apidb.Profile p on  ps.profile_set_id = p.profile_set_id       
              right outer join geneAttributes ga on ga.source_id = p.source_id
         group by ga.taxon_id
)
       
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE IsolateCount&1 nologging as (    
        SELECT count(distinct gene.source_id) as isolateCount, sim.taxon_id
        FROM (
          (SELECT i.source_id, tn.taxon_id, nas.source_id as sequence_source_id
           FROM dots.similarity s,
                IsolateAttributes i,
                core.tableinfo t, dots.nasequence nas, sres.taxonname tn
           WHERE s.query_id = i.na_sequence_id
             AND nas.na_sequence_id = s.subject_id
             AND t.table_id = s.subject_table_id
             AND t.table_id = s.query_table_id
             AND t.name = 'ExternalNASequence'
             AND tn.taxon_id = nas.taxon_id
             AND tn.name_class = 'scientific name'
             AND s.pvalue_exp <= -10
           ) sim left join
           (SELECT i.source_id, seq.source_id as sequence_id
            FROM  dots.similarity s, IsolateAttributes i,
                  GeneAttributes g, 
                  core.tableinfo t, dots.nalocation l, dots.nasequence seq
            WHERE s.query_id = i.na_sequence_id
              AND s.subject_id = g.na_sequence_id
              AND t.table_id = s.subject_table_id
              AND t.table_id = s.query_table_id
              AND s.min_subject_start <=  l.end_max
              AND s.max_subject_end >= l.start_min
              AND l.na_feature_id = g.na_feature_id
              AND g.na_sequence_id = seq.na_sequence_id
              AND t.name = 'ExternalNASequence'
            ) gene
           on gene.source_id = sim.source_id and gene.sequence_id = sim.sequence_source_id)
         GROUP BY sim.taxon_id
)
       
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE GeneCount&1 nologging as (    
select genomestat.taxon_id,
       genomestat.project_id,
       genomestat.database_version,
       genomestat.ncbi_tax_id,
       genomestat.Megabps,
       nvl(snpCount.ct,0) as snpCount,
       nvl(stg.ct,0) as SageTagGeneCount,
       nvl(count(distinct ga.source_id),0) as geneCount,
       nvl(sum(ga.is_pseudo),0) as pseudoGeneCount,
       nvl(sum(case when ga.gene_type ='protein coding'
                then 1
                else 0
                end),0) as codingGeneCount,
       nvl(sum(case when ga.gene_type ='protein coding'
                then 0
                else 1
                end),0) as otherGeneCount,
       nvl(count (distinct (case when ga.is_deprecated = 0
                  then ccg.gene_source_id
                  else NULL 
                  end)),0) ChipChipGeneCount ,
      nvl(count (distinct (case when ga.is_deprecated = 0
                  then pp.source_id
                  else NULL 
                  end)),0) orthologCount, 
      nvl(count (distinct (case when ga.is_deprecated = 0
                  then gts.source_id
                  else NULL 
                  end)),0) goCount, 
      nvl(count (distinct (case when ga.is_deprecated = 0
                  then tfbs.gene_source_id
                  else NULL 
                  end)),0) tfbsCount, 
      nvl(count (distinct (case when ga.is_deprecated = 0
                  then mss.aa_sequence_id
                  else NULL 
                  end)),0) proteomicsCount, 
      nvl(count (distinct (case when ga.is_deprecated = 0
                  then est.source_id
                  else NULL 
                  end)),0) estCount,
      nvl(count (distinct (case when ga.is_deprecated = 0
                  then ga.ec_numbers
                  else NULL 
                  end)),0) ecNumberCount
        FROM   GeneAttributes ga
               left outer join apidb.phylogeneticprofile pp on ga.source_id = pp.source_id
               left outer join gotermsummary gts on ga.source_id = gts.source_id
               left outer join TFBSGene tfbs on ga.source_id = tfbs.gene_source_id
               left outer join apidb.MassSpecSummary mss on ga.aa_sequence_id = mss.aa_sequence_id
               left outer join chipchipgene ccg on ga.source_id = ccg.gene_source_id
               left outer join (SELECT distinct s.gene as source_id 
                                  FROM EstAlignmentGeneSummary s, EstAttributes e 
                                  WHERE s.est_gene_overlap_length >= 100 
                                    AND s.is_best_alignment in (1) 
                                    AND s.percent_est_bases_aligned >= 20  
                                    AND s.percent_identity >= 90  
                                    AND e.best_alignment_count <= 1 
                                    AND e.source_id = s.accession   
                                    GROUP by s.gene HAVING count(*) >= 1) est on ga.source_id = est.source_id
          right outer join
         ( SELECT  project_id, taxon_id,
                 max(database_version) as database_version,
                CASE WHEN ncbi_tax_id > 9000000000 THEN NULL
                     ELSE ncbi_tax_id
                END ncbi_tax_id, 
                to_char(sum(length)/1000000,'9999.99') as megabps 
         FROM   SequenceAttributes 
         WHERE  is_top_level = 1
         GROUP BY project_ID, taxon_id, ncbi_tax_id
       ) genomestat on genomestat.taxon_id = ga.taxon_id
        left outer join 
        (SELECT count(distinct (case when ga.source_id is not null and ga.is_deprecated = 0
                                   then ga.source_id
                                   else ''
                                   end)) as ct, o.taxon_id 
       FROM Apidb.Organism o
            left outer join GeneAttributes ga on o.taxon_id = ga.taxon_id
            left outer join sageTagGene stg on ga.source_id = stg.gene_source_id
       GROUP BY o.taxon_id
        )  stg on ga.taxon_id =stg.taxon_id 
        left outer join       
      (SELECT count(distinct (case when ga.source_id is not null and ga.is_deprecated = 0
                                   then ga.source_id
                                   else ''
                                   end)) as ct, o.taxon_id 
       FROM Apidb.Organism o
            left outer join GeneAttributes ga on o.taxon_id = ga.taxon_id
            left outer join dots.snpfeature sf on ga.na_feature_id = sf.parent_id
       GROUP BY o.taxon_id
      ) snpCount on ga.taxon_id = snpCount.taxon_id
        group by genomestat.taxon_id,
                 genomestat.project_id,
                 genomestat.database_version,
                 genomestat.ncbi_tax_id,
                 genomestat.Megabps,
                 stg.ct,
                 snpCount.ct
)
       
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE OrganismAttributes&1 NOLOGGING AS
SELECT o.project_name as project_id,
       o.public_abbrev as source_id,
       o.family_name_for_files,
       tn.name as organism_name,
       o.genome_source,
       o.strain_abbrev,
       o.is_annotated_genome,
       o.is_reference_strain,
       o.is_family_representative,
       o.name_for_filenames,
       o.taxon_id as component_taxon_id,
       gc.database_version,
       gc.megabps as megabps,
       gc.ncbi_tax_id as ncbi_tax_id,
       gc.snpCount as snpCount,
       gc.sagetagGeneCount as sageTagCount,
       gc.geneCount as geneCount,
       gc.pseudoGeneCount as pseudoGeneCount,
       gc.codingGeneCount as codingGeneCount,
       gc.otherGeneCount as otherGeneCount,
       gc.ChipChipGeneCount as ChipChipGeneCount,
       gc.orthologCount as orthologCount,
       gc.goCount as goCount,    
       gc.tfbsCount as tfbsCount,
       gc.proteomicsCount as proteomicsCount,
       gc.estCount as estCount,
       gc.ecNumberCount as ecNumberCount,
       nvl(dsc.isOrganellar, 0) as isOrganellar,
       nvl(dsc.hasHTSIsolate, 0) as hasHTSIsolate, 
       nvl(dsc.hasIsolate, 0) as hasIsolate,
       nvl(dsc.hasEpitope, 0) as hasEpitope,
       nvl(dsc.hasArray, 0) as hasArray,
       nvl(cc.communityCount, 0) as communityCount,
       nvl(ic.isolateCount, 0) as isolateCount,
       nvl(pc.geneArrayCount, 0) as arrayGeneCount,
       nvl(pc.rnaSeqCount, 0) as rnaSeqCount,
       nvl(pc.rtPCRCount, 0) as rtPCRCount
FROM   apidb.Organism o,
       sres.TaxonName tn,
       DataSourceCount&1 dsc,
       CommunityCount&1 cc,
       GeneCount&1 gc,
       isolateCount&1 ic,
       profileCount&1 pc
WHERE tn.taxon_id = o.taxon_id
  AND tn.name_class = 'scientific name' 
  AND o.taxon_id = dsc.taxon_id (+)
  AND o.taxon_id = cc.taxon_id (+)
  AND o.taxon_id = gc.taxon_id (+)
  AND o.taxon_id = ic.taxon_id (+)
  AND o.taxon_id = pc.taxon_id (+)
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index Organism_sourceId_idx&1 ON OrganismAttributes&1 (source_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="PdbSimilarity">
    <!-- Each record maps a gene to a PDB structure. Used by the model to find
         genes that have a PDB structure and to find the PDB structures for a
         given gene.
      -->
    <externalDependency name="core.TableInfo"/>
    <externalDependency name="dots.ExternalAaSequence"/>
    <externalDependency name="dots.GeneFeature"/>
    <externalDependency name="dots.Similarity"/>
    <externalDependency name="dots.Transcript"/>
    <externalDependency name="dots.TranslatedAaFeature"/>
    <externalDependency name="dots.TranslatedAaSequence"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE PdbSimilarity&1 NOLOGGING AS
SELECT gf.source_id, eas.source_id AS pdb_chain,
       substr(eas.description, 1, 100) AS pdb_title,
       substr(eas.source_id, 1,
              instr(eas.source_id, '_', -1) - 1)
         AS pdb_id,
       s.pvalue_mant, s.pvalue_exp, 
       SUBSTR(tn.name, 1, 100) AS taxon,
       ROUND( (s.number_identical / s.total_match_length) * 100)
         AS percent_identity,
       ROUND( (s.total_match_length / tas.length) * 100)
         AS percent_plasmo_coverage,
       s.score, eas.taxon_id as pdb_taxon_id, tas.taxon_id as gene_taxon_id
FROM dots.TranslatedAaFeature taf,
     dots.TranslatedAaSequence tas, core.TableInfo tas_ti,
     dots.Similarity s, core.TableInfo eas_ti,
     dots.ExternalAaSequence eas,
     sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed,
     sres.TaxonName tn, dots.Transcript t, dots.GeneFeature gf
WHERE taf.aa_sequence_id = tas.aa_sequence_id
  AND tas_ti.name = 'TranslatedAASequence'
  AND tas_ti.table_id = s.query_table_id
  AND s.query_id = tas.aa_sequence_id
  AND eas_ti.name = 'ExternalAASequence'
  AND eas_ti.table_id = s.subject_table_id
  AND s.subject_id = eas.aa_sequence_id
  AND tn.name_class = 'scientific name'
  AND eas.external_database_release_id
      = edr.external_database_release_id
  AND edr.external_database_id = ed.external_database_id
  AND ed.name in ('PDBProteinSequences_RSRC','PDB protein sequences')
  AND eas.taxon_id = tn.taxon_id
  AND t.na_feature_id = taf.na_feature_id
  AND gf.na_feature_id = t.parent_id
ORDER BY taf.source_id, eas.source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index PdbSim_sourceId_ix&1
ON PdbSimilarity&1 (source_id, score DESC)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="SequencePieceClosure" prefixEnabled="true">
    <!-- Extends dots.SequencePiece to handle multiple levels. Used in
         sequence-record queries and in other tuning tables, including
         SequenceAttributes, FeatureLocation, BlatAlignmentLocation,
         and SimilaritySpanLocation
      -->
    <externalDependency name="dots.SequencePiece"/>
    <sql>
      <![CDATA[
        create table &prefixSequencePieceClosure&1 nologging as
        select sp.sequence_piece_id,
               sp.virtual_na_sequence_id,
               sp.piece_na_sequence_id, 
               sp.sequence_order, 
               sp.distance_from_left,
               sp.uncertainty,
               sp.strand_orientation,
               sp.start_position,
               sp.end_position, 
               sp.modification_date,
               1 as edge_level
        from dots.SequencePiece sp, dots.NaSequence ns
        where sp.piece_na_sequence_id = ns.na_sequence_id
          and (ns.taxon_id = '&filterValue' or nvl('&filterValue', 0) = 0)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        /* known issue: this should be run not just once, but iteratively
           until it doesn't create new records.  Currently (7/2008),
           SequencePieces aren't nested even once. */
        insert into &prefixSequencePieceClosure&1
                    (edge_level, virtual_na_sequence_id, piece_na_sequence_id,
                     distance_from_left, strand_orientation, modification_date, 
                     start_position, end_position, sequence_order, sequence_piece_id)
        select 2, higher.virtual_na_sequence_id, lower.piece_na_sequence_id,
               higher.distance_from_left,
               case
                 when nvl(higher.strand_orientation, '+') = nvl(lower.strand_orientation, '+')
                 then '+'
                 else '-'
               end as strand_orientation,
               sysdate,
               higher.start_position - lower.distance_from_left, 
               higher.end_position - lower.distance_from_left, 
               higher.sequence_order,
               dots.sequencepiece_sq.nextval
        from &prefixSequencePieceClosure&1 higher, &prefixSequencePieceClosure&1 lower
        where higher.piece_na_sequence_id = lower.virtual_na_sequence_id
         and higher.start_position >= lower.start_position + lower.distance_from_left
         and higher.end_position <= lower.end_position + lower.distance_from_left
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="FeatureLocation" prefixEnabled="true">
    <!-- Addresses a performance problem with feature location queries, namely
         that the sequence and the location on that sequence are in different
         tables, so it's impossible to create an index on the whole shebang.
         Used by both model and GBrowse queries, as well as inputs to a
         dozen-odd other tuning tables.
      -->
    <internalDependency name="SequencePieceClosure"/>
    <internalDependency name="SequenceAttributes"/>
    <externalDependency name="core.ProjectInfo"/>
    <externalDependency name="dots.ExonFeature"/>
    <externalDependency name="dots.NaFeature"/>
    <externalDependency name="dots.NaLocation"/>
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
create table &prefixFeatureLocation&1 NOLOGGING as
    with project_mapping AS
       (select distinct tn.name AS organism,  pi.name as project
        from sres.TaxonName tn, dots.NaSequence na, 
        core.ProjectInfo pi
        where tn.name_class = 'scientific name'
          and tn.taxon_id = na.taxon_id
          and na.row_project_id = pi.project_id
          )
select case
         when nf.subclass_view = 'GeneFeature'
              and nf.is_predicted = 1
           then 'GenePrediction'
         when nf.subclass_view = 'Miscellaneous' 
              and nf.is_predicted = 1
           then 'Prediction'
         else nf.subclass_view
       end as feature_type,
       nf.source_id as feature_source_id, ns.source_id as sequence_source_id,
       nf.na_sequence_id, nf.na_feature_id,
       least(nl.start_min, nl.start_max, nl.end_min, nl.end_max) as start_min,
       greatest(nl.start_min, nl.start_max, nl.end_min, nl.end_max) as end_max,
       nl.is_reversed, nf.parent_id, nf.sequence_ontology_id,
       cast (null as number) as is_top_level, ef.coding_start, ef.coding_end,
       nf.external_database_release_id,
       (select project from project_mapping where organism = tn.name) as project_id
from dots.NaFeature nf, dots.NaLocation nl, &prefixSequenceAttributes ns,
     dots.ExonFeature ef, sres.TaxonName tn
where nf.na_feature_id = nl.na_feature_id
  and nf.na_sequence_id = ns.na_sequence_id
  and nl.na_feature_id = ef.na_feature_id(+)
  and ns.taxon_id = tn.taxon_id
  and tn.name_class = 'scientific name'
  and (ns.taxon_id = '&filterValue' or nvl('&filterValue', 0) = 0)
union
select -- virtual feature locations mapped through SequencePiece
       case
         when nf.subclass_view = 'GeneFeature'
              and nf.is_predicted = 1
           then 'GenePrediction'
         else nf.subclass_view
       end as feature_type,
       nf.source_id as feature_source_id, scaffold.source_id as sequence_source_id,
       sp.virtual_na_sequence_id, nf.na_feature_id,
       case
         when sp.strand_orientation in ('-', '-1')
           then sp.distance_from_left + sp.end_position - greatest(nl.start_min, nl.start_max, nl.end_min, nl.end_max)  + 1
           else sp.distance_from_left + least(nl.start_min, nl.start_max, nl.end_min, nl.end_max) - sp.start_position  + 1
       end as start_min,
       case
         when sp.strand_orientation in ('-', '-1')
           then sp.distance_from_left + sp.end_position - least(nl.start_min, nl.start_max, nl.end_min, nl.end_max) + 1
         else sp.distance_from_left + greatest(nl.start_min, nl.start_max, nl.end_min, nl.end_max) - sp.start_position + 1
       end as end_max,
       case
         when sp.strand_orientation in ('-', '-1')
         then decode(nvl(nl.is_reversed, 0),
                     0, 1,  1, 0,  1)
         else nl.is_reversed
       end as is_reversed,
       nf.parent_id, nf.sequence_ontology_id,
       cast (null as number) as is_top_level,
       case
         when sp.strand_orientation in ('-', '-1')
           then sp.distance_from_left + sp.end_position - coding_start + 1
           else sp.distance_from_left + ef.coding_start - sp.start_position + 1
       end as coding_start,
       case
         when sp.strand_orientation in ('-', '-1')
           then sp.distance_from_left + sp.end_position - coding_end + 1
         else sp.distance_from_left + coding_end - sp.start_position + 1
       end as coding_end, nf.external_database_release_id,
       (select project from project_mapping where organism = tn.name) as project_id
from dots.NaFeature nf, dots.NaLocation nl, &prefixSequenceAttributes contig,
     &prefixSequencePieceClosure sp, &prefixSequenceAttributes scaffold, dots.ExonFeature ef,
     sres.TaxonName tn
where nf.na_feature_id = nl.na_feature_id
  and nf.na_sequence_id = contig.na_sequence_id
  and nf.na_sequence_id = sp.piece_na_sequence_id
  and sp.start_position <= nl.start_min
  and sp.end_position >= nl.end_max
  and sp.virtual_na_sequence_id = scaffold.na_sequence_id
  and nl.na_feature_id = ef.na_feature_id(+)
  and contig.taxon_id = tn.taxon_id
  and tn.name_class = 'scientific name'
  and (contig.taxon_id = '&filterValue' or nvl('&filterValue', 0) = 0)
      ]]>
    </sql>
    <sql>
      <![CDATA[
update &prefixFeatureLocation&1
set is_top_level = 1
      ]]>
    </sql>
    <sql>
      <![CDATA[
update &prefixFeatureLocation&1 fl
set is_top_level = 0 
where na_sequence_id in (select distinct piece_na_sequence_id 
                         from &prefixSequencePieceClosure spc
                         where fl.start_min >= spc.start_position
                         and fl.end_max <= spc.end_position)
      ]]>
    </sql>
    <sql>
      <![CDATA[
commit
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index featloc_ix&1 on &prefixFeatureLocation&1
             (feature_type, na_sequence_id, start_min, end_max, is_reversed, feature_source_id, na_feature_id,external_database_release_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index featloc2_ix&1 on &prefixFeatureLocation&1
             (na_sequence_id, start_min, end_max, is_reversed, sequence_ontology_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index fl_seq_st_end_feat_idx&1
      on &prefixFeatureLocation&1 (na_sequence_id,start_min,end_max,na_feature_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index featloc3_ix&1 on &prefixFeatureLocation&1
             (na_feature_id, na_sequence_id, is_top_level)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index featloc4_ix&1 on &prefixFeatureLocation&1
             (feature_type, is_top_level, na_feature_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index featloc5_ix&1
on &prefixFeatureLocation&1 
(na_sequence_id, feature_type, start_min, end_max, parent_id, na_feature_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index featloc6_ix&1 on &prefixFeatureLocation&1 (feature_source_id, is_top_level, na_sequence_id, is_reversed)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index featloc7_ix&1 on &prefixFeatureLocation&1
             (feature_type, sequence_source_id, start_min, is_reversed, end_max, feature_source_id, na_feature_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="GeneId" prefixEnabled="true">
  <!-- GeneId maps any valid ID for a gene onto its official ID. These two quantities
       are stored in the "id" and "gene" columns, respectively. The "unique_mapping"
       column is set to 1 for IDs which map to only one gene.

       Most of the CREATE TABLE statement is made up of the union of nine subqueries,
       each of which looks in a different place for gene IDs. Each subquery populates
       the "union_member" field with a different literal string, to make it easier to
       understand which part (or parts) of the SQL is responsible for each ID-to-gene
       mapping.
    -->
    <internalDependency name="FeatureLocation"/>
    <externalDependency name="apidb.GeneFeatureName"/>
    <externalDependency name="dots.DbRefNaFeature"/>
    <externalDependency name="dots.DbRefNaSequence"/>
    <externalDependency name="dots.GeneFeature"/>
    <externalDependency name="dots.NaFeatureNaGene"/>
    <externalDependency name="dots.NaGene"/>
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="dots.Transcript"/>
    <externalDependency name="sres.DbRef"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.TaxonName"/>
    <intermediateTable name="CommentAssignment"/>
    <intermediateTable name="NewCsi"/>
    <sql>
      <![CDATA[
CREATE TABLE &prefixGeneId&1 NOLOGGING AS
SELECT substr(mapping.id, 1, 100) as id, mapping.gene, cast (null as NUMBER) as unique_mapping,
       SUBSTR(apidb.tab_to_string(set(CAST(COLLECT(union_member order by union_member) AS apidb.varchartab)),'; '), 1, 100) as union_member, 
       SUBSTR(apidb.tab_to_string(set(CAST(COLLECT(database_name order by database_name) AS apidb.varchartab)),'; '), 1, 200) as database_name
--   we would use listagg() as follows, but it repeats duplicate values, and doesn't provide a way to aggregate DISTINCT values. (lame!)
--       substr(listagg(union_member, '; ') within group (order by union_member), 1, 100) as union_member,
--       substr(listagg(database_name, '; ') within group (order by database_name), 1, 200) as database_name
FROM (SELECT substr(t.protein_id, 1, instr(t.protein_id, '.') - 1) AS id,
             gf.source_id AS gene,
             'Transcript.protein_id before dot' as union_member, ed.name as database_name -- dots.Transcript.protein_id, trimmed at period
      FROM dots.Transcript t, dots.GeneFeature gf,
           sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr
      WHERE t.parent_id = gf.na_feature_id
        AND substr(t.protein_id, 1, instr(t.protein_id, '.') - 1) IS NOT NULL
        AND gf.external_database_release_id = edr.external_database_release_id
        AND edr.external_database_id = ed.external_database_id
     UNION
      SELECT t.protein_id AS id,
             gf.source_id AS gene,
             'Transcript.protein_id' as union_member, ed.name as database_name -- dots.Transcript.protein_id
      FROM dots.Transcript t, dots.GeneFeature gf,
           sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr
      WHERE t.parent_id = gf.na_feature_id
        AND t.protein_id IS NOT NULL
        AND gf.external_database_release_id = edr.external_database_release_id
        AND edr.external_database_id = ed.external_database_id
     UNION
      SELECT dr.primary_identifier AS id, 
             gf.source_id AS gene,
             'DbRef.primary_identifier' as union_member, ed.name as database_name -- sres.DbRef.primary_identifier
      FROM dots.GeneFeature gf, dots.DbRefNaFeature drnf,
           sres.DbRef dr, sres.ExternalDatabaseRelease edr,
           sres.ExternalDatabase ed
      WHERE dr.primary_identifier IS NOT NULL
        AND gf.na_feature_id = drnf.na_feature_id
        AND drnf.db_ref_id = dr.db_ref_id
        AND dr.external_database_release_id
              = edr.external_database_release_id
        AND edr.external_database_id = ed.external_database_id
        AND  NOT (ed.name in ('NRDB_gb_dbXRefBySeqIdentity','NRDB_ref_dbXRefBySeqIdentity')  
                                  AND NOT  REGEXP_LIKE (dr.primary_identifier, '\D') )
        AND  NOT edr.id_type = 'synonym'
     UNION
     SELECT dr.primary_identifier AS id, 
             gf.source_id AS gene,
             'synonym' as union_member, ed.name as database_name
      FROM dots.GeneFeature gf, dots.DbRefNaFeature drnf,
           sres.DbRef dr, sres.ExternalDatabaseRelease edr,
           sres.ExternalDatabase ed
      WHERE dr.primary_identifier IS NOT NULL
        AND gf.na_feature_id = drnf.na_feature_id
        AND drnf.db_ref_id = dr.db_ref_id
        AND dr.external_database_release_id = edr.external_database_release_id
        AND edr.external_database_id = ed.external_database_id
        AND edr.id_type  = 'synonym'
     UNION
      SELECT dr.secondary_identifier AS id, 
             gf.source_id AS gene,
             'DbRef.secondary_identifier' as union_member, ed.name as database_name -- sres.DbRef.secondary_identifier
      FROM dots.GeneFeature gf, dots.DbRefNaFeature drnf,
           sres.DbRef dr, sres.ExternalDatabaseRelease edr,
           sres.ExternalDatabase ed
      WHERE dr.secondary_identifier IS NOT NULL
        AND gf.na_feature_id = drnf.na_feature_id
        AND drnf.db_ref_id = dr.db_ref_id
        AND dr.external_database_release_id
              = edr.external_database_release_id
        AND edr.external_database_id = ed.external_database_id
        AND ed.name IN ('NRDB_gb_dbXRefBySeqIdentity',
                        'NRDB_pdb_dbXRefBySeqIdentity',
                        'NRDB_ref_dbXRefBySeqIdentity',
                        'NRDB_sp_dbXRefBySeqIdentity',
                        'Predicted protein structures','Pf_predictedProteinStructures_RSRC',
                        'GenBank')
     UNION
      SELECT dr.primary_identifier AS id, 
             gf.source_id AS gene,
             'genbank DbRef.primary_identifier' as union_member, ed.name as database_name -- sres.DbRef.primary_identifier for Genbank records
      FROM dots.GeneFeature gf, dots.Transcript t, dots.DbRefNaSequence drns,
           sres.DbRef dr, sres.ExternalDatabaseRelease edr,
            sres.ExternalDatabase ed
      WHERE gf.na_feature_id = t.parent_id
        AND t.na_sequence_id = drns.na_sequence_id
        AND drns.db_ref_id = dr.db_ref_id
        AND dr.external_database_release_id = edr.external_database_release_id
        AND edr.external_database_id = ed.external_database_id
        AND ed.name = 'GenBank'
     UNION
      SELECT pred_loc.feature_source_id AS id,
             gene_loc.feature_source_id AS gene,
             'overlapping predicted gene source_id' as union_member, ed.name as database_name -- dots.GeneFeature.source_id for predicted genes that overlap
      FROM &prefixFeatureLocation gene_loc, &prefixFeatureLocation pred_loc,
           sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed
      WHERE pred_loc.feature_type = 'GenePrediction'
        AND gene_loc.feature_type = 'GeneFeature'
        AND pred_loc.na_sequence_id = gene_loc.na_sequence_id
        AND gene_loc.start_min <= pred_loc.end_max
        AND gene_loc.end_max >= pred_loc.start_min
        AND pred_loc.is_reversed = gene_loc.is_reversed
        AND pred_loc.external_database_release_id = edr.external_database_release_id
        AND edr.external_database_id = ed.external_database_id
     UNION
      SELECT ng.name AS id, gf.source_id AS gene,
             'NaGene' as union_member, ed.name as database_name -- dots.NaGene.name
      FROM dots.GeneFeature gf, dots.NaFeatureNaGene nfng, dots.NaGene ng,
           sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed
      WHERE gf.na_feature_id = nfng.na_feature_id
        AND ng.na_gene_id = nfng.na_gene_id
        AND gf.external_database_release_id = edr.external_database_release_id
        AND edr.external_database_id = ed.external_database_id
     UNION
      SELECT source_id AS id, source_id AS gene,
             'same ID' as union_member, ed.name as database_name -- same ID (reflexive mapping)
      FROM dots.GeneFeature gf,
           sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed
      WHERE gf.external_database_release_id = edr.external_database_release_id
        AND edr.external_database_id = ed.external_database_id
     UNION
      SELECT n.name AS id, gf.source_id AS gene,
             'gene name' as union_member, d.name as database_name -- apidb.GeneFeatureName.name
      from apidb.GeneFeatureName n, dots.genefeature gf, sres.ExternalDatabaseRelease r, sres.ExternalDatabase d
      where n.na_feature_id = gf.na_feature_id
        and gf.external_database_release_id =r.external_database_release_id
        and r.external_database_id = d.external_database_id
        and n.is_preferred = 1) mapping,
      dots.GeneFeature gf, dots.NaSequence ns
where mapping.gene = gf.source_id
  and gf.na_sequence_id = ns.na_sequence_id
  and (ns.taxon_id = '&filterValue' or nvl('&filterValue', 0) = 0)
  and (gf.is_predicted != 1 OR gf.is_predicted is null)
group by mapping.id, mapping.gene
      ]]>
    </sql>
    <sql>
      <![CDATA[
update &prefixGeneId&1
set unique_mapping = 1
where lower(id) in (select lower_id
                    from (select distinct lower(id) as lower_id, gene
                          from &prefixGeneId&1) case_independent_mapping
                    group by lower_id
                    having count(*) = 1)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX GeneId_gene_idx&1 ON &prefixGeneId&1 (gene, id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX GeneId_id_idx&1 ON &prefixGeneId&1 (id, gene)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX GeneId_uniqid_idx&1 ON &prefixGeneId&1 (unique_mapping, id, gene)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX GeneId_lowid_idx&1 ON &prefixGeneId&1 (lower(id), gene)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX GeneId_uniqlowid_idx&1 ON &prefixGeneId&1 (unique_mapping, lower(id), gene)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE &prefixCommentAssignment NOLOGGING AS
WITH projects AS
       (SELECT DISTINCT project_id FROM &prefixFeatureLocation), 
     project_comments AS
       (SELECT stable_id, comment_id
        FROM comments2.comments@&dblink
        WHERE project_name in (select project_id FROM projects)
          AND comment_target_id = 'gene')
  SELECT stable_id, comment_id
  FROM project_comments
UNION
  SELECT csi.stable_id, csi.comment_id
  FROM project_comments pc, comments2.commentStableId@&dblink csi
  WHERE csi.comment_id = pc.comment_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE &prefixNewCsi nologging as
SELECT stable_id, comment_id, comments2.CommentStableId_pkseq.nextval@&dblink as comment_stable_id
FROM (  SELECT gi.gene AS stable_id, ca.comment_id
        FROM &prefixGeneId&1 gi, &prefixCommentAssignment ca
        WHERE gi.id = ca.stable_id
          AND gi.id != gi.gene
      MINUS
        SELECT stable_id, comment_id
        FROM &prefixCommentAssignment ca)
      ]]>
    </sql>
    <sql>
      <![CDATA[
INSERT INTO comments2.CommentStableId@&dblink
           (stable_id, comment_id, comment_stable_id)
SELECT stable_id, comment_id, comment_stable_id
FROM &prefixNewCsi
      ]]>
    </sql>
    <!-- this program, which merely lists changes made by the SQL above,
         is sometmes a source of errors and not really needed -->
    <!-- program commandLine="showNewCommentLinks"/ -->
  </tuningTable>


  <tuningTable name="SequenceId">
  <!-- This table maps IDs for a sequence onto the official ID of the sequence.
       It is analogous to GeneId, which does the same thing for genes. Used by
       genomic-sequence record queries, by the sequence retrieval tool, and by
       the BasketFixer, which updates users' baskets at release time to replace
       old IDs with updated ones.
    -->
    <externalDependency name="dots.DbRefNaSequence"/>
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="sres.DbRef"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.SequenceOntology"/>
    <sql>
      <![CDATA[
CREATE TABLE SequenceId&1 NOLOGGING AS
SELECT DISTINCT substr(id, 1, 60) as id, substr(sequence, 1, 60) AS sequence
FROM (
  SELECT source_id as id, source_id as sequence
  FROM dots.NaSequence ns, sres.SequenceOntology so
  WHERE ns.sequence_ontology_id = so.sequence_ontology_id
    AND so.term_name in ('random_sequence', 'contig', 'supercontig', 'chromosome','mitochondrial_chromosome','plastid_sequence','cloned_genomic','apicoplast_chromosome')
UNION
  SELECT dr.primary_identifier AS id, ns.source_id AS sequence
  FROM dots.NaSequence ns, dots.DbRefNaSequence drnf,
       sres.DbRef dr, sres.ExternalDatabaseRelease edr,
       sres.ExternalDatabase ed
  WHERE dr.primary_identifier IS NOT NULL
    AND ns.na_sequence_id = drnf.na_sequence_id
    AND drnf.db_ref_id = dr.db_ref_id
    AND dr.external_database_release_id
          = edr.external_database_release_id
    AND edr.external_database_id = ed.external_database_id
)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX SequenceId_sequence_idx&1 ON SequenceId&1 (sequence, id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX SequenceId_id_idx&1 ON SequenceId&1 (id, sequence)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX SequenceId_lowid_idx&1 ON SequenceId&1 (lower(id), sequence)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="EpitopeSummary">
    <!-- Used by GeneTables.Epitopes to map a gene to its epitopes.
     -->
    <externalDependency name="dots.AaLocation"/>
    <externalDependency name="dots.EpitopeFeature"/>
    <externalDependency name="dots.GeneFeature"/>
    <externalDependency name="dots.MotifAaSequence"/>
    <externalDependency name="dots.Transcript"/>
    <externalDependency name="dots.TranslatedAaFeature"/>
    <externalDependency name="dots.TranslatedAaSequence"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE EpitopeSummary&1 NOLOGGING AS
SELECT gf.source_id, 
              al.start_min||'-'||al.end_max AS location,
              ef.source_id as iedb_id,
       mas.sequence, 
       SUBSTR(tn.name, 1, 100) AS name,
       DECODE(ef.type, 'Not Full Set Not on Blast Hit', 'Low',
                       'Not Full Set On Blast Hit', 'Medium',
                       'Full Set Not on Blast Hit', 'Medium',
                       'Full Set On Blast Hit', 'High',
                       'unknown epitope type') AS confidence
FROM dots.GeneFeature gf, 
     dots.Transcript t,
     dots.TranslatedAaFeature taf, 
     dots.MotifAaSequence mas,
     dots.TranslatedAaSequence tas, 
     dots.EpitopeFeature ef,
     dots.AaLocation al, 
     sres.TaxonName tn
WHERE t.parent_id = gf.na_feature_id
  AND taf.na_feature_id = t.na_feature_id
  AND taf.aa_sequence_id = tas.aa_sequence_id
  AND tas.aa_sequence_id = ef.aa_sequence_id
  AND ef.aa_feature_id = al.aa_feature_id
  AND ef.motif_aa_sequence_id = mas.aa_sequence_id
  AND tas.taxon_id = tn.taxon_id
  AND tn.name_class = 'scientific name'
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index Epi_srcId_ix&1 ON EpitopeSummary&1 (source_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="GeneCentromereDistance">
    <!-- Stores (gene, sequence, distance from centromere) 3-tuples for genes
         that lie on a sequence for which we have a centomere location.
     -->
    <internalDependency name="FeatureLocation"/>
    <externalDependency name="sres.SequenceOntology"/>
    <sql>
      <![CDATA[
CREATE TABLE GeneCentromereDistance&1 NOLOGGING AS
SELECT gfl.feature_source_id AS gene,
       LEAST(ABS(mfl.start_min - gfl.end_max),
             ABS(mfl.end_max - gfl.start_min)) AS centromere_distance,
       gfl.sequence_source_id AS genomic_sequence
FROM FeatureLocation gfl, FeatureLocation mfl,
     sres.SequenceOntology so
WHERE gfl.na_sequence_id = mfl.na_sequence_id
  AND mfl.feature_type = 'Miscellaneous'
  AND gfl.feature_type = 'GeneFeature'
  AND mfl.sequence_ontology_id = so.sequence_ontology_id
  AND so.term_name = 'centromere'
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index GCent_loc_ix&1
       ON GeneCentromereDistance&1 (genomic_sequence, centromere_distance)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="SageTagLibraryTotal">
    <!-- For each sage-tag library, store the total of the counts of all tags.
         Used by GeneTables.SageTags.
     -->
    <externalDependency name="rad.DataTransformationResult"/>
    <externalDependency name="rad.Analysis"/>
    <externalDependency name="rad.Protocol"/>
    <sql>
      <![CDATA[
        create table SageTagLibraryTotal&1 NOLOGGING as
        select dt.analysis_id, sum(float_value) as total_count
        from rad.DataTransformationResult dt, rad.Analysis a, rad.Protocol p
        where dt.analysis_id = a.analysis_id
          and a.protocol_id = p.protocol_id
          and p.name = 'Normalization of SAGE tag frequencies to a target total intensity'
        group by dt.analysis_id
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="SageTagAnalysisAttributes">
    <!-- Stores information specific to a given SAGE tag within a given library.
         Used by gene and sage-tag queries in the model, by GBrowse queries, and
         in the creation of the tuning tables SageTagGene and SageTagAttributes.
     -->
    <internalDependency name="SageTagLibraryTotal"/>
    <externalDependency name="core.TableInfo"/>
    <externalDependency name="dots.SageTagFeature"/>
    <externalDependency name="rad.Analysis"/>
    <externalDependency name="rad.AnalysisInput"/>
    <externalDependency name="rad.Assay"/>
    <externalDependency name="rad.DataTransformationResult"/>
    <externalDependency name="rad.LogicalGroup"/>
    <externalDependency name="rad.LogicalGroupLink"/>
    <externalDependency name="rad.Protocol"/>
    <externalDependency name="rad.Quantification"/>
    <externalDependency name="rad.SageTag"/>
    <externalDependency name="rad.SageTagResult"/>
    <intermediateTable name="SageTagInfo"/>
    <intermediateTable name="SageTagGenomicOccurrence"/>
    <intermediateTable name="SageTagQuantificationTotal"/>
    <sql>
      <![CDATA[
create table SageTagInfo NOLOGGING as
select st.composite_element_id, dtr.analysis_id, dtr.float_value as dtr_tag_count,
       substr(st.tag, 1, 30) as sequence, r.tag_count, r.quantification_id, dtr.table_id
from dots.SageTagFeature stf, rad.DataTransformationResult dtr, rad.SageTag st, rad.SageTagResult r
where st.composite_element_id = dtr.row_id
  and st.composite_element_id = stf.source_id
  and st.composite_element_id = r.composite_element_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
create table SageTagGenomicOccurrence NOLOGGING as
select source_id, count(*) as occurrence
from dots.SageTagFeature
group by source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
create table SageTagQuantificationTotal nologging as
select quantification_id, sum(tag_count) as total_raw_count
from rad.SageTagResult
group by quantification_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
create table SageTagAnalysisAttributes&1 NOLOGGING as
select sti.analysis_id, max(sti.dtr_tag_count) as tag_count,
       max(ct.occurrence) as occurrence, sti.sequence,
       sti.composite_element_id, a.name as library_name,
       library_total.total_count as library_total_tag_count,
       (max(sti.dtr_tag_count) * 100) / library_total.total_count
         as library_tag_percentage,
       sti.tag_count as raw_count, tot.total_raw_count,
       100 *(sti.tag_count / tot.total_raw_count ) as raw_percent
from SageTagInfo sti, SageTagGenomicOccurrence ct,
     SageTagLibraryTotal library_total, SageTagQuantificationTotal tot,
     core.TableInfo ti, rad.AnalysisInput ai, rad.LogicalGroup lg,
     rad.LogicalGroupLink ll, rad.Assay a, core.TableInfo quant_ti,
     rad.Quantification q
where ti.name = 'SAGETag'
  and quant_ti.name = 'Assay'
  and sti.table_id = ti.table_id
  and q.quantification_id = sti.quantification_id
  and tot.quantification_id = sti.quantification_id
  and ct.source_id = sti.composite_element_id
  and sti.analysis_id = ai.analysis_id
  and ai.logical_group_id = lg.logical_group_id
  and lg.logical_group_id = ll.logical_group_id
  and ll.row_id = a.assay_id
  and a.name = q.name
  and ll.table_id = quant_ti.table_id
  and sti.analysis_id = library_total.analysis_id
group by sti.analysis_id, sti.sequence, sti.composite_element_id,
         a.name, library_total.total_count,
         q.name, sti.tag_count, tot.total_raw_count
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index staa_ix&1 on SageTagAnalysisAttributes&1 (analysis_id, composite_element_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index staa_tag_ix&1 on SageTagAnalysisAttributes&1 (composite_element_id, analysis_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="SageTagGene">
    <!-- Stores info about colocated gene-sage tag pairs. Used by the model for
         sage tag and gene queries, and in the creation of the tuning tables
         OrganismAttributes and SageTagAttributes.
     -->
    <internalDependency name="FeatureLocation"/>
    <internalDependency name="SageTagAnalysisAttributes"/>
    <externalDependency name="rad.DataTransformationResult"/>
    <externalDependency name="dots.SageTagFeature"/>
    <intermediateTable name="SageTagGeneFivePrime"/>
    <intermediateTable name="SageTagGeneThreePrime"/>
    <sql>
      <![CDATA[
create table SageTagGeneFivePrime NOLOGGING as
   select '5' as direction, g.feature_source_id AS gene_source_id,
          s.feature_source_id as tag_source_id,
             min (case
                    when g.is_reversed = 1 and s.end_max - g.end_max < 0
                      then 0
                    when g.is_reversed = 1 and s.end_max - g.end_max >= 0
                      then s.end_max - g.end_max
                    when g.is_reversed = 0 and g.start_min - s.start_min < 0
                      then 0
                    when g.is_reversed = 0 and g.start_min - s.start_min >= 0
                      then g.start_min - s.start_min
                  end) as distance,
           dr.analysis_id, max(dr.float_value) as tag_count,
           max(ct.occurrence) as occurrence,
           g.na_feature_id as gene_feature_id, s.na_feature_id as tag_feature_id,
           case when s.is_reversed = g.is_reversed then 0
                else 1
           end as antisense
      from FeatureLocation g, FeatureLocation s,
           rad.DataTransformationResult dr,
           (select source_id , count(*) as occurrence
            from dots.SageTagFeature
            group by source_id) ct
      where g.feature_type = 'GeneFeature'
        and s.feature_type = 'SAGETagFeature'
        and g.na_sequence_id = s.na_sequence_id
        and s.feature_source_id = dr.row_id
        and dr.row_id = ct.source_id
        and (case
               when g.is_reversed = 0
                 then g.start_min - s.start_min
               else s.end_max - g.end_max
             end <= 1000
            and case
                  when g.is_reversed = 0
                    then g.end_max - s.end_max
                  else s.start_min - g.start_min
                end >= 0)
      group by g.feature_source_id, s.feature_source_id, dr.analysis_id,
               g.na_feature_id, s.na_feature_id,
               case when s.is_reversed = g.is_reversed then 0
                    else 1
               end
      ]]>
    </sql>
    <sql>
      <![CDATA[
create table SageTagGeneThreePrime NOLOGGING as
      select '3' as direction, g.feature_source_id AS gene_source_id,
             s.feature_source_id as tag_source_id,
             min (case
                    when g.is_reversed = 1 and g.start_min - s.start_min < 0
                      then 0
                    when g.is_reversed = 1 and g.start_min - s.start_min  >= 0
                      then g.start_min - s.start_min
                    when g.is_reversed = 0 and s.end_max - g.end_max < 0
                      then 0
                    when g.is_reversed = 0 and s.end_max - g.end_max >= 0
                      then s.end_max - g.end_max
                  end) as distance,
           dr.analysis_id, max(dr.float_value) as tag_count,
           max(ct.occurrence) as occurrence,
           g.na_feature_id as gene_feature_id, s.na_feature_id as tag_feature_id,
           case when s.is_reversed = g.is_reversed then 0
                else 1
           end as antisense
      from FeatureLocation g, FeatureLocation s,
           rad.DataTransformationResult dr,
           (select source_id , count(*) as occurrence
            from dots.SageTagFeature
            group by source_id) ct
            where g.feature_type = 'GeneFeature'
              and s.feature_type = 'SAGETagFeature'
              and g.na_sequence_id = s.na_sequence_id
              and s.feature_source_id = dr.row_id
              and dr.row_id = ct.source_id
              and (case
                     when g.is_reversed = 0
                       then s.end_max - g.end_max
                     else g.start_min - s.start_min end <= 1000
                  and
                   case
                     when g.is_reversed = 0
                       then s.start_min - g.start_min
                     else g.end_max - s.end_max
                   end >= 0)
            group by g.feature_source_id, s.feature_source_id, dr.analysis_id,
                     g.na_feature_id, s.na_feature_id,
                     case when s.is_reversed = g.is_reversed then 0
                          else 1
                     end
      ]]>
    </sql>
    <sql>
      <![CDATA[
create table SageTagGene&1 NOLOGGING as
select t.direction, t.gene_source_id, t.tag_source_id, t.distance,
       t.analysis_id, t.occurrence, t.gene_feature_id, t.tag_feature_id,
       t.tag_count, t.antisense,
       case
         when t.antisense = 0 then t.tag_count
         else 0
       end as sense_count,
       case
         when t.antisense = 0 then 0
         else t.tag_count
       end as antisense_count, 
       libs.library_name
from
  (select * from SageTagGeneFivePrime
   union all
   select * from SageTagGeneThreePrime) t,
  (select distinct(analysis_id), library_name from SageTagAnalysisAttributes) libs
  where t.analysis_id = libs.analysis_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index stg_ix&1
on SageTagGene&1 (gene_source_id, direction, distance, tag_source_id, tag_feature_id, antisense)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index stg_2ix&1
on SageTagGene&1 (gene_source_id, direction, distance, library_name, tag_source_id,
                  tag_feature_id, antisense, analysis_id, tag_count, occurrence)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="GeneAttributes" prefixEnabled="true">
    <!-- The BFMV for the gene record. Each gene gets a single record, which
         stores all its attributes. Used widely, in the model and elsewhere, for
         queries involving genes, as well as in the creation of more than a
         dozen other tuning tables.
     -->
    <internalDependency name="GeneId"/>
    <internalDependency name="FeatureLocation"/>
    <internalDependency name="GenomicSequence"/>
    <internalDependency name="TaxonSpecies"/>
    <internalDependency name="UTR"/>
    <externalDependency name="apidb.AaSequenceAttribute"/>
    <externalDependency name="apidb.GeneFeatureName"/>
    <externalDependency name="apidb.GeneFeatureProduct"/>
    <externalDependency name="apidb.Organism"/>
    <externalDependency name="core.TableInfo"/>
    <externalDependency name="dots.AaLocation"/>
    <externalDependency name="dots.AaSequence"/>
    <externalDependency name="dots.AaSequenceEnzymeClass"/>
    <externalDependency name="dots.DbRefNaFeature"/>
    <externalDependency name="dots.ExonFeature"/>
    <externalDependency name="dots.GeneFeature"/>
    <externalDependency name="dots.GeneInstance"/>
    <externalDependency name="dots.GoAssociation"/>
    <externalDependency name="dots.GoAssociationInstance"/>
    <externalDependency name="dots.GoAssociationInstanceLoe"/>
    <externalDependency name="dots.GoAssocInstEvidCode"/>
    <externalDependency name="dots.NaFeatureComment"/>
    <externalDependency name="dots.RnaType"/>
    <externalDependency name="dots.SequenceGroup"/>
    <externalDependency name="dots.SequenceSequencegroup"/>
    <externalDependency name="dots.SignalPeptideFeature"/>
    <externalDependency name="dots.SnpFeature"/>
    <externalDependency name="dots.SplicedNaSequence"/>
    <externalDependency name="dots.Transcript"/>
    <externalDependency name="dots.TranslatedAaFeature"/>
    <externalDependency name="dots.TranslatedAaSequence"/>
    <externalDependency name="dots.TransmembraneAaFeature"/>
    <externalDependency name="sres.DbRef"/>
    <externalDependency name="sres.EnzymeClass"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.GoEvidenceCode"/>
    <externalDependency name="sres.GoRelationship"/>
    <externalDependency name="sres.GoTerm"/>
    <externalDependency name="sres.SequenceOntology"/>
    <externalDependency name="sres.Taxon"/>
    <externalDependency name="sres.TaxonName"/>
    <intermediateTable name="GoTermList"/>
    <intermediateTable name="GeneGoAttributes"/>
    <intermediateTable name="GeneProteinAttributes"/>
    <sql>
      <![CDATA[
CREATE TABLE &prefixGoTermList NOLOGGING AS
SELECT *
FROM (  -- work around sometime Oracle bug ORA-00942
      SELECT source_id, ontology, source,
             apidb.tab_to_string(set(cast(COLLECT(name order by name) as apidb.varchartab)), ', ')
               AS go_terms
      FROM (SELECT DISTINCT gf.source_id, o.ontology, gt.name,
                        DECODE(gail.name, 'Interpro', 'predicted', 'annotated')
                              AS source
            FROM dots.GeneFeature gf, dots.Transcript t,
                 dots.TranslatedAaFeature taf, dots.GoAssociation ga,
                 sres.GoTerm gt, dots.GoAssociationInstance gai,
                 dots.GoAssociationInstanceLoe gail,
                 dots.GoAssocInstEvidCode gaiec, sres.GoEvidenceCode gec,
                 (SELECT gr.child_term_id AS go_term_id, gp.name AS ontology
                  FROM sres.GoRelationship gr, sres.GoTerm gp
                  WHERE gr.parent_term_id = gp.go_term_id
                    AND gp.go_id in ('GO:0008150','GO:0003674','GO:0005575')) o
            WHERE gf.na_feature_id = t.parent_id
              AND t.na_feature_id = taf.na_feature_id
              AND taf.aa_sequence_id = ga.row_id
              AND ga.table_id = (SELECT table_id
                                 FROM core.TableInfo
                                 WHERE name = 'TranslatedAASequence')
              AND ga.go_term_id = gt.go_term_id
              AND ga.go_association_id = gai.go_association_id
              AND gai.go_assoc_inst_loe_id = gail.go_assoc_inst_loe_id
              AND gai.go_association_instance_id
                  = gaiec.go_association_instance_id
              AND gaiec.go_evidence_code_id = gec.go_evidence_code_id
              AND gt.go_term_id = o.go_term_id)
      GROUP BY source_id, ontology, source)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE &prefixGeneGoAttributes NOLOGGING AS
SELECT DISTINCT gene.source_id,
       substr(annotated_go_component.go_terms, 1, 300) AS annotated_go_component,
       substr(annotated_go_function.go_terms, 1, 300) AS annotated_go_function,
       substr(annotated_go_process.go_terms, 1, 300) AS annotated_go_process,
       substr(predicted_go_component.go_terms, 1, 300) AS predicted_go_component,
       substr(predicted_go_function.go_terms, 1, 300) AS predicted_go_function,
       substr(predicted_go_process.go_terms, 1, 300) AS predicted_go_process
FROM (SELECT DISTINCT gene AS source_id FROM &prefixGeneId) gene,
     (SELECT * FROM &prefixGoTermList
      WHERE source = 'annotated' AND ontology = 'cellular_component')
       annotated_go_component,
     (SELECT * FROM &prefixGoTermList
      WHERE source = 'annotated' AND ontology = 'molecular_function')
       annotated_go_function,
     (SELECT * FROM &prefixGoTermList
      WHERE source = 'annotated' AND ontology = 'biological_process')
       annotated_go_process,
     (SELECT * FROM &prefixGoTermList
      WHERE source = 'predicted' AND ontology = 'cellular_component')
       predicted_go_component,
     (SELECT * FROM &prefixGoTermList
      WHERE source = 'predicted' AND ontology = 'molecular_function')
       predicted_go_function,
     (SELECT * FROM &prefixGoTermList
      WHERE source = 'predicted' AND ontology = 'biological_process')
       predicted_go_process
WHERE gene.source_id = annotated_go_component.source_id(+)
  AND 'annotated' = annotated_go_component.source(+)
  AND 'cellular_component' = annotated_go_component.ontology(+)
  AND gene.source_id = annotated_go_function.source_id(+)
  AND 'annotated' = annotated_go_function.source(+)
  AND 'molecular_function' = annotated_go_function.ontology(+)
  AND gene.source_id = annotated_go_process.source_id(+)
  AND 'annotated' = annotated_go_process.source(+)
  AND 'biological_process' = annotated_go_process.ontology(+)
  AND gene.source_id = predicted_go_component.source_id(+)
  AND 'predicted' = predicted_go_component.source(+)
  AND 'cellular_component' = predicted_go_component.ontology(+)
  AND gene.source_id = predicted_go_function.source_id(+)
  AND 'predicted' = predicted_go_function.source(+)
  AND 'molecular_function' = predicted_go_function.ontology(+)
  AND gene.source_id = predicted_go_process.source_id(+)
  AND 'predicted' = predicted_go_process.source(+)
  AND 'biological_process' = predicted_go_process.ontology(+)
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index GeneGoAttr_sourceId&1 ON &prefixGeneGoAttributes (source_id)
tablespace indx
      ]]>
    </sql>



    <sql>
      <![CDATA[
CREATE TABLE &prefixGeneProteinAttributes NOLOGGING AS
SELECT gene.source_id,
       protein.tm_count, protein.molecular_weight,
       protein.isoelectric_point, protein.min_molecular_weight,
       protein.max_molecular_weight, protein.hydropathicity_gravy_score,
       protein.aromaticity_score, protein.cds_length, protein.protein_length,
       protein.ec_numbers,
       protein.signalp_scores, protein.signalp_peptide, protein.aa_sequence_id, protein.protein_source_id
FROM (SELECT DISTINCT gene AS source_id from &prefixGeneId) gene,
     (SELECT gf.source_id, taf.na_feature_id, tas.aa_sequence_id,tas.molecular_weight,tas.source_id as protein_source_id,
             tas.length AS protein_length,
             greatest(taf.translation_start, taf.translation_stop)
             - least(taf.translation_start, taf.translation_stop) + 1 AS cds_length,
             asa.isoelectric_point,
             asa.min_molecular_weight, asa.max_molecular_weight,
             asa.hydropathicity_gravy_score,
             asa.aromaticity_score,
             NVL(transmembrane.tm_domains, 0) AS tm_count,
             ec.ec_numbers,
             sigp.scores as signalp_scores,
             substr(sigp.pep, 1, 200) as signalp_peptide
      FROM  dots.GeneFeature gf, dots.Transcript t,
            dots.TranslatedAaFeature taf,
            dots.TranslatedAaSequence tas,
            apidb.AaSequenceAttribute asa,
            (SELECT aa_sequence_id, max(tm_domains) AS tm_domains
             FROM (SELECT tmaf.aa_sequence_id, COUNT(*) AS tm_domains
                   FROM dots.TransmembraneAaFeature tmaf, dots.AaLocation al
                   WHERE tmaf.aa_feature_id = al.aa_feature_id
                   GROUP BY tmaf.aa_sequence_id) tms
             GROUP BY tms.aa_sequence_id) transmembrane,
            (SELECT aa_sequence_id,
                    SUBSTR(apidb.tab_to_string(set(cast(COLLECT(ec_number order by ec_number)
                                               as apidb.varchartab)), '; '),
                           1, 300)
                      AS ec_numbers
             FROM (SELECT DISTINCT asec.aa_sequence_id,
                          ec.ec_number || ' (' || ec.description || ')' AS ec_number
                   FROM dots.AaSequenceEnzymeClass asec, sres.EnzymeClass ec
                   WHERE ec.enzyme_class_id = asec.enzyme_class_id)
             GROUP BY aa_sequence_id) ec,
             (SELECT spf.aa_sequence_id,'NN Sum: ' || ( spf.maxy_conclusion + spf.maxc_conclusion + spf.maxs_conclusion + spf.means_conclusion ) ||
              ', NN D: ' || round(((spf.means_score + spf.maxy_score) / 2),2) || ', HMM Prob: ' || round(spf.signal_probability,2) as scores,
               apidb.tab_to_string(set(cast(COLLECT(decode(spf.algorithm_name,'SignalPhmm','HMM: ','NN: ') || dbms_lob.substr(s.sequence,aal.end_max,1) order by spf.algorithm_name, dbms_lob.substr(s.sequence, aal.end_max, 1)) as apidb.varchartab)), ', ') as pep
              FROM dots.SignalPeptideFeature spf, dots.AaLocation aal, dots.AaSequence s
              WHERE spf.aa_sequence_id = s.aa_sequence_id 
              and  aal.aa_feature_id = spf.aa_feature_id
              and (spf.signal_probability >= .5
              or ((spf.means_score + spf.maxy_score) / 2) >= .5
              or ( spf.maxy_conclusion + spf.maxc_conclusion + spf.maxs_conclusion + spf.means_conclusion ) >= 3)
              group by spf.aa_sequence_id,'NN Sum: ' || ( spf.maxy_conclusion + spf.maxc_conclusion + spf.maxs_conclusion + spf.means_conclusion ) ||
              ', NN D: ' || round(((spf.means_score + spf.maxy_score) / 2),2) || ', HMM Prob: ' || round(spf.signal_probability,2)) sigp
      WHERE gf.na_feature_id = t.parent_id
        AND t.na_feature_id = taf.na_feature_id
        AND taf.aa_sequence_id = tas.aa_sequence_id
        AND taf.aa_sequence_id = asa.aa_sequence_id
        and tas.aa_sequence_id = sigp.aa_sequence_id(+)
        AND tas.aa_sequence_id = transmembrane.aa_sequence_id(+)
        AND tas.aa_sequence_id = ec.aa_sequence_id(+)) protein
WHERE gene.source_id = protein.source_id(+)
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index GPA_sourceId&1 ON &prefixGeneProteinAttributes (source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE &prefixGeneAttributes&1 NOLOGGING AS
SELECT cast(apidb.project_id(tn.name) as varchar2(20)) as project_id,
       gf.source_id, gf.na_feature_id,
       REPLACE(so.term_name, '_', ' ') AS gene_type,
       CASE  WHEN (COALESCE(preferred_name.name, any_name.name) is NOT NULL) THEN
            SUBSTR(COALESCE(preferred_product.product, any_product.product, gf.product, 'unspecified product'), 1, 300)
            || ' (' || COALESCE(preferred_name.name, any_name.name) || ')' 
           ELSE SUBSTR(COALESCE(preferred_product.product, any_product.product, gf.product, 'unspecified product'), 1, 300)
           END AS product,
       COALESCE(preferred_name.name, any_name.name) AS name,
       gf.is_pseudo,
       LEAST(nl.start_min, nl.end_max) AS start_min,
       GREATEST(nl.start_min, nl.end_max) AS end_max,
       CASE
         WHEN nl.is_reversed = 1
           THEN coding_range.max_coding_start
         ELSE coding_range.min_coding_start
       END as coding_start,
       CASE
         WHEN nl.is_reversed = 1
           THEN coding_range.min_coding_end
         ELSE coding_range.max_coding_end
       END as coding_end,
       nl.is_reversed,
       sns.length AS transcript_length,
       GREATEST(1, least(nl.start_min, nl.end_max) - 15000)
           AS context_start,
       LEAST(sequence.length, greatest(nl.start_min, nl.end_max) + 15000)
           AS context_end,
       DECODE(nvl(nl.is_reversed, 0), 0, 'forward', 1, 'reverse',
              nl.is_reversed) AS strand,
       SUBSTR(sequence.source_id, 1, 50) AS sequence_id,
       SUBSTR(tn.name, 1, 100) AS organism,
       SUBSTR(species_name.name, 1, 100) AS species,
       taxon.ncbi_tax_id,
       so_id, SUBSTR(so.term_name, 1, 150) AS so_term_name,
       SUBSTR(so.definition, 1, 150) AS so_term_definition,
       so.ontology_name, SUBSTR(so.so_version, 1, 7) AS so_version,
       SUBSTR(NVL(rt1.anticodon, rt2.anticodon), 1, 3) AS anticodon,
       protein.tm_count, protein.molecular_weight,
       protein.isoelectric_point, protein.min_molecular_weight,
       protein.max_molecular_weight, protein.hydropathicity_gravy_score,
       protein.aromaticity_score, protein.cds_length, protein.protein_length,
       protein.ec_numbers,
       ed.name AS external_db_name,
       SUBSTR(edr.version, 1, 10) AS external_db_version,
       exons.exon_count, SUBSTR(cmnt.comment_string, 1, 300) AS comment_string,
       SUBSTR(sequence.chromosome, 1, 20) AS chromosome,
       sequence.chromosome_order_num, sequence.na_sequence_id,
       go.annotated_go_component,
       go.annotated_go_function,
       go.annotated_go_process,
       go.predicted_go_component,
       go.predicted_go_function,
       go.predicted_go_process,
       nvl(deprecated.is_deprecated, 0) as is_deprecated, gi.gene_id,
       substr(orthologs.name, 1, 60) as orthomcl_name,
       nvl(tothtssnps.total_hts_snps,0) as total_hts_snps, 
       nvl(totsnps.total_snps,0) as total_snps, 
       nvl(nssnps.nonsyn_snps,0) as nonsynonymous_snps,
       nvl(synsnps.syn_snps,0) as synonymous_snps,
       CASE WHEN (nssnps.nonsyn_snps is null) THEN 0
            WHEN (synsnps.syn_snps is null) THEN null
            ELSE round((nssnps.nonsyn_snps / synsnps.syn_snps),2) END as nonsyn_syn_ratio, 
       nvl(tothtssnps.hts_nonsynonymous_snps,0) as hts_nonsynonymous_snps,
       nvl(tothtssnps.hts_synonymous_snps,0) as hts_synonymous_snps,
       nvl(tothtssnps.hts_nonsyn_syn_ratio,0) as hts_nonsyn_syn_ratio, 
       0 as five_prime_utr_length,
       0 as three_prime_utr_length,
       protein.signalp_scores,protein.signalp_peptide, sequence.taxon_id, protein.aa_sequence_id, protein.protein_source_id
FROM dots.GeneFeature gf, &prefixFeatureLocation nl, sres.SequenceOntology so,
     sres.Taxon, sres.TaxonName tn, dots.RnaType rt1, dots.RnaType rt2,
     dots.Transcript t, sres.ExternalDatabase ed,
     sres.ExternalDatabaseRelease edr, dots.SplicedNaSequence sns,
     &prefixGeneProteinAttributes protein, &prefixGeneGoAttributes go,
     &prefixGenomicSequence sequence,
     dots.geneinstance gi, &prefixTaxonSpecies ts, sres.TaxonName species_name,
     (SELECT DISTINCT gene AS source_id FROM &prefixGeneId) gene,
     (SELECT parent_id, count(*) AS exon_count
      FROM dots.ExonFeature
      GROUP BY parent_id) exons,
     (SELECT parent_id, max(coding_start) as max_coding_start, min(coding_start) as min_coding_start,
             max(coding_end) as max_coding_end, min(coding_end) as min_coding_end
      FROM &prefixFeatureLocation
      WHERE feature_type = 'ExonFeature'
        AND is_top_level = 1
      GROUP BY parent_id) coding_range,
     (SELECT nfc.na_feature_id,
             MAX(DBMS_LOB.SUBSTR(nfc.comment_string, 300, 1))
               AS comment_string
      FROM dots.NaFeatureComment nfc
      GROUP BY nfc.na_feature_id) cmnt,
     (select distinct gf.source_id, 1 as is_deprecated
      from dots.GeneFeature gf, dots.DbRefNaFeature drnf, sres.DbRef dr, sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed
      where gf.na_feature_id = drnf.na_feature_id
        and drnf.db_ref_id = dr.db_ref_id
        and dr.external_database_release_id = edr.external_database_release_id
        and edr.external_database_id = ed.external_database_id
        and ed.name = 'gassAWB_dbxref_gene2Deprecated_RSRC') deprecated,
     ( select parent_id, total_hts_snps, hts_nonsynonymous_snps, hts_synonymous_snps,
        case when (hts_nonsynonymous_snps is null) then 0
              when (hts_synonymous_snps = 0) then 0
                   else round ((hts_nonsynonymous_snps/ hts_synonymous_snps), 2) end as hts_nonsyn_syn_ratio 
      from ( select sf.parent_id,
                    count(*) as total_hts_snps,
                    count(has_nonsynonymous_allele) as hts_nonsynonymous_snps,
                    count(*) - count(has_nonsynonymous_allele) as hts_synonymous_snps
             from dots.SnpFeature sf, sres.ExternalDatabaseRelease rel, sres.ExternalDatabase d
             where d.name = 'InsertSnps.pm NGS SNPs INTERNAL'
               and d.external_database_id = rel.external_database_id
               and sf.external_database_release_id = rel.external_database_release_id
               and sf.parent_id is not null
             group by sf.parent_id
      ) ) tothtssnps, 
     (select sf.parent_id,count(*) as total_snps
      from dots.SnpFeature sf, sres.ExternalDatabaseRelease rel, sres.ExternalDatabase d
      where d.name not in ('pfal3D7_SNP_Broad_gff_RSRC','Broad SNPs','Sanger falciparum SNPs', 'pfal3D7_SNP_sanger_ItGhana_gff_RSRC', 'Winzeler Array - Plasmodium Genetic Variation','pfal3D7_SNP_Winzeler_Genetic_Variation_Array_gff_RSRC','X.Su SNPs','pfal3D7_SNP_XSu_gff_RSRC','Sanger reichenowi SNPs','pfal3D7_SNP_sanger_PReichenowi_gff_RSRC')
      and d.external_database_id = rel.external_database_id
      and sf.external_database_release_id = rel.external_database_release_id
      and sf.parent_id is not null
      group by sf.parent_id) totsnps,
     (select sf.parent_id,count(*) as nonsyn_snps
      from dots.SnpFeature sf, sres.ExternalDatabaseRelease rel, sres.ExternalDatabase d
      where d.name not in ('pfal3D7_SNP_Broad_gff_RSRC','Broad SNPs','Sanger falciparum SNPs','pfal3D7_SNP_sanger_ItGhana_gff_RSRC',
             'Winzeler Array - Plasmodium Genetic Variation','pfal3D7_SNP_Winzeler_Genetic_Variation_Array_gff_RSRC','X.Su SNPs','pfal3D7_SNP_XSu_gff_RSRC','Sanger reichenowi SNPs','pfal3D7_SNP_sanger_PReichenowi_gff_RSRC')
        and d.external_database_id = rel.external_database_id
        and sf.external_database_release_id = rel.external_database_release_id
        and sf.parent_id is not null
        and sf.has_nonsynonymous_allele = 1
      group by sf.parent_id) nssnps,
     (select sf.parent_id,count(*) as syn_snps
      from dots.SnpFeature sf, sres.ExternalDatabaseRelease rel, sres.ExternalDatabase d
      where d.name not in ('pfal3D7_SNP_Broad_gff_RSRC','Broad SNPs','Sanger falciparum SNPs','pfal3D7_SNP_sanger_ItGhana_gff_RSRC',
             'Winzeler Array - Plasmodium Genetic Variation','pfal3D7_SNP_Winzeler_Genetic_Variation_Array_gff_RSRC','X.Su SNPs','pfal3D7_SNP_XSu_gff_RSRC','Sanger reichenowi SNPs','pfal3D7_SNP_sanger_PReichenowi_gff_RSRC')
        and d.external_database_id = rel.external_database_id
        and sf.external_database_release_id = rel.external_database_release_id
        and sf.parent_id is not null
        and sf.has_nonsynonymous_allele is null
        and sf.is_coding = 1
      group by sf.parent_id) synsnps,
     (  select gf.na_feature_id, sg.name
        from dots.genefeature gf, dots.SequenceSequenceGroup ssg, 
             dots.SequenceGroup sg, core.TableInfo ti
        where gf.na_feature_id = ssg.sequence_id
          and ssg.sequence_group_id = sg.sequence_group_id
          and ssg.source_table_id = ti.table_id
          and ti.name = 'GeneFeature'
       ) orthologs,
     (select na_feature_id, max(product) as product
      from apidb.GeneFeatureProduct
      where is_preferred = 1
      group by na_feature_id
     ) preferred_product,
     (select na_feature_id, max(product) as product
      from apidb.GeneFeatureProduct
      group by na_feature_id
     ) any_product,
     (select na_feature_id, max(name) as name
      from apidb.GeneFeatureName
      where is_preferred = 1
      group by na_feature_id
     ) preferred_name,
     (select na_feature_id, max(name) as name
      from apidb.GeneFeatureName
      group by na_feature_id
     ) any_name
WHERE gf.source_id = gene.source_id
  AND gf.na_feature_id = nl.na_feature_id
  AND nl.is_top_level = 1
  AND nl.na_sequence_id = sequence.na_sequence_id
  AND (sequence.taxon_id = '&filterValue' or nvl('&filterValue', 0) = 0)
  AND gf.sequence_ontology_id = so.sequence_ontology_id
  AND sequence.taxon_id = taxon.taxon_id
  AND sequence.taxon_id = tn.taxon_id
  AND tn.name_class = 'scientific name'
  AND tn.taxon_id NOT IN
	 (SELECT o.taxon_id FROM apidb.Organism o WHERE  o.is_annotated_genome=0)
  AND gf.source_id = protein.source_id(+)
  AND gf.source_id = go.source_id(+)
  AND t.na_sequence_id = sns.na_sequence_id(+)
  AND gf.na_feature_id = t.parent_id(+)
  AND t.na_feature_id = rt1.parent_id(+)
  AND gf.na_feature_id = rt2.parent_id(+)
  AND gf.external_database_release_id
       = edr.external_database_release_id
  AND edr.external_database_id = ed.external_database_id
  AND gf.na_feature_id = exons.parent_id(+)
  AND gf.na_feature_id = orthologs.na_feature_id(+)
  AND gf.na_feature_id = coding_range.parent_id(+)
  AND gf.na_feature_id = cmnt.na_feature_id(+)
  AND gf.source_id = deprecated.source_id(+)
  AND gf.na_feature_id = gi.na_feature_id(+)
  AND gf.na_feature_id = totsnps.parent_id(+)
  AND gf.na_feature_id = tothtssnps.parent_id(+)
  AND gf.na_feature_id = nssnps.parent_id(+)
  AND gf.na_feature_id = synsnps.parent_id(+)
  AND sequence.taxon_id = ts.taxon_id(+)
  AND ts.species_taxon_id = species_name.taxon_id
  AND species_name.name_class = 'scientific name'
  AND gf.na_feature_id = preferred_product.na_feature_id(+)
  AND gf.na_feature_id = preferred_name.na_feature_id(+)
  AND gf.na_feature_id = any_product.na_feature_id(+)
  AND gf.na_feature_id = any_name.na_feature_id(+)
  AND (gf.is_predicted != 1 OR gf.is_predicted is null)
  AND tn.name not in ('Plasmodium gallinaceum','Plasmodium reichenowi')
      ]]>
    </sql>
<!-- 
    <sql>
      <![CDATA[
create table GeneAttributesDuplicates nologging as
select ga.source_id, count(*) as id_count from &prefixGeneAttributes&1 ga
group by ga.source_id having count(*) > 1
      ]]>
    </sql>
-->
    <sql>
      <![CDATA[
create unique index GeneAttr_sourceId&1
       ON &prefixGeneAttributes&1 (source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create unique index GeneAttr_srcPrj&1
       ON &prefixGeneAttributes&1 (source_id, project_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index GeneAttr_exon_ix&1
       ON &prefixGeneAttributes&1 (exon_count, source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index GeneAttr_loc_ix&1
       ON &prefixGeneAttributes&1 (na_sequence_id, start_min, end_max, is_reversed)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index GeneAttr_feat_ix&1
       ON &prefixGeneAttributes&1 (na_feature_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index GeneAttr_geneid_ix&1
       ON &prefixGeneAttributes&1 (gene_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index GeneAttr_orthoname_ix&1
       ON &prefixGeneAttributes&1 (orthomcl_name, source_id, taxon_id, gene_type)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index GeneAttr_ortholog_ix&1
       ON &prefixGeneAttributes&1 (source_id, na_sequence_id, start_min, end_max, orthomcl_name)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
  update &prefixGeneAttributes&1
  set exon_count = 1
  where exon_count > 1
   and project_id = 'TriTrypDB' 
   and source_id in (
                select source_id from &prefixGeneAttributes&1
              minus
                select source_id
                from (
                  select 'intron' as type, ga.source_id,
                          abs(rightLoc.start_min - leftLoc.end_max) as len
                  from dots.ExonFeature left, &prefixFeatureLocation leftLoc,
                       dots.ExonFeature right, &prefixFeatureLocation rightLoc,
                       &prefixGeneAttributes&1 ga
                  where left.parent_id = right.parent_id
                    and left.parent_id = ga.na_feature_id
                    and (left.order_number = right.order_number - 1
                         or left.order_number = right.order_number + 1)
                    and leftLoc.start_min < rightLoc.start_min
                    and left.na_feature_id = leftLoc.na_feature_id
                    and leftLoc.is_top_level = 1
                    and right.na_feature_id = rightLoc.na_feature_id
                    and rightLoc.is_top_level = 1
                   ) 
               group by source_id
               having min(len) > 10
           )
      ]]>
    </sql>
    <sql>
      <![CDATA[
  update &prefixGeneAttributes&1 ga
  set five_prime_utr_length = (
    select u.utr_length from
      ( select sum(length) utr_length, na_sequence_id, parent_id, is_reversed from UTR 
        where direction = 5
        group by na_sequence_id, parent_id, is_reversed ) u
    where u.parent_id = ga.na_feature_id
      and u.na_sequence_id = ga.na_sequence_id
   )
      ]]>
    </sql>
    <sql>
      <![CDATA[
  update &prefixGeneAttributes&1 ga
  set three_prime_utr_length = (
    select u.utr_length from
      ( select sum(length) utr_length, na_sequence_id, parent_id, is_reversed from UTR 
        where direction = 3
        group by na_sequence_id, parent_id, is_reversed ) u
    where u.parent_id = ga.na_feature_id
      and u.na_sequence_id = ga.na_sequence_id
   )
      ]]>
    </sql>
<!--
    <sql>
      <![CDATA[
update &prefixGeneAttributes&1 ga
set ga.orthomcl_name = (select distinct gb.orthomcl_name from &prefixGeneAttributes&1 gb
                     where gb.gene_id = ga.gene_id
                     and gb.orthomcl_name is not null
                     and gb.source_id != gb.orthomcl_name)
where ga.organism like 'Toxo%' 
and ga.orthomcl_name is null
      ]]>
    </sql>
-->
    <sql>
      <![CDATA[
        update &prefixGeneAttributes&1
        set orthomcl_name = 'ORTH_' || gene_id || '.tmp'
        where orthomcl_name is null
        and gene_id is not null
      ]]>
    </sql>
    <sql>
      <![CDATA[
        update &prefixGeneAttributes&1
        set orthomcl_name = source_id
        where orthomcl_name is null
      ]]>
    </sql>
    <sql>
      <![CDATA[
       alter table &prefixGeneAttributes&1
       add (
            paralog_number number,
            ortholog_number number
            )
      ]]>
    </sql>
    <sql>
      <![CDATA[
       update &prefixGeneAttributes&1 set ortholog_number = 0,paralog_number = 0
      ]]>
    </sql>
    <sql>
      <![CDATA[
       update &prefixGeneAttributes&1 gaup
       set paralog_number = (select count(*)
                               from &prefixGeneAttributes&1 g1
                               where g1.orthomcl_name = gaup.orthomcl_name
                               and g1.organism = gaup.organism
                               and gaup.source_id != g1.source_id),
           ortholog_number = (select count(*)
                               from &prefixGeneAttributes&1 g1
                               where g1.orthomcl_name = gaup.orthomcl_name
                               and g1.organism != gaup.organism)
        where gaup.gene_type = 'protein coding'
      ]]>
    </sql>
    <sql>
      <![CDATA[
        update &prefixGeneAttributes&1
        set gene_id = na_feature_id -- gene_id is NUMBER(10) and source_id is VARCHAR(80) 
        where gene_id is null
      ]]>
    </sql>
<!--
This code will scale the context start and end so that ~ 10 genes appear in the genomic context;  it is breaking ... setting most to null;  This was added to help with the gbrwose popup/labels problems.... that is now a nonissue.   This code isn't as important
    <sql>
      <![CDATA[
    update &prefixGeneAttributes&1 gattr
    set (gattr.context_start, gattr.context_end) = (select nvl(context_start, gattr.context_start), 
                                                           nvl(context_end, gattr.context_end)
                                                    from (select ga.source_id, 
                                                                 round(ga.context_start + (least(ga.start_min, ga.end_max)- ga.context_start) * (10/count(*)) ) as context_start,
                                                                 round(ga.context_end - (ga.context_end - greatest(ga.start_min, ga.end_max)) * (10/count(*)) ) as context_end
                                                          from &prefixGeneAttributes&1 ga,
                                                               &prefixFeatureLocation fl
                                                          where fl.is_top_level =  1
                                                          and fl.feature_type =  'GeneFeature'
                                                          and ga.sequence_id = fl.sequence_source_id
                                                          and least(fl.start_min, fl.end_max) >= ga.context_start
                                                          and greatest(fl.start_min, fl.end_max) <= ga.context_end
                                                          group by ga.source_id, ga.context_start, ga.context_end, ga.start_min, ga.end_max
                                                          having count(*) > 10) gattrup
                                                    where gattrup.source_id = gattr.source_id
                                                    )
      ]]>
    </sql>
-->
  </tuningTable>


  <tuningTable name="GenomicSequence" prefixEnabled="true">
    <!-- Combines ExternalNaSequence with VirtualSequence, while excluding
         ExternalNaSequence records whose source_id also appears in
         VirtualSequence. Used by both model and GBrowse queries, as well as in
         the creation of several tuning tables, including SequenceAttributes and
         GeneAttributes. 
     -->
    <externalDependency name="dots.ExternalNaSequence"/>
    <externalDependency name="dots.VirtualSequence"/>
    <externalDependency name="sres.SequenceOntology"/>
    <sql>
      <![CDATA[
CREATE TABLE &prefixGenomicSequence&1 NOLOGGING AS
  SELECT ens.na_sequence_id, ens.taxon_id,
         SUBSTR(ens.source_id, 1, 50) AS source_id,
         LOWER(SUBSTR(ens.source_id, 1, 50)) AS lowercase_source_id,
         ens.a_count, ens.c_count, ens.g_count, ens.t_count, ens.length,
         SUBSTR(ens.description, 1, 400) AS description,
         ens.external_database_release_id,
         SUBSTR(ens.chromosome, 1, 40) AS chromosome,
         ens.chromosome_order_num, ens.sequence_ontology_id
  FROM dots.ExternalNaSequence ens, sres.SequenceOntology so
  WHERE ens.sequence_ontology_id = so.sequence_ontology_id
    AND so.term_name != 'EST'
    AND so.term_name != 'oligo'
    AND (ens.taxon_id = '&filterValue' or nvl('&filterValue', 0) = 0)
    AND -- see both? use the VirtualSequence.
        ens.source_id IN (SELECT source_id FROM dots.ExternalNaSequence
                         MINUS
                          SELECT source_id FROM dots.VirtualSequence)
UNION
  SELECT na_sequence_id, taxon_id, SUBSTR(source_id, 1, 50) AS source_id,
         LOWER(SUBSTR(source_id, 1, 50)) AS lowercase_source_id,
         a_count, c_count, g_count, t_count, length,
         SUBSTR(description, 1, 400) AS description,
         external_database_release_id, SUBSTR(chromosome, 1, 40) AS chromosome,
         chromosome_order_num, sequence_ontology_id
  FROM dots.VirtualSequence
  WHERE (taxon_id = '&filterValue' or nvl('&filterValue', 0) = 0)
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index GS_sourceId&1 ON &prefixGenomicSequence&1 (source_id, na_sequence_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index GS_lcSourceId&1 ON &prefixGenomicSequence&1 (lowercase_source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index GS_naSeqId&1 ON &prefixGenomicSequence&1 (na_sequence_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="SequenceAttributes" prefixEnabled="true">
    <!-- Each row represents one genomic sequence for which a WDK sequence
         record can be instantiated. Used widely in the workflow, the model,
         and GBrowse, as well as in the creation of a dozen or so other tuning
         tables.
     -->
    <internalDependency name="GenomicSequence"/>
    <internalDependency name="SequencePieceClosure"/>
    <externalDependency name="dots.DbRefNaSequence"/>
    <externalDependency name="sres.DbRef"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.SequenceOntology"/>
    <externalDependency name="sres.Taxon"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE &prefixSequenceAttributes&1 NOLOGGING AS
SELECT cast(apidb.project_id(tn.name) as varchar2(20)) as project_id,
       SUBSTR(sequence.source_id, 1, 60) AS source_id, sequence.a_count,
       sequence.c_count, sequence.g_count, sequence.t_count,
       (sequence.length
        - (sequence.a_count + sequence.c_count + sequence.g_count + sequence.t_count))
         AS other_count,
       sequence.length,
       to_char((sequence.a_count + sequence.t_count) / sequence.length * 100, '99.99')
         AS at_percent,
       SUBSTR(tn.name, 1, 100) AS organism,
       taxon.ncbi_tax_id,
       taxon.taxon_id,                 
       CASE WHEN sequence.description IS NULL  THEN SUBSTR(tn.name, 1, 100)
            ELSE SUBSTR(sequence.description, 1, 400)
            END AS sequence_description,
       SUBSTR(genbank.genbank_accession, 1, 20) AS genbank_accession,
       SUBSTR(db.database_version, 1, 30) AS database_version, db.database_name,
       SUBSTR(sequence.chromosome, 1, 20) AS chromosome,
       sequence.chromosome_order_num, so.so_id, so.term_name as sequence_type,
       nvl(virtualization.is_top_level, 1) as is_top_level,
       sequence.na_sequence_id,
       organism.genome_source, organism.name_for_filenames
FROM sres.TaxonName tn, sres.Taxon, sres.SequenceOntology so, apidb.Organism,
     &prefixGenomicSequence sequence,
     (SELECT drns.na_sequence_id, max(dr.primary_identifier) AS genbank_accession
      FROM dots.dbrefNaSequence drns, sres.DbRef dr,
           sres.ExternalDatabaseRelease gb_edr, sres.ExternalDatabase gb_ed
      WHERE drns.db_ref_id = dr.db_ref_id
        AND dr.external_database_release_id
            = gb_edr.external_database_release_id
        AND gb_edr.external_database_id = gb_ed.external_database_id
        AND gb_ed.name = 'GenBank'
      GROUP BY drns.na_sequence_id) genbank,
     (SELECT edr.external_database_release_id,
             edr.version AS database_version, ed.name AS database_name
      FROM sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr
      WHERE edr.external_database_id = ed.external_database_id) db,
     (SELECT distinct piece_na_sequence_id, 0 as is_top_level
      FROM &prefixSequencePieceClosure) virtualization
WHERE sequence.taxon_id = tn.taxon_id(+)
  AND (sequence.taxon_id = '&filterValue' or nvl('&filterValue', 0) = 0)
  AND tn.name_class = 'scientific name'
  AND sequence.taxon_id = taxon.taxon_id
  AND sequence.sequence_ontology_id = so.sequence_ontology_id
  AND so.term_name IN ('random_sequence', 'chromosome', 'contig', 'supercontig','mitochondrial_chromosome','plastid_sequence','cloned_genomic','apicoplast_chromosome')
  AND sequence.na_sequence_id = genbank.na_sequence_id(+)
  AND sequence.external_database_release_id = db.external_database_release_id(+)
  AND sequence.na_sequence_id = virtualization.piece_na_sequence_id(+)
  AND taxon.taxon_id = organism.taxon_id (+)
      ]]>
    </sql>
    <sql>
      <![CDATA[
create unique index pk_SeqAttr_&1 ON &prefixSequenceAttributes&1 (lower(source_id), project_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
create unique index SeqAttr_source_id&1 ON &prefixSequenceAttributes&1 (source_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
create unique index SeqAttr_naseqid&1 ON &prefixSequenceAttributes&1 (na_sequence_id)
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="SnpAttributes">
    <!-- Each record represents one SNP. Widely used in the model, as well as in
         the creation of several other tuning tables, including SnpSummary and
         IsolateSnps.
     -->
    <internalDependency name="FeatureLocation"/>
    <externalDependency name="dots.GeneFeature"/>
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="dots.SeqVariation"/>
    <externalDependency name="dots.SnpFeature"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.Taxon"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE SnpAttributes&1 NOLOGGING AS
SELECT cast(apidb.project_id(tn.name) as varchar2(20)) as project_id,
       snp.source_id,
       snp.na_feature_id,
       ed.name AS dataset,
       decode(ed.name,'InsertSnps.pm NGS SNPs INTERNAL','HTS','Other') as type,
       sequence.na_sequence_id,
       sequence.source_id AS seq_source_id,
       snp_loc.start_min,
       SUBSTR(snp.reference_strain, 1, 200) AS reference_strain,
       SUBSTR(snp.reference_na, 1, 200) AS reference_na,
       DECODE(snp.is_coding, 0, 'no', 1, 'yes') AS is_coding,
       snp.position_in_CDS,
       snp.position_in_protein,
       SUBSTR(snp.reference_aa, 1, 200) AS reference_aa,
       DECODE(snp.has_nonsynonymous_allele, 0, 'no', 1, 'yes')
         AS has_nonsynonymous_allele,
       SUBSTR(snp.major_allele, 1, 40) AS major_allele,
       SUBSTR(snp.major_product, 1, 40) AS major_product,
       SUBSTR(strain_info.minor_allele, 1, 40) AS minor_allele,
       SUBSTR(strain_info.minor_product, 1, 40) AS minor_product,
       strain_info.major_strains,strain_info.minor_strains,
       snp.major_allele_count, 
       round(snp.major_allele_count / (snp.major_allele_count + snp.minor_allele_count),2) as major_allele_frequency,
       snp.minor_allele_count,
       round(snp.minor_allele_count / (snp.major_allele_count + snp.minor_allele_count),2) as minor_allele_frequency,
       strain_info.distinct_strain_count as strain_count,
       gene_info.source_id AS gene_source_id,
       DECODE(gene_info.is_reversed, 0, 'forward', 1, 'reverse')
         AS gene_strand,
       SUBSTR(DBMS_LOB.SUBSTR(sequence.sequence, 60, snp_loc.start_min - 60), 1, 60)
         AS lflank,
       SUBSTR(DBMS_LOB.SUBSTR(sequence.sequence, 60, snp_loc.start_min + 1), 1, 60)
         AS rflank,
       SUBSTR(tn.name, 1, 100) AS organism,
       taxon.ncbi_tax_id,
       SUBSTR(chromosome_info.chromosome, 1, 20) AS chromosome,
       chromosome_info.chromosome_order_num
FROM dots.SnpFeature snp, FeatureLocation snp_loc,
     sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr, sres.Taxon,
     sres.TaxonName tn, dots.NaSequence sequence,
     (SELECT gene.source_id, gene_loc.is_reversed, gene.na_feature_id,
             gene_loc.na_sequence_id
      FROM dots.GeneFeature gene, FeatureLocation gene_loc
      WHERE gene.na_feature_id = gene_loc.na_feature_id
            and gene_loc.is_top_level = 1) gene_info,
     (SELECT na_sequence_id, chromosome, chromosome_order_num
      FROM dots.ExternalNaSequence
     UNION
      SELECT na_sequence_id, chromosome, chromosome_order_num
      FROM dots.VirtualSequence
     UNION
      SELECT na_sequence_id, null as chromosome, null as chromosome_order_num
      FROM dots.NaSequence
      WHERE subclass_view not in ('ExternalNASequence', 'VirtualSequence')
     ) chromosome_info,
     (select distinct sf.na_feature_id, 
             apidb.tab_to_string(set(cast(COLLECT(distinct CASE WHEN sv.allele != sf.major_allele THEN sv.allele END order by sv.allele) as apidb.varchartab)), ', ') as minor_allele,                
             apidb.tab_to_string(set(cast(COLLECT(distinct CASE WHEN sv.allele != sf.major_allele THEN sv.product END order by sv.product) as apidb.varchartab)), ', ') as minor_product,
             apidb.tab_to_string(set(cast(COLLECT(CASE WHEN sv.allele != sf.major_allele THEN sv.strain END order by sv.strain) as apidb.varchartab)), ', ') as minor_strains,
             apidb.tab_to_string(set(cast(COLLECT(CASE WHEN sv.allele = sf.major_allele THEN sv.strain END order by sv.strain) as apidb.varchartab)), ', ') as major_strains,
             count(distinct sv.strain) as distinct_strain_count
      from dots.SnpFeature sf, dots.SeqVariation sv
      where sv.parent_id = sf.na_feature_id
      group by sf.na_feature_id) strain_info
WHERE edr.external_database_release_id = snp.external_database_release_id
  AND ed.external_database_id = edr.external_database_id
  AND sequence.taxon_id = taxon.taxon_id
  AND sequence.taxon_id = tn.taxon_id
  AND tn.name_class = 'scientific name'
  AND snp_loc.na_feature_id = snp.na_feature_id
  AND snp_loc.is_top_level = 1
  AND sequence.na_sequence_id = snp_loc.na_sequence_id
  AND chromosome_info.na_sequence_id = snp_loc.na_sequence_id
  and strain_info.na_feature_id = snp.na_feature_id
  AND gene_info.na_feature_id(+) = snp.parent_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
create unique index SnpAttr_source_id&1 ON SnpAttributes&1 (source_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index Snp_nafeat_dataset_ix&1
       ON SnpAttributes&1 (na_feature_id, dataset)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index Snp_Seq_ix&1
       ON SnpAttributes&1 (na_sequence_id, dataset, start_min, na_feature_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index Snp_Freq_ix&1
       ON SnpAttributes&1 (dataset,strain_count,major_allele_frequency,minor_allele_frequency)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index SnpAttr_ds_org_ix&1 on snpattributes&1 (dataset,organism,na_feature_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index SnpVariantIx&1 on SnpAttributes&1 (type, dataset, na_feature_id, source_id, gene_source_id, start_min, position_in_protein)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="HtsVariant">
    <!-- This table is like SeqVariation, but only for HTS SNPs, and filtered
         for allele_percent > 80. Used in SNP queries, and to make the
         GoodHtsSnp tuning table.
     -->
    <internalDependency name="SnpAttributes"/>
    <externalDependency name="dots.SeqVariation"/>
    <sql>
      <![CDATA[
        create table HtsVariant&1 nologging as
        select snp.na_feature_id as snp_na_feature_id, min(var.na_feature_id) as var_na_feature_id,
               substr(var.allele, 1, 1) as allele,
               substr(max(var.product), 1, 30) as product, substr(var.strain, 1, 30) as strain,
               min(t.taxon_id) as species_taxon_id,
               substr(min(snp.source_id), 1, 50) as snp_source_id, min(snp.gene_source_id) as gene_source_id
        from dots.SeqVariation var, SnpAttributes snp, sres.Taxon t
        where var.parent_id = snp.na_feature_id
          and snp.ncbi_tax_id = t.ncbi_tax_id
          and snp.type = 'HTS'
          and var.name = 'SNP'
          and var.allele != 'undefined' -- this actually shows up in some crypto records
              -- we can only use this allele_percent cutoff for haploid parasites, like plasmodium and toxoplasma
          and (var.allele_percent > 80 or var.allele_percent is null)
        group by snp.na_feature_id, var.allele, var.strain
      ]]>
    </sql>
    <sql>
      <![CDATA[
        delete from HtsVariant&1
        where snp_na_feature_id
              in (select snp_na_feature_id
                  from (select snp_na_feature_id, count(distinct allele) as allele_count
                        from ApidbTuning.HtsVariant&1
                        group by snp_na_feature_id)
                  where allele_count = 1)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index htsvar_ix&1
        on HtsVariant&1 (strain, species_taxon_id,   -- access predicates for strain comparison
                         snp_source_id, allele, product) -- others
        tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="GoodHtsSnp">
    <!-- One record per HTS SNP location, rolled up from HtsVariant. Used for
         SNP queries.
     -->
    <internalDependency name="HtsVariant"/>
    <sql>
      <![CDATA[
        create table GoodHtsSnp&1 nologging as
        with snp_alleles -- one row per (SNP, allele) pair
             as (select snp_na_feature_id, max(snp_source_id) as snp_source_id, max(species_taxon_id) as taxon_id,
                        allele, max(product) as product, count(*) as strain_count
                 from ApidbTuning.HtsVariant
                 group by snp_na_feature_id, allele),
             ranked_alleles -- add ranking within SNP: 1 for major allele, 2 for silver medalist, et c.
             as (select snp_na_feature_id, allele, snp_source_id, taxon_id, product, strain_count,
                        row_number() over (partition by snp_na_feature_id order by strain_count desc) as ranking
                 from snp_alleles),
             allele_majority -- break out attributes to major_X and minor_X
             as (select snp_na_feature_id, snp_source_id, taxon_id, strain_count,
                        case when ranking = 1 then strain_count else 0 end as major_allele_count,
                        case when ranking = 1 then 0 else strain_count end as minor_allele_count,
                        case when ranking = 1 then allele else null end as major_allele,
                        case when ranking = 1 then null else allele end as minor_allele,
                        case when ranking = 1 then product else null end as major_product,
                        case when ranking = 1 then null else product end as minor_product
                 from ranked_alleles)
        select snp_na_feature_id as na_feature_id, max(snp_source_id) as source_id, max(taxon_id) as taxon_id,
               sum(strain_count) as strain_count,
               substr(listagg(minor_allele, ', ') within group (order by strain_count desc), 1, 12) as minor_allele,
               substr(listagg(major_allele, ', ') within group (order by major_allele), 1, 1) as major_allele,
               substr(listagg(minor_product, ', ') within group (order by strain_count desc), 1, 12) as minor_product,
               substr(listagg(major_product, ', ') within group (order by major_product), 1, 12) as major_product,
               sum(major_allele_count) / sum(strain_count) as major_allele_frequency,
               sum(minor_allele_count) / sum(strain_count) as minor_allele_frequency
        from allele_majority
        group by snp_na_feature_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index goodSnp_ix&1
        on GoodHtsSnp&1 (taxon_id, strain_count, -- access predicates
                         minor_allele_frequency, -- filter predicates
                         source_id, major_allele, minor_allele, major_product, minor_product) -- selectables
        tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="OrfAttributes">
    <!-- Each record represents an ORF. Used by the model and the sequence
         retrieval tool for ORF-related queries.
     -->
    <internalDependency name="FeatureLocation"/>
    <internalDependency name="GenomicSequence"/>
    <externalDependency name="dots.ExternalNaSequence"/>
    <externalDependency name="dots.Miscellaneous"/>
    <externalDependency name="dots.TranslatedAaFeature"/>
    <externalDependency name="dots.TranslatedAaSequence"/>
    <externalDependency name="sres.SequenceOntology"/>
    <externalDependency name="sres.Taxon"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE OrfAttributes&1 NOLOGGING AS
SELECT distinct
       cast(apidb.project_id(tn.name) as varchar2(20)) as project_id,
       SUBSTR(m.source_id, 1, 60) AS source_id,
       LOWER(SUBSTR(m.source_id, 1, 60)) AS lowercase_source_id,
       SUBSTR(tn.name, 1, 100) AS organism,
       taxon.ncbi_tax_id,
       SUBSTR(sequence.source_id, 1, 30) AS nas_id,
       tas.length,
       nl.start_min, nl.end_max, nl.is_reversed,
       SUBSTR(sequence.chromosome, 1, 20) AS chromosome,
       sequence.chromosome_order_num, sequence.na_sequence_id
FROM dots.Miscellaneous m, dots.TranslatedAaFeature taaf,
     dots.TranslatedAaSequence tas, sres.Taxon, sres.TaxonName tn,
     sres.SequenceOntology so, FeatureLocation nl,
     -- subquery for sequence. Can't just use GenomicSequence,
     -- which only contains records eligible to be the result of a sequence search.
     -- ORFs can be on other sequences, such as ESTs in cryptodb.
     (  select gs.na_sequence_id, gs.source_id, gs.chromosome, gs.chromosome_order_num, gs.taxon_id
        from GenomicSequence gs
      union
        select ens.na_sequence_id, ens.source_id, ens.chromosome, ens.chromosome_order_num, ens.taxon_id
        from dots.ExternalNaSequence ens
        where ens.na_sequence_id in (select distinct na_sequence_id from dots.Miscellaneous
                                  minus select na_sequence_id
                                        from GenomicSequence)) sequence
WHERE m.na_feature_id = taaf.na_feature_id
  AND taaf.aa_sequence_id = tas.aa_sequence_id
  AND sequence.na_sequence_id = nl.na_sequence_id
  AND sequence.taxon_id = tn.taxon_id
  AND sequence.taxon_id = taxon.taxon_id
  AND m.sequence_ontology_id = so.sequence_ontology_id
  AND m.na_feature_id = nl.na_feature_id
  AND nl.is_top_level = 1
  AND so.term_name = 'ORF'
  AND tn.name_class='scientific name'
      ]]>
    </sql>
    <sql>
      <![CDATA[
create unique index OrfAttr_source_id&1 ON OrfAttributes&1 (source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index OrfAttr_location_idx&1 ON OrfAttributes&1 (na_sequence_id, start_min, end_max, is_reversed)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="EstAttributes">
    <!-- Each row represents one EST. Used widely in the model, and to make the
         tuning tables BlastTypes, OrganismAbbreviationBlast, and OrganismAttributes.
     -->
    <externalDependency name="dots.BlatAlignment"/>
    <externalDependency name="dots.Est"/>
    <externalDependency name="dots.ExternalNaSequence"/>
    <externalDependency name="dots.Library"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.SequenceOntology"/>
    <externalDependency name="sres.Taxon"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE EstAttributes&1 NOLOGGING AS
SELECT cast(apidb.project_id(tn.name) as varchar2(20)) as project_id,
       ens.source_id,
       e.seq_primer AS primer,
       ens.a_count,
       ens.c_count,
       ens.g_count,
       ens.t_count,
       (ens.length - (ens.a_count + ens.c_count + ens.g_count + ens.t_count))
         AS other_count,
       ens.length,
       l.dbest_name,
       nvl(regexp_replace(l.vector, '^\s+$', null), 'unknown') AS vector,
       nvl(regexp_replace(l.stage, '^\s+$', null), 'unknown') AS stage,
       SUBSTR(CASE
                WHEN tn.name = 'Giardia lamblia' THEN 'Giardia Assemblage A isolate WB' 
                ELSE tn.name
              END, 1, 100) AS organism,
       taxon.ncbi_tax_id,
       ed.name AS external_db_name,
       nvl(best.best_alignment_count, 0) AS best_alignment_count,
       l.library_id, l.dbest_name as library_dbest_name
FROM dots.Est e, dots.ExternalNaSequence ens, dots.Library l, sres.Taxon,
     sres.TaxonName tn, sres.ExternalDatabase ed,
     sres.ExternalDatabaseRelease edr, sres.SequenceOntology so,
     (select query_na_sequence_id,max(ct) as best_alignment_count
      from (
            SELECT query_na_sequence_id, COUNT(*) AS ct
             FROM dots.BlatAlignment ba
             WHERE is_best_alignment = 1
             GROUP BY target_external_db_release_id,query_na_sequence_id)
      group by query_na_sequence_id) best
WHERE e.na_sequence_id = ens.na_sequence_id
  AND e.library_id = l.library_id
  AND ens.taxon_id = tn.taxon_id
  AND ens.taxon_id = taxon.taxon_id
  AND tn.name_class='scientific name'
  AND ens.external_database_release_id = edr.external_database_release_id
  AND edr.external_database_id = ed.external_database_id
  AND ens.sequence_ontology_id = so.sequence_ontology_id
  AND so.term_name = 'EST'
  AND best.query_na_sequence_id(+) = ens.na_sequence_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
create unique index EstAttr_source_id&1 ON EstAttributes&1 (source_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="BlatAlignmentLocation">
    <!-- Locations of BLAT alignments, both on the sequences they're annotated
         onto and also transitively through SequencePiece. Used in model and
         GBrowse queries, as well as in the creation of the tuning tables
         EstAlignmentGeneSummary and AsmAlignmentGeneSummary.
     -->
    <internalDependency name="SequencePieceClosure"/>
    <externalDependency name="core.TableInfo"/>
    <externalDependency name="dots.BlatAlignment"/>
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <sql>
      <![CDATA[ 
     delete from dots.BlatAlignment 
           where query_na_sequence_id in 
                (select s.na_sequence_id
                from sres.ExternalDatabase d, sres.ExternalDatabaseRelease r, dots.ExternalNaSequence s
                where d.external_database_id = r.external_database_id
                 and s.external_database_release_id = r.external_database_release_id
                 and d.name in ('Tcruzi_BACEnds_RSRC',
                                'Tbrucei_Genbank_BACEnds_RSRC',
                                'Lmajor_sanger_BACEnds_RSRC',
                                'Lmajor_sanger_PACEnds_RSRC',
                                'Lmajor_sanger_CosmidEnds_RSRC')
            ) and is_best_alignment != 1
      ]]> 
    </sql>
    <sql>
      <![CDATA[ 
      CREATE TABLE BlatAlignmentLocation&1 NOLOGGING AS
      SELECT blat_alignment_id, query_na_sequence_id, target_na_sequence_id,
             query_table_id, query_taxon_id, query_external_db_release_id,
             target_table_id, target_taxon_id, target_external_db_release_id,
             is_consistent, is_genomic_contaminant, unaligned_3p_bases,
             unaligned_5p_bases, has_3p_polya, has_5p_polya, is_3p_complete,
             is_5p_complete, percent_identity, max_query_gap, max_target_gap,
             number_of_spans, query_start, query_end, target_start, target_end,
             is_reversed, query_bases_aligned, repeat_bases_aligned, num_ns, score,
             is_best_alignment, blat_alignment_quality_id, blocksizes, qstarts,
             tstarts, cast('direct' as varchar2(7)) as location_mapping
      FROM dots.BlatAlignment
      ]]> 
    </sql>
    <perl>
      <![CDATA[ 
      use strict;
      use lib "$ENV{GUS_HOME}/lib/perl";

      my $sql = <<SQL;
        select blat_alignment_id, query_na_sequence_id, target_na_sequence_id,
               query_table_id, query_taxon_id, query_external_db_release_id, 
               target_table_id, target_taxon_id, target_external_db_release_id,
               is_consistent, is_genomic_contaminant, unaligned_3p_bases,
               unaligned_5p_bases, has_3p_polya, has_5p_polya, is_3p_complete,
               is_5p_complete, percent_identity, max_query_gap, max_target_gap,
               number_of_spans, query_start, query_end, target_start, target_end,
               is_reversed, query_bases_aligned, repeat_bases_aligned, num_ns, score,
               is_best_alignment, blat_alignment_quality_id, blocksizes, qstarts,
               tstarts, sp.virtual_na_sequence_id, sp.distance_from_left, sp.start_position, sp.end_position,
               sp.strand_orientation, piece.length, vti.table_id as virtual_target_table_id
        from dots.BlatAlignment ba, SequencePieceClosure sp, dots.NaSequence piece,
             dots.NaSequence virtualseq, core.TableInfo vti
        where ba.target_na_sequence_id = sp.piece_na_sequence_id(+)
          and sp.start_position <= target_start
          and sp.end_position >= target_end
          and ba.target_na_sequence_id = piece.na_sequence_id
          and sp.virtual_na_sequence_id = virtualseq.na_sequence_id
          and virtualseq.subclass_view = vti.name
SQL
      
      my $queryHandle = $dbh->prepare($sql) or die $dbh->errstr;
      $queryHandle->execute();

      $sql = <<SQL;
        insert into BlatAlignmentLocation&1(blat_alignment_id,
               query_na_sequence_id, target_na_sequence_id,
               query_table_id, query_taxon_id, query_external_db_release_id, 
               target_table_id, target_taxon_id, target_external_db_release_id,
               is_consistent, is_genomic_contaminant, unaligned_3p_bases,
               unaligned_5p_bases, has_3p_polya, has_5p_polya, is_3p_complete,
               is_5p_complete, percent_identity, max_query_gap, max_target_gap,
               number_of_spans, query_start, query_end, target_start, target_end,
               is_reversed, query_bases_aligned, repeat_bases_aligned, num_ns, score,
               is_best_alignment, blat_alignment_quality_id, blocksizes, qstarts,
               tstarts, location_mapping)
         values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,
                 ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,?)
SQL

      my $insertHandle = $dbh->prepare($sql) or die $dbh->errstr;
      my ($virtual_target_start, $virtual_target_end, $virtual_tstarts);

      while (my ($blat_alignment_id, $query_na_sequence_id, $target_na_sequence_id,
               $query_table_id, $query_taxon_id, $query_external_db_release_id,
               $target_table_id, $target_taxon_id, $target_external_db_release_id,
               $is_consistent, $is_genomic_contaminant, $unaligned_3p_bases,
               $unaligned_5p_bases, $has_3p_polya, $has_5p_polya, $is_3p_complete,
               $is_5p_complete, $percent_identity, $max_query_gap, $max_target_gap,
               $number_of_spans, $query_start, $query_end, $target_start, $target_end,
               $is_reversed, $query_bases_aligned, $repeat_bases_aligned, $num_ns, $score,
               $is_best_alignment, $blat_alignment_quality_id, $blocksizes, $qstarts,
               $tstarts, $virtual_na_sequence_id, $distance_from_left, $start_position, $end_position,
               $strand_orientation, $length, $virtual_target_table_id)
             = $queryHandle->fetchrow_array()) {

        if ($virtual_na_sequence_id) {
          if ($strand_orientation eq '-') {
            $virtual_target_start = $distance_from_left + $end_position - $target_end + 1;
            $virtual_target_end = $distance_from_left + $end_position - $target_start + 1;
            $virtual_tstarts = &getReversedTstarts($distance_from_left,$end_position,$tstarts,$blocksizes);
            $blocksizes = join(',', reverse split(',', $blocksizes));
            $is_reversed = $is_reversed == 1 ? 0 : 1;
          } else {
            $virtual_target_start = $target_start + $distance_from_left - $start_position + 1;
            $virtual_target_end = $target_end + $distance_from_left - $start_position + 1;
            $virtual_tstarts = join( ',', map{ $_ + $distance_from_left - $start_position + 1 } split( /,/, $tstarts));
          }

          # insert virtual locations
          $insertHandle->execute($blat_alignment_id,
                 $query_na_sequence_id, $virtual_na_sequence_id,
                 $query_table_id, $query_taxon_id, $query_external_db_release_id,
                 $virtual_target_table_id, $target_taxon_id, $target_external_db_release_id,
                 $is_consistent, $is_genomic_contaminant, $unaligned_3p_bases,
                 $unaligned_5p_bases, $has_3p_polya, $has_5p_polya, $is_3p_complete,
                 $is_5p_complete, $percent_identity, $max_query_gap, $max_target_gap,
                 $number_of_spans, $query_start, $query_end, $virtual_target_start,
                 $virtual_target_end,
                 $is_reversed, $query_bases_aligned, $repeat_bases_aligned, $num_ns, $score,
                 $is_best_alignment, $blat_alignment_quality_id, $blocksizes, $qstarts,
                 $virtual_tstarts, 'virtual');
        }
      }

      $insertHandle->finish();
      $queryHandle->finish();

sub getReversedTstarts {
  my($dfl,$len,$tstart,$blocksizes) = @_;
  my @ts = split(',',$tstart);
  my @bs = split(',',$blocksizes);
  my @new;
  for(my $a = scalar(@ts) - 1;$a >= 0;$a--){
    push(@new,($dfl + $len - $ts[$a] - $bs[$a] + 2));
  }
  return join(',',@new);
}
      ]]> 
    </perl>
  </tuningTable>


  <tuningTable name="BlatProtAlignLocation">
    <!-- BLAT protein alignments. Used by GBrowse for the track proteinAlignment:BLAT
     -->
    <internalDependency name="SequencePieceClosure"/>
    <externalDependency name="apidb.BlatProteinAlignment"/>
    <externalDependency name="core.TableInfo"/>
    <externalDependency name="dots.NaSequence"/>
    <sql>
      <![CDATA[ 
      CREATE TABLE BlatProtAlignLocation&1 NOLOGGING AS
      SELECT blat_protein_alignment_id, query_aa_sequence_id, target_na_sequence_id,
             query_table_id, query_taxon_id, query_external_db_release_id,
             target_table_id, target_taxon_id, target_external_db_release_id,
             is_consistent, is_genomic_contaminant, unaligned_3p_bases,
             unaligned_5p_bases, has_3p_polya, has_5p_polya, is_3p_complete,
             is_5p_complete, percent_identity, max_query_gap, max_target_gap,
             number_of_spans, query_start, query_end, target_start, target_end,
             is_reversed, query_bases_aligned, repeat_bases_aligned, num_ns, score,
             is_best_alignment, blat_alignment_quality_id, blocksizes, qstarts,
             tstarts, cast('direct' as varchar2(7)) as location_mapping
      FROM apidb.BlatProteinAlignment
      ]]> 
    </sql>
    <perl>
      <![CDATA[ 
      use strict;
      use lib "$ENV{GUS_HOME}/lib/perl";

      my $sql = <<SQL;
        select blat_protein_alignment_id, query_aa_sequence_id, target_na_sequence_id,
               query_table_id, query_taxon_id, query_external_db_release_id, 
               target_table_id, target_taxon_id, target_external_db_release_id,
               is_consistent, is_genomic_contaminant, unaligned_3p_bases,
               unaligned_5p_bases, has_3p_polya, has_5p_polya, is_3p_complete,
               is_5p_complete, percent_identity, max_query_gap, max_target_gap,
               number_of_spans, query_start, query_end, target_start, target_end,
               is_reversed, query_bases_aligned, repeat_bases_aligned, num_ns, score,
               is_best_alignment, blat_alignment_quality_id, blocksizes, qstarts,
               tstarts, sp.virtual_na_sequence_id, sp.distance_from_left, sp.start_position, sp.end_position,
               sp.strand_orientation, piece.length, vti.table_id as virtual_target_table_id
        from apidb.blatproteinalignment ba, SequencePieceClosure sp, dots.NaSequence piece,
             dots.NaSequence virtualseq, core.TableInfo vti
        where ba.target_na_sequence_id = sp.piece_na_sequence_id(+)
          and sp.start_position <= target_start
          and sp.end_position >= target_end
          and ba.target_na_sequence_id = piece.na_sequence_id
          and sp.virtual_na_sequence_id = virtualseq.na_sequence_id
          and virtualseq.subclass_view = vti.name
SQL
      
      my $queryHandle = $dbh->prepare($sql) or die $dbh->errstr;
      $queryHandle->execute();

      $sql = <<SQL;
        insert into BlatProtAlignLocation&1(blat_protein_alignment_id,
               query_aa_sequence_id, target_na_sequence_id,
               query_table_id, query_taxon_id, query_external_db_release_id, 
               target_table_id, target_taxon_id, target_external_db_release_id,
               is_consistent, is_genomic_contaminant, unaligned_3p_bases,
               unaligned_5p_bases, has_3p_polya, has_5p_polya, is_3p_complete,
               is_5p_complete, percent_identity, max_query_gap, max_target_gap,
               number_of_spans, query_start, query_end, target_start, target_end,
               is_reversed, query_bases_aligned, repeat_bases_aligned, num_ns, score,
               is_best_alignment, blat_alignment_quality_id, blocksizes, qstarts,
               tstarts, location_mapping)
         values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,
                 ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,?)
SQL

      my $insertHandle = $dbh->prepare($sql) or die $dbh->errstr;
      my ($virtual_target_start, $virtual_target_end, $virtual_tstarts);

      while (my ($blat_protein_alignment_id, $query_aa_sequence_id, $target_na_sequence_id,
               $query_table_id, $query_taxon_id, $query_external_db_release_id,
               $target_table_id, $target_taxon_id, $target_external_db_release_id,
               $is_consistent, $is_genomic_contaminant, $unaligned_3p_bases,
               $unaligned_5p_bases, $has_3p_polya, $has_5p_polya, $is_3p_complete,
               $is_5p_complete, $percent_identity, $max_query_gap, $max_target_gap,
               $number_of_spans, $query_start, $query_end, $target_start, $target_end,
               $is_reversed, $query_bases_aligned, $repeat_bases_aligned, $num_ns, $score,
               $is_best_alignment, $blat_alignment_quality_id, $blocksizes, $qstarts,
               $tstarts, $virtual_na_sequence_id, $distance_from_left, $start_position, $end_position,
               $strand_orientation, $length, $virtual_target_table_id)
             = $queryHandle->fetchrow_array()) {

        if ($virtual_na_sequence_id) {
          if ($strand_orientation eq '-') {
            $virtual_target_start = $distance_from_left + $end_position - $target_end + 1;
            $virtual_target_end = $distance_from_left + $end_position - $target_start + 1;
            $virtual_tstarts = &getReversedTstarts($distance_from_left,$end_position,$tstarts,$blocksizes);
            $blocksizes = join(',', reverse split(',', $blocksizes));
            $is_reversed = $is_reversed == 1 ? 0 : 1;
          } else {
            $virtual_target_start = $target_start + $distance_from_left - $start_position + 1;
            $virtual_target_end = $target_end + $distance_from_left - $start_position + 1;
            $virtual_tstarts = join( ',', map{ $_ + $distance_from_left - $start_position + 1 } split( /,/, $tstarts));
          }

          # insert virtual locations
          $insertHandle->execute($blat_protein_alignment_id,
                 $query_aa_sequence_id, $virtual_na_sequence_id,
                 $query_table_id, $query_taxon_id, $query_external_db_release_id,
                 $virtual_target_table_id, $target_taxon_id, $target_external_db_release_id,
                 $is_consistent, $is_genomic_contaminant, $unaligned_3p_bases,
                 $unaligned_5p_bases, $has_3p_polya, $has_5p_polya, $is_3p_complete,
                 $is_5p_complete, $percent_identity, $max_query_gap, $max_target_gap,
                 $number_of_spans, $query_start, $query_end, $virtual_target_start,
                 $virtual_target_end,
                 $is_reversed, $query_bases_aligned, $repeat_bases_aligned, $num_ns, $score,
                 $is_best_alignment, $blat_alignment_quality_id, $blocksizes, $qstarts,
                 $virtual_tstarts, 'virtual');
        }
      }

      $insertHandle->finish();
      $queryHandle->finish();

      # create index
      $dbh->do(<<SQL) or die $dbh->errstr;
        create index bpal&1
          on ApidbTuning.BlatProtAlignLocation&1
          (target_na_sequence_id, target_start, target_end, blat_protein_alignment_id,
           score, is_reversed, query_aa_sequence_id, percent_identity)
SQL

sub getReversedTstarts {
  my($dfl,$len,$tstart,$blocksizes) = @_;
  my @ts = split(',',$tstart);
  my @bs = split(',',$blocksizes);
  my @new;
  for(my $a = scalar(@ts) - 1;$a >= 0;$a--){
    push(@new,($dfl + $len - $ts[$a] - $bs[$a] + 2));
  }
  return join(',',@new);
}
      ]]> 
    </perl>
  </tuningTable>


  <tuningTable name="EstAlignmentGeneSummary">
    <!-- Each row represents a colocated EST alignment - gene pair. Used by the
         model, by generateGeneMetrics, and in the creation of the
         OrganismAttributes tuning table
     -->
    <internalDependency name="GenomicSequence"/>
    <internalDependency name="GeneAttributes"/>
    <internalDependency name="BlatAlignmentLocation"/>
    <externalDependency name="dots.AssemblySequence"/>
    <externalDependency name="dots.BlatAlignment"/>
    <externalDependency name="dots.Est"/>
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="sres.SequenceOntology"/>
    <intermediateTable name="EstAlignmentGene"/>
    <intermediateTable name="EstAlignmentNoGene"/>
    <sql>
      <![CDATA[
CREATE TABLE EstAlignmentGene NOLOGGING AS
SELECT ba.blat_alignment_id, ba.query_na_sequence_id, e.accession,
         e.library_id, ba.query_taxon_id, ba.target_na_sequence_id,
         ba.target_taxon_id, ba.percent_identity, ba.is_consistent,
         ba.is_best_alignment, ba.is_reversed, ba.target_start, ba.target_end,
         sequence.source_id AS target_sequence_source_id,
         least(ba.target_end, ga.end_max)
         - greatest(ba.target_start, ga.start_min) + 1
           AS est_gene_overlap_length,
         ba.query_bases_aligned / (query_sequence.length)
         * 100 AS percent_est_bases_aligned,
         ga.source_id AS gene
  FROM BlatAlignmentLocation ba, dots.Est e, dots.AssemblySequence aseq,
       GeneAttributes ga, GenomicSequence sequence,
       dots.NaSequence query_sequence, sres.SequenceOntology so
  WHERE e.na_sequence_id = ba.query_na_sequence_id
    AND aseq.na_sequence_id = ba.query_na_sequence_id
    AND sequence.na_sequence_id = ba.target_na_sequence_id
    AND ga.sequence_id = sequence.source_id
    AND least(ba.target_end, ga.end_max) - greatest(ba.target_start, ga.start_min) >= 0
    AND query_sequence.na_sequence_id = ba.query_na_sequence_id
    AND query_sequence.sequence_ontology_id = so.sequence_ontology_id
    AND so.term_name = 'EST'
    AND ba.target_na_sequence_id = sequence.na_sequence_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE EstAlignmentNoGene NOLOGGING AS
SELECT * from EstAlignmentGene WHERE 1=0 UNION -- define datatype for null column
SELECT ba.blat_alignment_id, ba.query_na_sequence_id, e.accession,
       e.library_id, ba.query_taxon_id, ba.target_na_sequence_id,
       ba.target_taxon_id, ba.percent_identity, ba.is_consistent,
       ba.is_best_alignment, ba.is_reversed, ba.target_start, ba.target_end,
       sequence.source_id AS target_sequence_source_id,
       NULL AS est_gene_overlap_length,
       ba.query_bases_aligned / (query_sequence.length)
       * 100 AS percent_est_bases_aligned,
       NULL AS gene
FROM dots.BlatAlignment ba, dots.Est e, dots.AssemblySequence aseq,
     dots.NaSequence sequence, dots.NaSequence query_sequence
WHERE e.na_sequence_id = ba.query_na_sequence_id
  AND e.na_sequence_id = query_sequence.na_sequence_id
  AND aseq.na_sequence_id = ba.query_na_sequence_id
  AND ba.target_na_sequence_id = sequence.na_sequence_id
  AND ba.blat_alignment_id IN
   ( -- set of blat_alignment_ids not in in first leg of UNION
    -- (because they overlap no genes)
    SELECT ba.blat_alignment_id
    FROM dots.BlatAlignment ba, dots.NaSequence query_sequence,
         sres.SequenceOntology so
    WHERE query_sequence.na_sequence_id = ba.query_na_sequence_id
      AND query_sequence.sequence_ontology_id = so.sequence_ontology_id
      AND so.term_name = 'EST'
  MINUS
    SELECT blat_alignment_id FROM EstAlignmentGene)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE EstAlignmentGeneSummary&1 NOLOGGING AS
SELECT * FROM EstAlignmentNoGene
UNION
SELECT * FROM EstAlignmentGene
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index EstSumm_libOverlap_ix&1
             ON EstAlignmentGeneSummary&1
                (library_id, percent_identity, is_consistent,
                 est_gene_overlap_length, percent_est_bases_aligned)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index EstSumm_estSite_ix&1
             ON EstAlignmentGeneSummary&1
                (target_sequence_source_id, target_start, target_end,
                 library_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="SnpStrains">
    <!-- Each record captures info for an (organism, strain,
         external_database_release_id) 3-tuple. Used in the model, including
         gene and SNP queries, as well as the gene record. Also used by the
         FindPolymorphismsPlugin in the workflow.
     -->
    <internalDependency name="SequenceAttributes"/>
    <externalDependency name="dots.SnpFeature"/>
    <externalDependency name="dots.SeqVariation"/>
    <sql>
      <![CDATA[
CREATE TABLE SnpStrains&1 NOLOGGING AS
  SELECT distinct sv.strain,
                  sa.organism,
                  sf.external_database_release_id,
                  CASE WHEN d.name='pfal3D7_SNP_sanger_PReichenowi_gff_RSRC' THEN 1
                       WHEN d.name='pfal3D7_SNP_Winzeler_Genetic_Variation_Array_gff_RSRC' THEN 0
                       WHEN d.name='pfal3D7_SNP_sanger_ItGhana_gff_RSRC' THEN 0
                       WHEN d.name='pfal3D7_SNP_Broad_gff_RSRC' THEN 0
                       WHEN d.name='pfal3D7_SNP_XSu_gff_RSRC' THEN 0
                       WHEN d.name='InsertSnps.pm NGS SNPs INTERNAL' THEN 0
                       ELSE 1 
                  END as is_queryable,
                  d.name as extdb_name, vd.name as var_extdb_name, sa.taxon_id
  FROM   dots.SnpFeature sf, 
         (select strain, external_database_release_id, max(parent_id) as parent_id
          from dots.SeqVariation
          group by strain, external_database_release_id) sv, 
         SequenceAttributes sa,
         sres.ExternalDatabase d, 
         sres.ExternalDatabaseRelease rel,
         sres.ExternalDatabase vd, 
         sres.ExternalDatabaseRelease vrel
  WHERE sa.na_sequence_id = sf.na_sequence_id
    AND sf.na_feature_id = sv.parent_id
    AND sf.external_database_release_id = rel.external_database_release_id
    AND rel.external_database_id = d.external_database_id
    AND sv.external_database_release_id = vrel.external_database_release_id
    AND vrel.external_database_id = vd.external_database_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX SnpStrains_ix&1 ON SnpStrains&1(extdb_name,external_database_release_id,strain,organism)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="IsolateAttributes">
    <!-- The BFMV for the WDK isolate record. Widely used in the model for
         queries related to isolates (including gene and SNP queries as well as
         isolate queries). Used as input in the creation of half a dozen other
         tuning tables, including GeneIsolateOverlap, IsolateSequence,
         IsolateSNPs, OrganismAttributes, SnpsWithIsolates, and TajimasStats.
         Aggregated into portal instances for use in the portal site.
     -->
    <internalDependency name="SequenceAttributes"/>
    <externalDependency name="apidb.IsolateMapping"/>
    <externalDependency name="apidb.IsolateVocabulary"/>
    <externalDependency name="apidb.VocabularyBiomaterial"/>
    <externalDependency name="core.ProjectInfo"/>
    <externalDependency name="dots.ExternalNaSequence"/>
    <externalDependency name="dots.isolatefeature"/>
    <externalDependency name="dots.IsolateSource"/>
    <externalDependency name="rad.StudyBiomaterial"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.TaxonName"/>
    <externalDependency name="study.BiomaterialCharacteristic"/>
    <externalDependency name="study.Biosource"/>
    <externalDependency name="study.OntologyEntry"/>
    <externalDependency name="study.Study"/>
    <sql>
      <![CDATA[
CREATE TABLE IsolateAttributes&1 NOLOGGING AS
select null as na_sequence_id,
       null as na_feature_id,
       b.bio_material_id,
       o.taxon_id,
       edr.version as external_db_version,
       ed.name as external_db_name,
       b.source_id,
       nvl(o.name, 'Unknown') as organism,
       nvl(strain.value, 'Unknown') as strain,
       nvl(host.value, 'Unknown') as specific_host,
       nvl(isolation_source.value, 'Unknown') as isolation_source,
       nvl(geographic_location.value, 'Unknown') as geographic_location,
      'N/A' as product,
       null as note,
       b.description,
       null as is_reference,
       project.project_id,
       'HTS' as data_type,
       host.annotated_value as annotated_specific_host,
       isolation_source.annotated_value as annotated_isolation_source,
       geographic_location.annotated_value as annotated_geographic_location,
       null as length, 
       null as pcr_primers, 
       null as collected_by
 From study.Biosource b, study.Study s, 
     rad.StudyBiomaterial sb, sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr,
     (select bc.bio_material_id, tn.name, tn.taxon_id
      from study.OntologyEntry oe, sres.TaxonName tn, study.BiomaterialCharacteristic bc
      where category = 'Organism'
      and oe.value = tn.name
      and bc.ontology_entry_id = oe.ontology_entry_id
      ) o,
     (select bc.bio_material_id, oe.value
      from study.OntologyEntry oe, study.BiomaterialCharacteristic bc
      where category = 'StrainOrLine'
      and bc.ontology_entry_id = oe.ontology_entry_id
      ) strain,
     (select bc.bio_material_id, oe.value, iv.term as annotated_value
      from study.OntologyEntry oe, study.BiomaterialCharacteristic bc,
           apidb.VocabularyBiomaterial vb, apidb.IsolateVocabulary iv
      where category = 'Host'
      and bc.ontology_entry_id = oe.ontology_entry_id
      and bc.bio_material_id = vb.bio_material_id
      and vb.isolate_vocabulary_id = iv.isolate_vocabulary_id
      and iv.type = 'specific_host'
      ) host,
     (select bc.bio_material_id, oe.value, iv.term as annotated_value
      from study.OntologyEntry oe, study.BiomaterialCharacteristic bc,
           apidb.VocabularyBiomaterial vb, apidb.IsolateVocabulary iv
      where category = 'BioSourceType'
      and bc.ontology_entry_id = oe.ontology_entry_id
      and bc.bio_material_id = vb.bio_material_id
      and vb.isolate_vocabulary_id = iv.isolate_vocabulary_id
      and iv.type = 'isolation_source'
      ) isolation_source,
     (select bc.bio_material_id, oe.value, iv.term as annotated_value
      from study.OntologyEntry oe, study.BiomaterialCharacteristic bc,
           apidb.VocabularyBiomaterial vb, apidb.IsolateVocabulary iv
      where category = 'GeographicLocation'
      and bc.ontology_entry_id = oe.ontology_entry_id
      and bc.bio_material_id = vb.bio_material_id
      and vb.isolate_vocabulary_id = iv.isolate_vocabulary_id
      and iv.type = 'geographic_location'
      ) geographic_location,
     (select distinct project_id from sequenceattributes) project
where lower(s.name) like '%_hts%'
and s.study_id = sb.study_id
and sb.bio_material_id = b.bio_material_id
and b.external_database_release_id = edr.external_database_release_id
and edr.external_database_id = ed.external_database_id
and b.bio_material_id = o.bio_material_id (+)
and b.bio_material_id = strain.bio_material_id (+)
and b.bio_material_id = host.bio_material_id (+)
and b.bio_material_id = isolation_source.bio_material_id (+)
and b.bio_material_id = geographic_location.bio_material_id (+)
UNION
select i.na_sequence_id,
       i.na_feature_id,
       null as bio_material_id,
       i.taxon_id,
       i.external_db_version,
       i.external_db_name,
       i.source_id,
       decode(i.organism, null, 'Unknown', substr(i.organism, 1, 100)) as organism,
       decode(i.strain, null, 'Unknown', substr(i.strain, 1, 100)) as strain,
       decode(i.specific_host, null, 'Unknown', substr(i.specific_host, 1, 100)) as specific_host,
       decode(i.isolation_source, null, 'Unknown', substr(i.isolation_source, 1, 200)) as isolation_source,
       decode(i.country, null, 'Unknown', substr(i.country, 1, 200)) as geographic_location,
       nvl(nvl(prod.product, prod.gene), 'Unknown') as product,
       substr(i.note, 1, 400) as note,
       substr(i.description, 1, 400) as description,
       i.is_reference,
       i.project_id,
       i.data_type,
       s_h.annotated_specific_host,
       i_s.annotated_isolation_source,
       g_l.annotated_geographic_location,
       i.length, 
       i.pcr_primers, 
       i.collected_by
FROM (
       SELECT  etn.na_sequence_id,
               etn.taxon_id,
               etn.length,
               edr.version as external_db_version, 
               src.na_feature_id,
               edb.name as external_db_name,
               CASE 
                 WHEN etn.source_id is null 
                   THEN decode(edb.name, 'Broad 75K genotyping chip', 'CPHD.'||strain, 
                                         'pfal3D7_SNP_Broad75KGenotyping_RSRC', 'CPHD.'||strain,
                                         'Broad 3K genotyping chip', 'CP3.'||strain,
                                         'pfal3D7_SNP_Broad3KGenotyping_RSRC', 'CP3.'||strain,
                                         'pfal3D7_SNP_BroadIsolateBarcode_RSRC','BC.'||strain,
                                         'Isolate barcode data from Broad','BC.'||strain)
                ELSE etn.source_id 
              END as source_id,
              tn.name as organism,
              CASE 
                WHEN src.strain != src.isolate 
                  THEN src.strain || ' ' || src.isolate 
                WHEN src.strain is  not null 
                  THEN src.strain
                ELSE src.isolate 
              END as strain,
              src.specific_host as specific_host,
              src.isolation_source as isolation_source,
              src.country as country,
              src.note as note,
              etn.description as description,
              src.pcr_primers,
              src.collected_by,
              src.is_reference,
              decode(edb.name, 'Broad 75K genotyping chip', 'HD_Array', 
                               'pfal3D7_SNP_Broad75KGenotyping_RSRC', 'HD_Array',
                               'Broad 3K genotyping chip', '3kChip',
                               'pfal3D7_SNP_Broad3KGenotyping_RSRC', '3kChip',
                               'tgonME49_isolates_ChunleiSu_RFLP_RSRC', 'RFLP Typed',
                               'pfal3D7_SNP_BroadIsolateBarcode_RSRC','Barcode',
                               'Isolate barcode data from Broad','Barcode','Sequencing Typed') as data_type,
        CASE WHEN lower(pinfo.name) like 'plas%' THEN 'PlasmoDB' 
             WHEN lower(pinfo.name) like 'cryp%' THEN 'CryptoDB'
             WHEN lower(pinfo.name) like 'toxo%' THEN 'ToxoDB'
             WHEN lower(pinfo.name) like 'giard%' THEN 'GiardiaDB'
             WHEN lower(pinfo.name) like 'tritryp%' THEN 'TriTrypDB'
             WHEN lower(pinfo.name) like 'micro%' THEN 'MicrosporidiaDB'
             WHEN lower(pinfo.name) like 'piro%' THEN 'PiroplasmaDB'
             WHEN lower(pinfo.name) like 'amoeb%' THEN 'AmoebaDB'
        ELSE '' END as project_id
      FROM dots.ExternalNaSequence etn, dots.IsolateSource src,
           sres.ExternalDatabaseRelease edr, sres.ExternalDatabase edb, core.ProjectInfo pinfo, 
           (select  distinct taxon_id,name from sres.TaxonName where name_class = 'scientific name') tn
      WHERE etn.na_sequence_id = src.na_sequence_id
       AND  etn.taxon_id = tn.taxon_id(+)
       AND edr.external_database_id = edb.external_database_id
       AND edr.external_database_release_id = etn.external_database_release_id
       AND pinfo.project_id = etn.row_project_id
      ) i,
      (select im.na_sequence_id, apidb.tab_to_string(set(cast(COLLECT(iv.term) as apidb.varchartab)),',') as annotated_isolation_source
      from apidb.IsolateVocabulary iv, apidb.IsolateMapping im
      where iv.isolate_vocabulary_id = im.isolate_vocabulary_id
      and iv.type = 'isolation_source'
      group by im.na_sequence_id
      ) i_s,
      (select im.na_sequence_id, apidb.tab_to_string(set(cast(COLLECT(iv.term) as apidb.varchartab)),',') as annotated_specific_host
      from apidb.IsolateVocabulary iv, apidb.IsolateMapping im
      where iv.isolate_vocabulary_id = im.isolate_vocabulary_id
      and iv.type = 'specific_host'
      group by im.na_sequence_id
      ) s_h,
      (select im.na_sequence_id, apidb.tab_to_string(set(cast(COLLECT(iv.term) as apidb.varchartab)),',') as annotated_geographic_location
      from apidb.IsolateVocabulary iv, apidb.IsolateMapping im
      where iv.isolate_vocabulary_id = im.isolate_vocabulary_id
      and iv.type = 'geographic_location'
      group by im.na_sequence_id
      ) g_l,
      (select na_sequence_id,
              apidb.tab_to_string(set(cast(COLLECT(product order by product) as apidb.varchartab)),'; ') as product,
              apidb.tab_to_string(set(cast(COLLECT(gene order by gene) as apidb.varchartab)),'; ') as gene
       from dots.IsolateFeature group by na_sequence_id
      ) prod
WHERE i.na_sequence_id = i_s.na_sequence_id
and i.na_sequence_id = s_h.na_sequence_id
and i.na_sequence_id = g_l.na_sequence_id
and i.na_sequence_id = prod.na_sequence_id (+)
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index IsolateAttr_sourceId_idx&1 ON IsolateAttributes&1 (source_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="ChIPProtocolParams">
    <!-- Used by the GenesByChipChip(Plasmo|Toxo) query, as well as by GBrowse.
     -->
    <externalDependency name="rad.Analysis"/>
    <externalDependency name="rad.AnalysisParam"/>
    <externalDependency name="rad.ProtocolParam"/>
    <sql>
      <![CDATA[
        create table ChIPProtocolParams&1 NOLOGGING AS
select pp.*, e.experiment_name from
(
select a.analysis_id,
       a.protocol_id,
       antbd.antibody as antibody,
       strn.strain as strain,
       treamnt.treatment as treatment,
       replcte.replicate as replicate,
       gentyp.genotype as genotype,
       celltyp.celltype as celltype,
       CASE
          WHEN lower(p.name) like '%peak%' then 'called_peaks'
       ELSE 'raw'
       END as protocol_type
from   rad.analysis a,rad.protocol p,
      (select ap.analysis_id,ap.value as antibody
       from   rad.analysisparam ap,rad.protocolparam pp
       where  ap.protocol_param_id = pp.protocol_param_id
       and    lower(name) like 'antibody') antbd,
      (select ap.analysis_id,ap.value as strain
       from   rad.analysisparam ap,rad.protocolparam pp
       where  ap.protocol_param_id = pp.protocol_param_id
       and    lower(name) like 'strain') strn,
      (select ap.analysis_id,ap.value as treatment
       from   rad.analysisparam ap,rad.protocolparam pp
       where  ap.protocol_param_id = pp.protocol_param_id
       and    lower(name) like 'treatment') treamnt,
      (select ap.analysis_id,ap.value as replicate
       from   rad.analysisparam ap,rad.protocolparam pp
       where  ap.protocol_param_id = pp.protocol_param_id
       and    lower(name) like 'replicate') replcte,
      (select ap.analysis_id,ap.value as genotype
       from   rad.analysisparam ap,rad.protocolparam pp
       where  ap.protocol_param_id = pp.protocol_param_id
       and    lower(name) like 'genotype') gentyp,
      (select ap.analysis_id,ap.value as celltype
       from   rad.analysisparam ap,rad.protocolparam pp
       where  ap.protocol_param_id = pp.protocol_param_id
       and    lower(name) like 'celltype') celltyp
where a.protocol_id = p.protocol_id
and p.name in ('ChIP chip Smoothed',
               'ChIP chip Peak Calls',
                -- legacy ones too
                'NimbleScan_ChIP_Hakimi_called_peaks',
                'NimbleScan_ChIP_Hakimi',
                'NimbleGen_ChIP_Myler_Lmajor',
                'ChIP_chip_Einstein',
                'ChIP_chip_Einstein_called_peaks',
                'ChIP_chip_Einstein_ME1',
                'ChIP_chip_Einstein_ME1_Peak_Calls')
and   a.analysis_id = antbd.analysis_id (+)
and   a.analysis_id = strn.analysis_id (+)
and   a.analysis_id = treamnt.analysis_id (+)
and   a.analysis_id = replcte.analysis_id (+)
and   a.analysis_id = gentyp.analysis_id (+)
and   a.analysis_id = celltyp.analysis_id (+)
) pp, (
select replace(d.name, '_' || a.name || '_chipChipSample_RSRC', '') as experiment_name, a.analysis_id
from sres.ExternalDatabase d, rad.analysis a
where d.name like '%' || a.name ||'%_chipChipSample_RSRC') e
where pp.analysis_id = e.analysis_id (+)
      ]]>
    </sql>
    <sql>
      <![CDATA[
       create index chp_prtparam_idx&1 ON ChIPProtocolParams&1 (analysis_id,protocol_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="ChIPchipGene">
    <!-- Used by the GenesByChipChip(Plasmo|Toxo) query, as well as by
         generateGeneMetrics. Also an input to OrganismAttributes.
     -->
    <internalDependency name="FeatureLocation"/>
    <internalDependency name="GeneAttributes"/>
    <internalDependency name="SequenceAttributes"/>
    <internalDependency name="ExpressionElement"/>
    <sql>
      <![CDATA[
        create table ChIPchipGene&1 NOLOGGING AS
select distinct
      ga.source_id as gene_source_id,
      aef.feature_source_id as probe_id,
      aef.na_feature_id as chip_na_feature_id,
      CASE 
        WHEN ga.is_reversed = 0 
        THEN round(abs(ga.start_min - (((arrloc.end_max - arrloc.start_min) / 2) + arrloc.start_min)),0)
        ELSE round(abs(ga.end_max - (((arrloc.end_max - arrloc.start_min) / 2) + arrloc.start_min)),0) 
      END as distance,
      CASE 
        WHEN -- distance > 0
          CASE WHEN ga.is_reversed = 0 
            THEN ga.start_min - (((arrloc.end_max - arrloc.start_min) / 2) + arrloc.start_min)
            ELSE ga.end_max - (((arrloc.end_max - arrloc.start_min) / 2) + arrloc.start_min)
          END > 0 
        THEN 
          CASE 
            WHEN ga.is_reversed = 0 
            THEN '-' 
            ELSE '+'
          END 
        ELSE 
          CASE 
            WHEN ga.is_reversed = 1 
            THEN '-' 
            ELSE '+'
          END 
        END as direction
from  ExpressionElement aef,
      FeatureLocation arrloc,
      GeneAttributes ga,
      rad.analysis a,
      rad.protocol p
where aef.na_feature_id = arrloc.na_feature_id
and   aef.analysis_id = a.analysis_id
and   a.protocol_id = p.protocol_id
and   p.name in ('ChIP chip Peak Calls','ChIP_chip_Einstein_called_peaks','NimbleScan_ChIP_Hakimi_called_peaks')
and   arrloc.na_sequence_id = ga.na_sequence_id
and   ( (ga.is_reversed = 0 and abs((((arrloc.end_max - arrloc.start_min) / 2) + arrloc.start_min) - ga.start_min) <= 3000)
                  or (ga.is_reversed = 1 and abs((((arrloc.end_max - arrloc.start_min) / 2) + arrloc.start_min) - ga.end_max) <= 3000) )
     ]]>
    </sql>
    <sql>
      <![CDATA[
       create index chpgene_geneid_idx&1 ON ChIPchipGene&1 (gene_source_id, chip_na_feature_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="TFBSGene">
    <!-- Used by gene queries, as well as by generateGeneMetrics. Also an input
         to OrganismAttributes.
     -->
    <internalDependency name="FeatureLocation"/>
    <internalDependency name="GeneAttributes"/>
    <internalDependency name="SequenceAttributes"/>
    <sql>
      <![CDATA[
        create table TFBSGene&1 NOLOGGING AS
select distinct
      ga.source_id as gene_source_id,
      ga.organism as organism,
      ga.species as species,
      aef.source_id as probe_id,
      aef.na_feature_id as tfbs_na_feature_id,
      CASE 
        WHEN ga.is_reversed = 0 
        THEN round(abs(ga.start_min - (((arrloc.end_max - arrloc.start_min) / 2) + arrloc.start_min)),0)
        ELSE round(abs(ga.end_max - (((arrloc.end_max - arrloc.start_min) / 2) + arrloc.start_min)),0) 
      END as distance,
      CASE 
        WHEN -- distance > 0
          CASE WHEN ga.is_reversed = 0 
            THEN ga.start_min - (((arrloc.end_max - arrloc.start_min) / 2) + arrloc.start_min)
            ELSE ga.end_max - (((arrloc.end_max - arrloc.start_min) / 2) + arrloc.start_min)
          END > 0 
        THEN 
          CASE 
            WHEN ga.is_reversed = 0 
            THEN '-' 
            ELSE '+'
          END 
        ELSE 
          CASE 
            WHEN ga.is_reversed = 1 
            THEN '-' 
            ELSE '+'
          END 
        END as direction
from  dots.BindingSiteFeature aef,
      FeatureLocation arrloc,
      GeneAttributes ga
where aef.na_feature_id = arrloc.na_feature_id
and   arrloc.na_sequence_id = ga.na_sequence_id
and   ( (ga.is_reversed = 0 and abs((((arrloc.end_max - arrloc.start_min) / 2) + arrloc.start_min) - ga.start_min) <= 3000)
                  or (ga.is_reversed = 1 and abs((((arrloc.end_max - arrloc.start_min) / 2) + arrloc.start_min) - ga.end_max) <= 3000) )
     ]]>
    </sql>
    <sql>
      <![CDATA[
       create index tfbs_geneid_idx&1 ON TFBSGene&1 (gene_source_id, tfbs_na_feature_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="SageTagAttributes">
    <!-- The BFMV for the SAGE tag WDK record. Widely used in the model, as
         well as by GBrowse. Propagated to portal instances for use there.
     -->
    <internalDependency name="FeatureLocation"/>
    <internalDependency name="SageTagAnalysisAttributes"/>
    <internalDependency name="SageTagGene"/>
    <internalDependency name="GeneAttributes"/>
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="dots.SageTagFeature"/>
    <externalDependency name="rad.SageTag"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE SageTagAttributes&1 NOLOGGING AS
SELECT cast(apidb.project_id(tn.name) as varchar2(20)) as project_id,
       substr(s.source_id || '-' || l.start_min || '-' || l.end_max || '.'
              || l.is_reversed, 1, 40) as source_id,
       f.na_feature_id, f.source_id as feature_source_id,
       substr(s.source_id, 1, 40) as sequence_source_id, s.na_sequence_id,
       l.start_min, l.end_max, substr(st.tag, 1, 20) as sequence,
       st.composite_element_id, st.source_id as rad_source_id,
       l.is_reversed,
       SUBSTR(CASE
                WHEN tn.name = 'Giardia lamblia' THEN 'Giardia Assemblage A isolate WB' 
                ELSE tn.name
              END, 1, 60) AS organism,
       gene.gene_source_id, nvl(gene.gene_count, 0) gene_count,
       gene.gene_product
from dots.SageTagFeature f, FeatureLocation l, dots.NaSequence s,
     sres.TaxonName tn, rad.SageTag st, 
     (select a.na_feature_id,
             apidb.tab_to_string(set(cast(COLLECT(b.gene_source_id order by b.gene_source_id) as apidb.varchartab)),'; ') as gene_source_id,
             apidb.tab_to_string(set(cast(COLLECT(ga.product order by ga.product) as apidb.varchartab)),'; ') as gene_product,
             count(b.gene_source_id) as gene_count
      from dots.sagetagfeature a, (
                             select distinct a.na_feature_id,
                                            sg.gene_source_id as gene_source_id
                             from dots.SageTagFeature a left join SageTagGene sg on a.na_feature_id = sg.tag_feature_id
                             where (sg.distance = 0 or sg.distance is null)
                             and (sg.antisense = 0 or sg.antisense is null)
                             ) b, GeneAttributes ga
       where a.na_feature_id = b.na_feature_id
        and b.gene_source_id = ga.source_id
       group by a.na_feature_id
      ) gene
where f.na_feature_id = gene.na_feature_id (+)
  and f.na_feature_id = l.na_feature_id
  and l.is_top_level = 1
  and s.na_sequence_id = l.na_sequence_id
  and s.taxon_id = tn.taxon_id
  and tn.name_class = 'scientific name'
  and f.source_id = st.composite_element_id
  and st.composite_element_id in (select composite_element_id from SageTagAnalysisAttributes)
      ]]>
    </sql>
    <sql>
      <![CDATA[
create unique index SageTagAttr_sourceId_idx&1 ON SageTagAttributes&1
             (source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index SageTagAttr_loc_idx&1 ON SageTagAttributes&1
             (na_sequence_id, start_min, end_max, is_reversed, source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create unique index SageTagAttr_ftrId_idx&1 ON SageTagAttributes&1
             (na_feature_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="AsmAlignmentGeneSummary">
    <!-- Each record represents a 2-tuple of a gene and a colocated assembly
         alignment. Used in assembly ID queries and in the assembly record.
     -->
    <internalDependency name="GeneAttributes"/>
    <internalDependency name="GenomicSequence"/>
    <internalDependency name="BlatAlignmentLocation"/>
    <externalDependency name="dots.Assembly"/>
    <externalDependency name="dots.BlatAlignment"/>
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="sres.SequenceOntology"/>
    <intermediateTable name="AsmAlignmentGene"/>
    <intermediateTable name="AsmAlignmentNoGene"/>
    <sql>
      <![CDATA[
CREATE TABLE AsmAlignmentGene NOLOGGING AS
SELECT ba.blat_alignment_id, ba.query_na_sequence_id, a.source_id, a.number_of_contained_sequences AS est_count, a.length,
         ba.query_taxon_id, ba.target_na_sequence_id,
         ba.target_taxon_id, ba.percent_identity, ba.is_consistent,
         ba.is_best_alignment, ba.is_reversed, ba.target_start, ba.target_end,
         sequence.source_id AS target_sequence_source_id,
         least(ba.target_end, ga.end_max)
         - greatest(ba.target_start, ga.start_min) + 1
           AS assembly_gene_overlap_length,
         ba.query_bases_aligned / (a.length)
         * 100 AS percent_assembly_bases_aligned,
         ga.source_id AS gene
  FROM dots.Assembly a, 
       BlatAlignmentLocation ba,
       GeneAttributes ga, 
       GenomicSequence sequence
  WHERE ba.query_na_sequence_id = a.na_sequence_id 
   AND ba.target_na_sequence_id = sequence.na_sequence_id
   AND ga.sequence_id = sequence.source_id
   AND least(ba.target_end, ga.end_max) - greatest(ba.target_start, ga.start_min) >= 0
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE AsmAlignmentNoGene NOLOGGING AS
SELECT * from AsmAlignmentGene WHERE 1=0 UNION -- define datatype for null column
SELECT ba.blat_alignment_id, ba.query_na_sequence_id, a.source_id, a.number_of_contained_sequences AS est_count, a.length,
         ba.query_taxon_id, ba.target_na_sequence_id,
         ba.target_taxon_id, ba.percent_identity, ba.is_consistent,
         ba.is_best_alignment, ba.is_reversed, ba.target_start, ba.target_end,
         sequence.source_id AS target_sequence_source_id,
         NULL
           AS assembly_gene_overlap_length,
         ba.query_bases_aligned / (a.length)
         * 100 AS percent_assembly_bases_aligned,
         NULL AS gene
  FROM dots.BlatAlignment ba, dots.Assembly a,
      dots.NaSequence sequence
  WHERE a.na_sequence_id = ba.query_na_sequence_id
    AND sequence.na_sequence_id = ba.target_na_sequence_id
    AND ba.blat_alignment_id IN
   ( -- set of blat_alignment_ids not in in first leg of UNION
    -- (because they overlap no genes)
    SELECT ba.blat_alignment_id
    FROM dots.BlatAlignment ba, dots.NaSequence query_sequence,
         sres.SequenceOntology so
    WHERE query_sequence.na_sequence_id = ba.query_na_sequence_id
      AND query_sequence.sequence_ontology_id = so.sequence_ontology_id
      AND so.term_name = 'assembly'
  MINUS
    SELECT blat_alignment_id FROM AsmAlignmentGene)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE AsmAlignmentGeneSummary&1 NOLOGGING AS
SELECT * FROM AsmAlignmentNoGene
UNION
SELECT * FROM AsmAlignmentGene
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="Subcellular">
    <!-- Each record maps a gene onto a subcellular location. Used by
         GenesBySubcellularLocalization.
     -->
    <internalDependency name="GeneId"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="dots.PredictedAaFeature"/>
    <sql>
      <![CDATA[
CREATE TABLE Subcellular&1 NOLOGGING AS
select distinct gi.gene as source_id, targetting_domain
from (
select paf.source_id, 'ht' as targetting_domain
from sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr, dots.PredictedAaFeature paf
where ed.name in ('subcellular motif from Haldar','pfal3D7_cellularLocation_Haldar_RSRC')
  and ed.external_database_id = edr.external_database_id
  and edr.external_database_release_id = paf.external_database_release_id
union
select paf.source_id, 'pexel' as targetting_domain
from sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr, dots.PredictedAaFeature paf
where ed.name in ('subcellular motif from Cowman','pfal3D7_cellularLocation_Cowman_RSRC')
  and ed.external_database_id = edr.external_database_id
  and edr.external_database_release_id = paf.external_database_release_id
union
select paf.source_id, 'apicoplast' as targetting_domain
from sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr, dots.PredictedAaFeature paf
where ed.name in ('apicoplast targeting data from 4.4','pfal3D7_cellularLocation_ApicoplastTargeting_RSRC')
  and ed.external_database_id = edr.external_database_id
  and edr.external_database_release_id = paf.external_database_release_id
) sc, GeneId gi
where gi.id = sc.source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index subc_ix&1 ON Subcellular&1(source_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="TajimasStats">
    <!-- Each record stores values for the Tajima's D statistic associated with
         a particular N value. Used by GenesByTajimasDHtsSnps.
     -->
    <internalDependency name="IsolateAttributes"/>
    <sql>
      <![CDATA[ 
create table TajimasStats&1 (
   n  number(5),
   a1 number(10,6),
   a2 number(10,6),
   b1 number(10,6),
   b2 number(10,6),
   c1 number(10,6),
   c2 number(10,6), 
   e1 number(10,6),
   e2 number(10,6)
 )
      ]]> 
    </sql>
    <perl>
      <![CDATA[ 
      use strict;
      use lib "$ENV{GUS_HOME}/lib/perl";

      my $sql = "select count(*) as hts_isolates from apidbtuning.isolateattributes where data_type = 'HTS'";

      
      my $queryHandle = $dbh->prepare($sql) or die $dbh->errstr;
      $queryHandle->execute();

      my ($hts_isolates_count) = $queryHandle->fetchrow_array();
      $queryHandle->finish();

      my $insert_sql = <<SQL;
        insert into TajimasStats&1(n, a1, a2, b1, b2, c1, c2, e1, e2)
         values (?, ?, ?, ?, ?, ?, ?, ?, ?)
SQL

      my $insertHandle = $dbh->prepare($insert_sql) or die $dbh->errstr;

      foreach my $n (3..$hts_isolates_count) {
  
        my $a1 = &sum(map { 1/$_ } 1..$n-1);
        my $a2 = &sum(map { 1 / $_**2 } 1..$n-1);
        my $b1 =($n + 1) / (3 * ($n - 1));
        my $b2 = (2 * ($n**2 + $n + 3)) / (9 * $n * ($n - 1));
        my $c1 = $b1 - (1 / $a1);
        my $c2 = $b2 - (($n + 2) / ($a1 * $n)) + $a2 / $a1**2;
        my $e1 = $c1 / $a1;
        my $e2 = $c2 / ($a1**2 + $a2);

       $insertHandle->execute($n, 
                              sprintf("%.6f", $a1),
                              sprintf("%.6f", $a2),
                              sprintf("%.6f", $b1),
                              sprintf("%.6f", $b2),
                              sprintf("%.6f", $c1),
                              sprintf("%.6f", $c2),
                              sprintf("%.6f", $e1),
                              sprintf("%.6f", $e2)
                             );
      }

      $insertHandle->finish();
      1;
      sub sum {
         my $rv = 0;
         foreach ( @_ ) {
           $rv += $_;
         }
         $rv
     }
      ]]> 
    </perl>
  </tuningTable>


  <tuningTable name="SimilaritySpanLocation">
    <!-- Like dots.SimilaritySpan, except that for sequences that are mapped by
         SequencePiece into parts of other sequences, both locations are stored.
         Used by GBrowse, and also in the creation of the Blastx tuning table.
     -->
    <externalDependency name="dots.Similarity"/>
    <externalDependency name="dots.SimilaritySpan"/>
    <externalDependency name="core.TableInfo"/>
    <externalDependency name="dots.NaSequence"/>
    <internalDependency name="SequencePieceClosure"/>
    <sql>
      <![CDATA[
create table SimilaritySpanLocation&1 NOLOGGING as
select sim.similarity_id, sim.query_id, sim.subject_id, sim.query_table_id,
       sim.subject_table_id, sim.score as similarity_score, sim.min_query_start,
       sim.max_query_end, sim.is_reversed as similarity_is_reversed,
       sim.pvalue_mant, sim.pvalue_exp,
       round(100 * sim.number_identical / sim.total_match_length,1) as percent_identical,
       round(100 * sim.number_positive / sim.total_match_length,1) as percent_positive,
       sim.min_subject_start, sim.max_subject_end, sim.total_match_length,
       simp.similarity_span_id, simp.score as span_score, simp.query_start, simp.query_end,
       simp.subject_start, simp.subject_end,
       simp.is_reversed as span_is_reversed,
       'direct' as location_mapping
from dots.similarity sim, dots.similarityspan simp, core.TableInfo ti
where sim.similarity_id = simp.similarity_id
  and sim.query_table_id = ti.table_id
  and ti.name = 'ExternalNASequence'
union
select sim.similarity_id, scaffold.na_sequence_id as query_id, sim.subject_id,
       sim.query_table_id,
       sim.subject_table_id, sim.score as similarity_score,
       case
         when sp.strand_orientation in ('-', '-1')
           then sp.distance_from_left + sp.end_position - greatest(sim.min_query_start, sim.max_query_end) + 1
           else sp.distance_from_left + least(sim.min_query_start, sim.max_query_end) - sp.start_position + 1
       end as min_query_start,
       case
         when sp.strand_orientation in ('-', '-1')
           then sp.distance_from_left + sp.end_position - least(sim.min_query_start, sim.max_query_end) + 1
           else sp.distance_from_left + greatest(sim.min_query_start, sim.max_query_end) - sp.start_position + 1
       end as max_query_end,
       sim.is_reversed, sim.pvalue_mant, sim.pvalue_exp,
       round(100 * sim.number_identical / sim.total_match_length,1) as percent_identical,
       round(100 * sim.number_positive / sim.total_match_length,1) as percent_positive,
       sim.min_subject_start, sim.max_subject_end, sim.total_match_length, 
       simp.similarity_span_id, simp.score as span_score,
       case
         when sp.strand_orientation in ('-', '-1')
           then sp.distance_from_left + sp.end_position - greatest(simp.query_start, simp.query_end) + 1
           else sp.distance_from_left + least(simp.query_start, simp.query_end) - sp.start_position + 1
       end as query_start,
       case
         when sp.strand_orientation in ('-', '-1')
           then sp.distance_from_left + sp.end_position - least(simp.query_start, simp.query_end) + 1
           else sp.distance_from_left + greatest(simp.query_start, simp.query_end) - sp.start_position + 1
       end as query_end,
       simp.subject_start, simp.subject_end,
       simp.is_reversed as span_is_reversed,
       'virtual' as location_mapping
from dots.similarity sim, dots.similarityspan simp, core.TableInfo ti,
     dots.NaSequence contig, &prefixSequencePieceClosure sp, dots.NaSequence scaffold
where sim.similarity_id = simp.similarity_id
  and sim.query_table_id = ti.table_id
  and ti.name = 'ExternalNASequence'
  and sim.query_id = sp.piece_na_sequence_id
  and sp.start_position <= sim.min_query_start
  and sp.end_position >= sim.max_query_end
  and sim.query_id = contig.na_sequence_id
  and sp.virtual_na_sequence_id = scaffold.na_sequence_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
update SimilaritySpanLocation&1
set pvalue_exp = (select min(pvalue_exp) from SimilaritySpanLocation&1)
where pvalue_mant = 0
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index spanloc_query_ix&1
        on SimilaritySpanLocation&1 (query_id, min_query_start, max_query_end, query_table_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="IsolateSNPs">
    <!-- Associates SNPs with isolates. Used for the SNP record and for SNP ID
         queries, as well as for the creation of the SnpsWithIsolates tuning table.
     -->
    <internalDependency name="FeatureLocation"/>
    <internalDependency name="IsolateAttributes"/>
    <internalDependency name="SnpAttributes"/>
    <externalDependency name="dots.IsolateFeature"/>
    <sql>
      <![CDATA[
create table IsolateSNPs&1 NOLOGGING as
select atr.na_sequence_id as is_na_sequence_id,
       atr.source_id as is_source_id,
       isof.allele,
       sa.source_id as snp_source_id,
       sa.dataset as snp_db_name,
       sa.na_sequence_id as snp_na_sequence_id,
       sa.start_min as snp_start_min
from dots.IsolateFeature isof,  FeatureLocation isol, 
     SnpAttributes sa, IsolateAttributes atr
where atr.na_feature_id = isof.parent_id
and isof.na_feature_id = isol.na_feature_id
and sa.na_sequence_id = isol.na_sequence_id
and sa.start_min = isol.start_min
and sa.dataset in ('pfal3D7_SNP_combined_Su_Broad_Sanger_gff_RSRC','PlasmoDB combined SNPs','Broad SNPs','pfal3D7_SNP_Broad_gff_RSRC')
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index IsolateSNPs_is_sid_idx&1 on IsolateSNPs&1 (is_source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index IsolateSNPs_snp_db_id_idx&1 on IsolateSNPs&1 (snp_db_name,snp_source_id,allele)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index IsolateSNPs_snp_id_idx&1 on IsolateSNPs&1 (snp_source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index isnps_snp_sq_strt_idx&1 on IsolateSNPs&1 (snp_na_sequence_id,snp_start_min)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="SnpsWithIsolates">
    <!-- Each record summarizes statistics for a single SNP location within a
         single isolate external database release. Used by GBrowse.
     -->
    <internalDependency name="IsolateAttributes"/>
    <internalDependency name="IsolateSNPs"/>
    <sql>
      <![CDATA[
create table SnpsWithIsolates&1 NOLOGGING as
select iso_ext_db_name,snp_source_id, 
 apidb.tab_to_string(set(cast(COLLECT(CASE WHEN frequency < 0.5 THEN allele END order by allele) as apidb.varchartab)), ', ') as minor_allele,
 apidb.tab_to_string(set(cast(COLLECT(CASE WHEN frequency > 0.5 THEN allele END order by allele) as apidb.varchartab)), ', ') as major_allele,
 to_char(min(frequency), '0.99') as minor_allele_frequency,
 min(number_isolates) as number_isolates
from (
 select s.snp_source_id as snp_source_id, s.external_db_name as iso_ext_db_name, s.allele, s.ct/t.tot as frequency, s.ct as allele_count, t.tot as number_isolates
                 from (
                       select ia.external_db_name, isos.snp_source_id,isos.allele,count(*) as ct
                       from IsolateSNPs isos,IsolateAttributes ia
                       where  isos.allele in ('A','C','G','T')
                       and isos.is_source_id = ia.source_id
                       group by ia.external_db_name, isos.snp_source_id,isos.allele
                       ) s,
                       (
                       select ia.external_db_name, isos.snp_source_id, count(*) as tot
                       from IsolateSNPs isos,IsolateAttributes ia
                       where  isos.allele in ('A','C','G','T')
                       and isos.is_source_id = ia.source_id
                       group by ia.external_db_name, isos.snp_source_id
                       ) t
                       where s.snp_source_id = t.snp_source_id
                       and s.external_db_name = t.external_db_name
                       )
                 group by iso_ext_db_name,snp_source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index snpswiso_id_db_idx&1 on SnpsWithIsolates&1 (snp_source_id,iso_ext_db_name)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
update SnpsWithIsolates&1 swa
set swa.major_allele = (select max(allele) from IsolateAttributes ia, IsolateSNPs isnp 
                    where isnp.snp_source_id = swa.snp_source_id and ia.EXTERNAL_DB_NAME = swa.iso_ext_db_name
                    group by isnp.snp_source_id,ia.EXTERNAL_DB_NAME),
swa.minor_allele = (select min(allele) from IsolateAttributes ia, IsolateSNPs isnp 
                    where isnp.snp_source_id = swa.snp_source_id and ia.EXTERNAL_DB_NAME = swa.iso_ext_db_name
                    group by isnp.snp_source_id,ia.EXTERNAL_DB_NAME)
where swa.major_allele is null
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="Blastp">
    <!-- Each record stores a Blastp similarity of a gene. Used by the gene-page
         Blastp table. 
     -->
    <externalDependency name="dots.Similarity"/>
    <externalDependency name="dots.ExternalAaSequence"/>
    <externalDependency name="dots.GeneFeature"/>
    <externalDependency name="dots.Transcript"/>
    <externalDependency name="dots.TranslatedAaFeature"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="core.TableInfo"/>
    <internalDependency name="GeneAttributes"/>
    <internalDependency name="TaxonSpecies"/>
    <sql>
      <![CDATA[
create table Blastp&1 nologging as
select rownum as blastp_id, gf.source_id, ga.project_id, sim.similarity_id,
       subject.source_id as subject_source_id, sim.score score, sim.query_id, 
       sim.min_query_start, sim.max_query_end, sim.pvalue_mant, sim.pvalue_exp,
       sim.number_identical, sim.total_match_length,
       substr(replace(subject.description, chr(1), ''), 1, 300) as description,
       sim.number_positive, ed.name as external_database_name,
       substr(tn.name, 1, 50) AS query_organism, ns.taxon_id as query_taxon_id
from dots.Similarity sim, core.TableInfo qti, core.TableInfo sti, dots.ExternalAaSequence subject,
     dots.GeneFeature gf, dots.Transcript t, dots.TranslatedAaFeature taf,
     sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed,
     dots.NaSequence ns, -- TaxonSpecies st,
     sres.TaxonName tn, GeneAttributes ga
where qti.table_id = sim.query_table_id
  and qti.name = 'TranslatedAASequence'
  and sti.table_id = sim.subject_table_id
  and sti.name = 'ExternalAASequence'
  and subject.aa_sequence_id = sim.subject_id
  and ga.source_id = gf.source_id
  and gf.na_feature_id = t.parent_id
  and t.na_feature_id = taf.na_feature_id
  and taf.aa_sequence_id = sim.query_id
  and subject.external_database_release_id = edr.external_database_release_id
  and edr.external_database_id = ed.external_database_id
  and gf.na_sequence_id = ns.na_sequence_id
  and ns.taxon_id =
--    st.taxon_id and st.species_taxon_id = # TaxonSpecies mapping commented out
                     tn.taxon_id
  and tn.name_class = 'scientific name'
      ]]>
    </sql>
    <sql>
      <![CDATA[
update Blastp&1
set pvalue_exp = (select min(pvalue_exp) from Blastp&1)
where pvalue_mant = 0
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index Blastp_src_ix&1 on Blastp&1 (source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index Blastp_query_ix&1 on Blastp&1 (query_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
drop index Blastp_text_ix
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index Blastp_text_ix on Blastp&1(description) indextype is ctxsys.context
             parameters('DATASTORE CTXSYS.DEFAULT_DATASTORE')
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="GeneIsolateOverlap">
    <!-- Each record stores a colocated (gene, isolate) 2-tuple. Used by the
         gene page as well as the IsolateByOverlap query.
     -->
    <internalDependency name="IsolateAttributes"/>
    <internalDependency name="FeatureLocation"/>
    <externalDependency name="dots.Similarity"/>
    <sql>
      <![CDATA[
create table GeneIsolateOverlap&1 nologging as
select substr(ia.source_id, 1, 30) as isolate_source_id,
       fl.feature_source_id as gene_source_id,
       min(pvalue_exp) as min_pvalue_exp
from IsolateAttributes ia, dots.Similarity sim, FeatureLocation fl
where fl.feature_type = 'GeneFeature'
  and fl.na_sequence_id = sim.subject_id
  and fl.start_min < sim.max_subject_end
  and fl.end_max > sim.min_subject_start
  and sim.query_id = ia.na_sequence_id
group by ia.source_id, fl.feature_source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index gi_i_ix&1 on GeneIsolateOverlap&1 (isolate_source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index gi_g_ix&1 on GeneIsolateOverlap&1 (gene_source_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="TableWeight">
    <!-- Each record assigns a weight (i.e. an importance) to one WDK table.
         Used to order the results of text searches.
     -->
    <sql>
      <![CDATA[
create table TableWeight&1 nologging as
-- genes
  select cast ('GoTerms' as varchar2(80)) as table_name, 1 as weight from dual
union
  select cast ('Product' as varchar2(80)) as table_name, 5 as weight from dual
union
  select cast ('Notes' as varchar2(80)) as table_name, 2 as weight from dual
union
  select cast ('Comments' as varchar2(80)) as table_name, 2 as weight from dual
union
  select cast ('InterPro' as varchar2(80)) as table_name, 1 as weight from dual
union
  select cast ('BlastP' as varchar2(80)) as table_name, 1 as weight from dual
union
  select cast ('EcNumber' as varchar2(80)) as table_name, 1 as weight from dual
-- isolates
union
  select cast ('Reference' as varchar2(80)) as table_name, 1 as weight from dual
union
  select cast ('ProteinSequence' as varchar2(80)) as table_name, 1 as weight from dual
union
  select cast ('GeneOverlap' as varchar2(80)) as table_name, 1 as weight from dual
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create unique index weight_ix&1 on TableWeight&1(table_name)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="TaxonSpecies" prefixEnabled="true">
    <!-- Each record maps a taxon_id of interest onto the taxon_id that taxon's
         taxon-tree ancestor whose rank is "species". Used by
         buildAnnotationChangeTT and by gene queries, as well as an input in the
         creation of several tuning tables, including GeneAttributes and
         OrganismTree.
     -->
    <internalDependency name="SequenceAttributes"/>
    <externalDependency name="sres.Taxon"/>
    <sql>
      <![CDATA[
create table &prefixTaxonSpecies&1 nologging as
select t.taxon_id, species.taxon_id as species_taxon_id
from sres.Taxon species, (select distinct sa.taxon_id
      from &prefixSequenceAttributes sa) t
where species.taxon_id in (select taxon_id from sres.Taxon
                           connect by taxon_id = prior parent_id and prior rank != 'species'
                           start with taxon_id = t.taxon_id)
  and species.rank = 'species'
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="Blastx">
    <!-- Each record stores a Blastx similarity. Used by GBrowse for the
         match:WU_BLASTX track.
     -->
    <externalDependency name="dots.ExternalAaSequence"/>
    <externalDependency name="dots.NaSequence"/>
    <internalDependency name="SimilaritySpanLocation"/>
    <sql>
      <![CDATA[
create table Blastx&1
      (similarity_id, name, score, pvalue, na_sequence_id, startm, end, strand, atts,
       constraint blastx&1_pk primary key(na_sequence_id, startm, pvalue, end, similarity_id))
organization index
nologging
as
select distinct sim.similarity_id,
       extt.source_id name, 
       substr(sim.similarity_score || '', 1, 6) score, 
       to_number(sim.pvalue_mant || 'e' || sim.pvalue_exp) pvalue,
       extq.na_sequence_id,
       sim.min_query_start startm, 
       sim.max_query_end end, 
       decode (sim.similarity_is_reversed, 0, '+1', 1, '-1', '.') strand, 
       substr('Score=' || sim.similarity_score || ';;' || 
              'Expect=' || (sim.pvalue_mant || 'e' ||sim.pvalue_exp)||';;'|| 
              'Defline=' || extt.description || ';;' || 
              'PercentIdentity=' || sim.percent_identical || ';;' ||
              'PercentPositive=' || sim.percent_positive || ';;' ||
              'TStart=' || sim.min_query_start || ';;' || 
              'TStop=' || sim.max_query_end, 1, 400) atts 
from SimilaritySpanLocation sim, dots.ExternalAaSequence extt, 
     dots.NaSequence extq
where sim.query_id = extq.na_sequence_id
  and sim.subject_id = extt.aa_sequence_id
  and (sim.max_query_end - sim.min_query_start) < 5000
  and sim.pvalue_exp < -10
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="TranscriptSequence">
    <!-- Each record stores the transcript sequence of one gene. Used by the
         gene record and the sequence retrieval tool. Propagated to the portal.
     -->
    <externalDependency name="dots.Transcript"/>
    <externalDependency name="dots.SplicedNaSequence"/>
    <externalDependency name="sres.TaxonName"/>
    <internalDependency name="GeneAttributes"/>
    <sql>
      <![CDATA[
create table TranscriptSequence&1 nologging as
select gf.source_id, cast(apidb.project_id(tn.name) as varchar2(20)) as project_id,
       sns.sequence
from GeneAttributes gf, dots.Transcript t, dots.SplicedNaSequence sns, sres.TaxonName tn
where t.parent_id = gf.na_feature_id
  and sns.na_sequence_id = t.na_sequence_id
  and sns.taxon_id = tn.taxon_id
  and tn.name_class = 'scientific name'
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index XScriptSeq_ix&1 on TranscriptSequence&1 (source_id, project_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="CodingSequence">
    <!-- Each record stores the coding sequence of one gene. Used by the
         gene record and the sequence retrieval tool. Propagated to the portal.
     -->
    <externalDependency name="dots.Transcript"/>
    <externalDependency name="dots.SplicedNaSequence"/>
    <externalDependency name="dots.TranslatedAaFeature"/>
    <externalDependency name="sres.TaxonName"/>
    <internalDependency name="GeneAttributes"/>
    <sql>
      <![CDATA[
CREATE TABLE CodingSequence&1 NOLOGGING AS
SELECT gf.source_id, cast(apidb.project_id(tn.name) as varchar2(20)) as project_id,
       SUBSTR(sns.sequence, tf.translation_start,                            
              tf.translation_stop - tf.translation_start + 1) as sequence
FROM GeneAttributes gf, dots.Transcript t, dots.SplicedNaSequence sns,
     dots.TranslatedAaFeature tf, sres.TaxonName tn
WHERE t.parent_id = gf.na_feature_id
  AND sns.na_sequence_id = t.na_sequence_id
  AND t.na_feature_id = tf.na_feature_id
  AND sns.taxon_id = tn.taxon_id
  AND tn.name_class = 'scientific name'
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index CodSeq_ix&1 on CodingSequence&1 (source_id, project_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="ProteinSequence">
    <!-- Each record stores the coding sequence of one gene. Used by the
         gene record and the sequence retrieval tool, as well as by
         buildTrackOldAnnotationTT. Propagated to the portal.
     -->
    <externalDependency name="dots.Transcript"/>
    <externalDependency name="dots.TranslatedAaSequence"/>
    <externalDependency name="dots.TranslatedAaFeature"/>
    <externalDependency name="sres.TaxonName"/>
    <internalDependency name="GeneAttributes"/>
    <sql>
      <![CDATA[
CREATE TABLE ProteinSequence&1 NOLOGGING AS
SELECT ga.source_id, cast(apidb.project_id(tn.name) as varchar2(20)) as project_id,
       tas.sequence
FROM GeneAttributes ga, dots.Transcript t, dots.TranslatedAaFeature taf,
     dots.TranslatedAaSequence tas, sres.TaxonName tn
WHERE t.parent_id = ga.na_feature_id
  AND t.na_feature_id = taf.na_feature_id
  AND taf.aa_sequence_id = tas.aa_sequence_id
  AND tas.taxon_id = tn.taxon_id
  AND tn.name_class = 'scientific name'
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index ProtSeq_ix&1 on ProteinSequence&1 (source_id, project_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="NaSequence">
    <!-- Each record stores the nucleotide sequence for one genomic sequence
         that is "official" (in the sense that it can be instantiated as a WDK
         sequence record. Used by generatePathoLogicFile and the sequence
         retrieval tool Propagated to portal instances.
     -->
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="sres.TaxonName"/>
    <internalDependency name="SequenceAttributes"/>
    <sql>
      <![CDATA[
CREATE TABLE NaSequence&1 NOLOGGING AS
SELECT sa.source_id, cast(apidb.project_id(tn.name) as varchar2(20)) as project_id,
       ns.sequence
FROM SequenceAttributes sa, dots.NaSequence ns, sres.TaxonName tn
WHERE sa.na_sequence_id = ns.na_sequence_id
  AND ns.taxon_id = tn.taxon_id
  AND tn.name_class = 'scientific name'
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index GenomicSeq_ix&1 on NaSequence&1 (source_id, project_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="OrfSequence">
    <!-- Each record stores the amino-acid sequence of an ORF. Used by the
         relevant attribute query of the WDK ORF record, as well as by the
         sequence retrieval tool. Propagated to portal instances.
     -->
    <externalDependency name="dots.TranslatedAaSequence"/>
    <externalDependency name="dots.TranslatedAaFeature"/>
    <externalDependency name="dots.NaFeature"/>
    <externalDependency name="sres.SequenceOntology"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE OrfSequence&1 NOLOGGING AS
SELECT nf.source_id,
       cast(apidb.project_id(tn.name) as varchar2(20)) as project_id,
       ts.sequence
FROM dots.TranslatedAaSequence ts, dots.TranslatedAaFeature tf,
      dots.NaFeature nf, sres.SequenceOntology so, sres.TaxonName tn
 WHERE nf.na_feature_id = tf.na_feature_id
   AND ts.aa_sequence_id = tf.aa_sequence_id
   AND so.term_name = 'ORF'
   AND nf.sequence_ontology_id = so.sequence_ontology_id
   AND ts.taxon_id = tn.taxon_id
   AND tn.name_class = 'scientific name'
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index OrfSeq_ix&1 on OrfSequence&1 (source_id, project_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="EstSequence">
    <!-- Each record stores the nucleotide sequence of an EST, for use by the
         relevant attribute query in the WDK EST record. Propagated to portal
         instances.
     -->
    <externalDependency name="dots.ExternalNaSequence"/>
    <externalDependency name="sres.SequenceOntology"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE EstSequence&1 NOLOGGING AS
SELECT ens.source_id,
       cast(apidb.project_id(tn.name) as varchar2(20)) as project_id,
       ens.sequence
FROM dots.ExternalNaSequence ens, sres.SequenceOntology so, sres.TaxonName tn
WHERE so.term_name = 'EST'
  AND so.sequence_ontology_id = ens.sequence_ontology_id
  AND ens.taxon_id = tn.taxon_id
  AND tn.name_class = 'scientific name'
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index EstSeq_ix&1 on EstSequence&1 (source_id, project_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="AssemblySequence">
    <!-- Holds the sequence of an assembly.
     -->
    <externalDependency name="dots.Assembly"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE AssemblySequence&1 NOLOGGING AS
SELECT a.source_id,
       cast(apidb.project_id(tn.name) as varchar2(20)) as project_id,
       a.sequence 
FROM dots.Assembly a, sres.TaxonName tn
WHERE a.taxon_id = tn.taxon_id
  AND tn.name_class = 'scientific name'
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index AssemblySeq_ix&1 on AssemblySequence&1 (source_id, project_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="UTR" prefixEnabled="true">
    <!-- Each record represents an untranslated region (UTR) of a gene. Used by
         GBrowse.
     -->
    <internalDependency name="FeatureLocation"/>
    <externalDependency name="dots.ExonFeature"/>
    <externalDependency name="dots.GeneFeature"/>
    <externalDependency name="sres.SequenceOntology"/>
    <sql>
      <![CDATA[
CREATE TABLE &prefixUTR&1 NOLOGGING AS
SELECT na_feature_id,parent_id,na_sequence_id,start_min,end_max,direction,is_reversed,end_max-start_min+1 as length FROM 
(
  (SELECT exon_loc.na_feature_id,
          exon_loc.parent_id,
          exon_loc.na_sequence_id,
          exon_loc.start_min as start_min,
          CASE WHEN exon_loc.is_reversed = 0 THEN exon_loc.coding_start - 1 
               ELSE exon_loc.coding_end - 1 
               END end_max,
          CASE WHEN exon_loc.is_reversed = 0 THEN 5 
               WHEN exon_loc.is_reversed = 1 THEN 3 
               ELSE 0 END direction,
          exon_loc.is_reversed
   FROM   FeatureLocation exon_loc, dots.GeneFeature gf, sres.SequenceOntology so
   WHERE  exon_loc.feature_type = 'ExonFeature'
      AND gf.na_feature_id = exon_loc.parent_id
      AND gf.sequence_ontology_id = so.sequence_ontology_id
      AND so.term_name = 'protein_coding'
      AND ((exon_loc.is_reversed = 0 AND exon_loc.coding_start - exon_loc.start_min  != 0)
       OR (exon_loc.is_reversed = 1 AND exon_loc.coding_end - exon_loc.start_min  != 0)))
  UNION
  (SELECT exon_loc.na_feature_id, 
          exon_loc.parent_id,
          exon_loc.na_sequence_id,
          CASE WHEN exon_loc.is_reversed = 0 THEN exon_loc.coding_end + 1 
               ELSE exon_loc.coding_start + 1 
               END start_min,
          exon_loc.end_max,
          CASE WHEN exon_loc.is_reversed = 0 THEN 3 
          WHEN exon_loc.is_reversed = 1 THEN 5 
          ELSE 0 END direction,
          exon_loc.is_reversed
   FROM   FeatureLocation exon_loc, dots.GeneFeature gf, sres.SequenceOntology so
   WHERE  exon_loc.feature_type = 'ExonFeature'
      AND gf.na_feature_id = exon_loc.parent_id
      AND gf.sequence_ontology_id = so.sequence_ontology_id
      AND so.term_name = 'protein_coding'
      AND ((exon_loc.is_reversed = 0 AND exon_loc.end_max - exon_loc.coding_end  != 0)
       OR (exon_loc.is_reversed = 1 AND exon_loc.end_max - exon_loc.coding_start  != 0))  )
   UNION
   (SELECT exon_loc.na_feature_id,
           exon_loc.parent_id,
           exon_loc.na_sequence_id,
           exon_loc.start_min,
           exon_loc.end_max,
           CASE WHEN ef.order_number <= eo.max_order_number THEN 5
                WHEN ef.order_number > eo.max_order_number THEN 3
                ELSE 0
                END direction,
           exon_loc.is_reversed
    FROM   FeatureLocation exon_loc, dots.exonfeature ef, dots.GeneFeature gf, sres.SequenceOntology so,
           (select parent_id, max(order_number) as max_order_number from dots.exonfeature
            where coding_start is not null
            group by parent_id) eo
    WHERE  exon_loc.feature_type = 'ExonFeature'
       AND gf.na_feature_id = exon_loc.parent_id
       AND ef.na_feature_id = exon_loc.na_feature_id
       AND ef.parent_id = eo.parent_id
       AND gf.sequence_ontology_id = so.sequence_ontology_id
       AND so.term_name = 'protein_coding'
       AND exon_loc.coding_start is null)
)
WHERE end_max - start_min != 0
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index UTRSeq_ix&1 on &prefixUTR&1 (na_feature_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="IsolateSequence">
    <!-- Each record stores the nucleotide sequence of one isolate. Used in the
         relevant attribute query of the WDK isolate record, as well as by
         IsolateClustalw. Propagated to portal instances.
     -->
    <internalDependency name="IsolateAttributes"/>
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE IsolateSequence&1 NOLOGGING AS
SELECT ia.source_id,
       ia.project_id,
       ns.sequence
FROM IsolateAttributes ia, dots.NaSequence ns, sres.TaxonName tn
WHERE ia.na_sequence_id = ns.na_sequence_id
  AND ns.taxon_id = tn.taxon_id
  AND tn.name_class = 'scientific name'
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index IsolateSeq_ix&1 on IsolateSequence&1 (source_id, project_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="TypeAheadCounts">
    <!-- Stores strings that can be used in parameters with type-ahead, such as
         GO terms, EC numbers, or InterPro domains. Each record stores such a
         string, along with the project ID and the number of genes with which it
         is associated. Used for gene queries.
     -->
    <internalDependency name="GeneAttributes"/>
    <externalDependency name="dots.DbRefAaFeature"/>
    <externalDependency name="sres.DbRef"/>
    <externalDependency name="dots.AaFeature"/>
    <externalDependency name="dots.TranslatedAaFeature"/>
    <externalDependency name="dots.Transcript"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.EnzymeClass"/>
    <externalDependency name="dots.AaSequenceEnzymeClass"/>
    <externalDependency name="dots.GoAssociation"/>
    <externalDependency name="sres.GoTerm"/>
    <externalDependency name="sres.GoRelationship"/>
    <externalDependency name="sres.GoRelationshipType"/>
    <externalDependency name="core.TableInfo"/>
    <sql>
      <![CDATA[
CREATE TABLE TypeAheadCounts&1 NOLOGGING AS
   (SELECT DISTINCT dr.primary_identifier as option_id,
                   count(distinct aaf.aa_sequence_id) AS gene_count,
                   gf.project_id
   FROM dots.DbRefAaFeature draf, sres.DbRef dr, dots.aafeature aaf,
        sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed,
        dots.TranslatedAAFeature taf,GeneAttributes gf, dots.transcript t
   WHERE draf.db_ref_id = dr.db_ref_id
   AND dr.external_database_release_id
       = edr.external_database_release_id
   AND edr.external_database_id = ed.external_database_id
   AND aaf.aa_feature_id = draf.aa_feature_id
   AND aaf.aa_sequence_id = taf.aa_sequence_id
   AND taf.na_feature_id = t.na_feature_id
   AND gf.na_feature_id = t.parent_id
   GROUP BY gf.project_id,
            dr.primary_identifier)
   UNION
   (SELECT DISTINCT ec.ec_number AS option_id,
          COUNT(DISTINCT aaf.aa_sequence_id) AS gene_count,
          gf.project_id
   FROM sres.EnzymeClass ec, GeneAttributes gf,
        dots.AaSequenceEnzymeClass asec,
        dots.translatedAaFeature taf,
        dots.aafeature aaf, dots.transcript t
   WHERE gf.na_feature_id = t.parent_id
   AND t.na_feature_id = taf.na_feature_id
   AND taf.aa_sequence_id = asec.aa_sequence_id
   AND aaf.aa_sequence_id = taf.aa_sequence_id
   AND asec.enzyme_class_id = ec.enzyme_class_id
   GROUP BY gf.project_id,
            ec.ec_number)
   UNION                
   (SELECT DISTINCT gp.go_id AS option_id,
           COUNT(DISTINCT aaf.aa_sequence_id) AS gene_count,
           gf.project_id
    FROM GeneAttributes gf, dots.Transcript t,
         dots.TranslatedAaFeature taf, dots.AaFeature aaf,
         dots.GoAssociation ga, sres.GoTerm gp,
         sres.GoRelationship gr, core.TableInfo ti,
         sres.GoRelationshipType grt
    WHERE gf.na_feature_id = t.parent_id
    AND t.na_feature_id = taf.na_feature_id
    AND taf.aa_sequence_id = ga.row_id
    AND aaf.aa_sequence_id = taf.aa_sequence_id
    AND ga.table_id = ti.table_id
    AND ti.name = 'TranslatedAASequence'
    AND ga.go_term_id = gr.child_term_id
    AND gr.parent_term_id = gp.go_term_id
    AND gr.go_relationship_type_id = grt.go_relationship_type_id
    AND grt.name = 'closure'
    GROUP BY gf.project_id,
             gp.go_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX TypeAheadCounts_idx&1 ON TypeAheadCounts&1 (option_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="ExpressionElement">
    <!-- Each record associates expression values for an NaFeature with that
         feature's ID and location. Used by GBrowse, as well as in the creation
         of the ChIPchipGene table.
     -->
    <internalDependency name="FeatureLocation"/>
    <externalDependency name="rad.DataTransformationResult"/>
    <sql>
      <![CDATA[
      create table ExpressionElement&1 nologging as
      select fl.na_feature_id, fl.na_sequence_id, fl.start_min, fl.end_max,
             fl.feature_source_id, dtr.analysis_id, dtr.float_value as score
      from rad.DataTransformationResult dtr, FeatureLocation fl
      where dtr.row_id = fl.na_feature_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
      create index ee_track_ix&1
      on ExpressionElement&1 (na_sequence_id, analysis_id, start_min, end_max, na_feature_id, score)
      tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="OrthologousPair">
    <!-- Each record contains a pair of genes that are orthologous to each other.
         Used in the creation of the tuning table OrthologGeneTable.
     -->
    <internalDependency name="GeneAttributes"/>
    <sql>
      <![CDATA[
       create table OrthologousPair&1 nologging as
       select /*+ ordered_predicates */
              ga2.source_id AS ortho_source_id, ga2.na_sequence_id as ortho_na_sequence_id, ga2.start_min as ortho_start_min,
              case when ga1.project_id = 'GiardiaDB' then ga2.species
              else ga2.organism end as organism, 
              ga2.product, ga1.source_id, ga1.project_id, ga1.na_sequence_id, ga1.start_min,
              nvl(comments.comment_count, 'no') as comment_count
             from GeneAttributes ga1, GeneAttributes ga2,
                  (select distinct 'yes' as comment_count, stable_id as source_id, project_name
                   from comments2.comments@&dblink
                   where comment_target_id = 'gene'
                     and review_status_id != 'rejected'
                     and is_visible = 1) comments
             where ga2.source_id = comments.source_id(+)
               and ga2.project_id = ga1.project_id
               and ga1.orthomcl_name = ga2.orthomcl_name
               and ga2.source_id != ga1.source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
      create index orth_ix&1
      on OrthologousPair&1 (source_id, project_id)
      tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="OrthologGeneTable">
    <!-- Each record contains a record from OrthologousPair, augmented by the
         IS_SYNTENIC column. Used by the relevant table query of the WDK gene
         record.
      -->
    <internalDependency name="OrthologousPair"/>
    <externalDependency name="apidb.Synteny"/>
    <sql>
      <![CDATA[
      create table OrthologGeneTable&1 nologging as
      select
       op.ortho_source_id,
       op.organism,
       op.product, op.source_id,
       nvl(synteny.is_syntenic, 'no') as is_syntenic,
       op.comment_count,
       op.project_id
      from OrthologousPair op,
       (select distinct
               'yes' as is_syntenic,
               a_na_sequence_id, b_na_sequence_id, a_start, a_end, b_start, b_end
        from apidb.synteny s) synteny
        where synteny.a_na_sequence_id(+) = op.na_sequence_id
          AND synteny.b_na_sequence_id(+) = op.ortho_na_sequence_id
          AND synteny.a_start(+) <= op.start_min
          AND synteny.a_end(+) >= op.start_min
          AND synteny.b_start(+) <= op.ortho_start_min
          AND synteny.b_end(+) >= op.ortho_start_min
      ]]>
    </sql>
    <sql>
      <![CDATA[
      create index ogt_ix&1
      on OrthologGeneTable&1 (source_id, project_id)
      tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="OrganismAbbreviation">
    <!-- Each record maps an organism name onto an abbreviation, getting the
         pair either from apidb.Organism or (in the case of Tvag), hardwired
         into the below SQL. This table will eventually be replaced by workflow.
      -->
    <externalDependency name="apidb.Organism"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
       CREATE TABLE OrganismAbbreviation&1 NOLOGGING AS
       select organism, abbreviation
       From (
  -- TrichDB Annotated Genomes
  select 'Trichomonas vaginalis G3' as organism, 'Tvaginalis' as abbreviation from dual union  
   -- All projects which use the Workflow can get this directly from the organism table
  select tn.name as organism, o.name_for_filenames as abbreviation
  from apidb.Organism o, sres.TaxonName tn
  where o.taxon_id = tn.taxon_id
  and tn.name_class = 'scientific name'
       )
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="OrganismAbbreviationWS">
    <!-- Stores special webservice abbreviations which are not standard organism
         names. Each record maps an organism name onto this abbreviation, as
         well as the species name and project ID. Used by the model and as an
         input in the creation of the OrganismAbbreviationBlast tuning table.
         Propagated to portal instances.
      -->
    <internalDependency name="OrganismAbbreviation"/>
    <internalDependency name="OrganismTree"/>
    <sql>
      <![CDATA[
       create table OrganismAbbreviationWS&1 nologging as
       select oa.organism, ot.parentTerm as parent, oa.abbreviation, ot.project_id
       from OrganismAbbreviation oa, OrganismTree ot
       where ot.term = oa.organism
       union
       select special.organism, special.parent,special.abbreviation, ot.project_id from OrganismTree ot,(
  -- TrichDB Repeat Genes
  select 'Trichomonas vaginalis G3 (Repeated Genes)' as organism, 'Trichomonas vaginalis' as parent, 'TvaginalisRG' as abbreviation from dual
) special
          where special.parent = ot.term
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="ProjectIdTaxonLevel">
    <!-- Groups projects by higher level taxonomy. Used in the creation of the
         OrganismTree tuning table.
      -->
    <internalDependency name="SequenceAttributes"/>
    <sql>
      <![CDATA[
       CREATE TABLE ProjectIdTaxonLevel&1 NOLOGGING AS
       SELECT p.project_id, taxon_node, organism
          FROM (SELECT 'PlasmoDB' AS project_id,
		       'Apicomplexa' AS  taxon_node 
		FROM dual 
		UNION
		SELECT 'CryptoDB' AS project_id,
			   'Apicomplexa' AS  taxon_node 
		FROM dual 
		UNION
		SELECT 'ToxoDB' AS project_id,
		           'Apicomplexa' AS  taxon_node 
		FROM dual 
		UNION
		SELECT 'PiroplasmaDB' AS project_id,
		           'Apicomplexa' AS  taxon_node 
		FROM dual
		UNION
		SELECT 'TriTrypDB' AS project_id,
			   'Kinetoplastida' AS  taxon_node 
		FROM dual 
		UNION
		SELECT 'AmoebaDB' AS project_id,
			   'Amoebozoa' AS  taxon_node 
		FROM dual
		UNION 
		SELECT 'MicrosporidiaDB' AS project_id,
		           'Microsporidia' AS  taxon_node 
		FROM dual
		UNION
		SELECT 'GiardiaDB' AS project_id, 
		           'Diplomonadida' AS taxon_node 
		FROM dual
		UNION
		SELECT 'TrichDB' AS project_id,
		           'Trichomonadida' AS taxon_node
		FROM dual
        ) p,
        (select distinct project_id, organism from sequenceattributes) s
        where p.project_id = s.project_id
        union 
        SELECT distinct s.project_id as project_id, 
          CASE
            when (s.organism like 'Coprinopsis%' or
                  s.organism like 'Phanerochaete%')
            then 'Agaricomycetes'
            when (s.organism like 'Batrachochytrium%') 
            then 'Chytridiomycetes'
            when (s.organism like 'Aspergillus%' or
                  s.organism like 'Emericella%' or
                  s.organism like 'Coccidioides%' or
                  s.organism like 'Histoplasma%' or
                  s.organism like 'Talaromyces%' or
                  s.organism like 'Penicillium%' or
                  s.organism like 'Neosartorya%' or
                  s.organism like 'Ajellomyces%')
            then 'Eurotiomycetes'
            when (s.organism like 'Sclerotinia%' or
                  s.organism like 'Botrytis%' or 
                  s.organism like 'Botryotinia%' )
            then 'Leotiomycetes'
            when (s.organism like 'Hyaloperonospora%' or
                  s.organism like 'Phytophthora%' or
                  s.organism like 'Pythium%' )
            then 'Oomycetes'
            when (s.organism like 'Puccinia%')
            then 'Pucciniomycetes'
            when (s.organism like 'Saccharomyces%' or
                  s.organism like 'Candida%')
            then 'Saccharomycetes'
            when (s.organism like 'Schizosaccharomyces%')
            then 'Schizosaccharomycetes' 
            when (s.organism like 'Neurospora%' or 
                  s.organism like 'Magnaporthe%' or 
                  s.organism like 'Fusarium%' or 
                  s.organism like 'Gibberella%' or
                  s.organism like 'Trichoderma%' or
                  s.organism like 'Sordaria%')
            then 'Sordariomycetes'
            when (s.organism like 'Tremella%' or
                  s.organism like 'Cryptococcus%' )
            then 'Tremellomycetes'
            when (s.organism like 'Ustilago%' or
                  s.organism like 'Malassezia%' or 
                  s.organism like 'Sporisorium%') 
            then 'Ustilaginomycetes'
            when (s.organism like 'Rhizopus%' or
                  s.organism like 'Mucor%')
            then 'Zygomycetes'
            else 'Missing ProjectIdTaxonLevel'
          end as taxon_node,
          s.organism as organism
        from sequenceattributes s
        where s.project_id = 'FungiDB'
	]]>
    </sql>
  </tuningTable>

  <tuningTable name="OrganismTree">
    <!-- Group species by higher level taxonomy. Each row associates a taxon of
         interest with one of its ancestors in the taxon tree. Used in parameter
         queries that have to know about the taxon tree, as well as
         apidb.project_id(), the function that maps an organism name to a
         project. Propagated to portal instances.
      -->
    <internalDependency name="ProjectIdTaxonLevel"/>
    <internalDependency name="SequenceAttributes"/>
    <internalDependency name="TaxonSpecies"/>
    <externalDependency name="sres.TaxonName"/>
    <externalDependency name="sres.Taxon"/>
    <intermediateTable name="StrainTree"/>
    <sql>
      <![CDATA[
CREATE TABLE StrainTree NOLOGGING AS
SELECT *
FROM (         SELECT organism,term,parentTerm, internal,project_id
         FROM (
           -- all organisms from sequenceattributes as organism, organism as term, parentterm is species           
           SELECT DISTINCT sa.organism AS organism,
                           sa.organism AS term,
                           sn.name AS parentTerm,
                           t.taxon_id AS internal,
                           sa.project_id AS project_id
           FROM SequenceAttributes sa, sres.TaxonName tn,
                sres.Taxon t, sres.TaxonName sn, TaxonSpecies ts
           WHERE tn.name = sa.organism
           AND  ts.taxon_id = tn.taxon_id
           AND  sn.taxon_id = ts.species_taxon_id
           AND t.taxon_id = ts.taxon_id
           AND sn.name_class = 'scientific name'
           AND t.rank != 'species'
           UNION
           -- all organisms from sequenceattributes as organism, species as term, parentterm is genus  
           -- we are getting a row for species level AND for children here
           SELECT DISTINCT sa.organism,  
                          sn.name AS term,
                          SUBSTR(sa.organism,0,(INSTR(sa.organism,' ') - 1)) AS parentTerm,
                          tn.taxon_id AS internal,
                          sa.project_id AS project_id
           FROM SequenceAttributes sa, sres.Taxon t, 
                sres.TaxonName tn, sres.TaxonName sn,
                TaxonSpecies ts
           WHERE tn.name = sa.organism
           AND  ts.taxon_id = tn.taxon_id
           AND  sn.taxon_id = ts.species_taxon_id
           AND t.taxon_id = ts.taxon_id
           AND sn.name_class = 'scientific name'
           UNION 
           SELECT DISTINCT sa.organism,
                          sn.name AS term,
                          SUBSTR(sa.organism,0,(INSTR(sa.organism,' ') - 1)) AS parentTerm,
                          sn.taxon_id AS internal,
                          sa.project_id AS project_id
           FROM SequenceAttributes sa, sres.Taxon t, 
                sres.TaxonName tn, sres.TaxonName sn,
                TaxonSpecies ts
           WHERE tn.name = sa.organism
           AND  ts.taxon_id = tn.taxon_id
           AND  sn.taxon_id = ts.species_taxon_id
           AND t.taxon_id = ts.taxon_id
           AND sn.name_class = 'scientific name'
           UNION
           -- all organisms from sequenceattributes as organism, genus as term, parentterm from taxonlevel
           SELECT DISTINCT sa.organism,      
                           SUBSTR(sa.organism,0,(INSTR(sa.organism,' ') - 1)) AS term,
                           ptl.taxon_node AS parentTerm,
                           -1 AS internal,
                           sa.project_id AS project_id
           FROM SequenceAttributes sa, ProjectIdTaxonLevel ptl
           WHERE ptl.project_id = sa.project_id
            AND ptl.organism = sa.organism
           UNION
           -- all organisms from sequenceattributes as organism, taxon_node as term, parentterm is null
           SELECT DISTINCT sa.organism,               
                           ptl.taxon_node AS term,
                           '' AS parentTerm,
                           -1 AS internal,
                           sa.project_id AS project_id
           FROM SequenceAttributes sa, ProjectIdTaxonLevel ptl
           WHERE ptl.project_id = sa.project_id
            AND ptl.organism = sa.organism))
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE TABLE OrganismTree&1 NOLOGGING AS
         SELECT organism,term,parentTerm, internal,project_id
         FROM (
               SELECT * from StrainTree
               UNION
               SELECT stn.name as organism,
                      st.term as term,
                      st.parentTerm as parentTerm,
                      st.internal as internal,
                      st.project_id as project_id
               FROM StrainTree st, TaxonSpecies ts, sres.TaxonName tn, sres.TaxonName stn
               WHERE tn.taxon_id = ts.taxon_id
                 AND stn.taxon_id = ts.species_taxon_id
                 AND st.organism = tn.name
                 AND tn.name_class = 'scientific name'
                 AND stn.name_class = 'scientific name'
                 AND st.organism != st.term
          )
    	]]>
    </sql>
  </tuningTable>

  <tuningTable name="OrganismAbbreviationBlast">
    <!-- Each record maps an organism to its BLAST abbreviation. Used by
         BLAST-query parameters. Propagated to portal instances.
      -->
    <internalDependency name="OrganismAbbreviationWS"/>
    <internalDependency name="OrganismTree"/>
    <internalDependency name="EstAttributes"/>
    <sql>
      <![CDATA[
       create table OrganismAbbreviationBlast&1 nologging as
       select organism, parent, abbreviation, project_id from OrganismAbbreviationWS
         union
      -- All familes for isolates
      select distinct family_name_for_files || ' Popset/Genbank Isolates' as organism, '' as parent, family_name_for_files as abbreviation, project_name as project_id
      from apidb.Organism 
       where family_name_for_files is not null
       and family_name_for_files NOT IN ('Culicosporidae', 'Dubosqiidae', 'Pleistophoridae')
       union
       select special.organism, special.parent, special.abbreviation, ot.project_id from OrganismTree ot,
       (
  -- All species and speciesAbbreviations from apidb.Organism where we have ests
  select distinct sp.name as organism,
                  ot.parentTerm as parent,
                  REGEXP_REPLACE(org.name_for_filenames, org.strain_abbrev,'', 1, 1) as abbreviation 
  from sres.TaxonName sp, taxonspecies ts, apidb.Organism org, organismtree ot,
       estattributes ea, sres.TaxonName etn, taxonspecies ets
  where org.taxon_id = ts.taxon_id
  and ts.species_taxon_id = sp.taxon_id
  and sp.name_class = 'scientific name'
  and ot.term = sp.name
  and org.strain_abbrev is not null
  and org.name_for_filenames is not null
  and ets.species_taxon_id = sp.taxon_id
  and (ets.taxon_id = etn.taxon_id OR ets.species_taxon_id = etn.taxon_id)
  and etn.name = ea.organism
  union
  -- TrichDB EST Legacy
  select 'Trichomonas vaginalis' as organism, 'Trichomonas' as parent, 'Tvaginalis' as abbreviation from dual union  
  --
  select 'Cryptosporidiidae Reference Isolates' as organism, 'Cryptosporidium' as parent, 'CryptosporidiidaeReference' as abbreviation from dual
) special
      where special.parent = ot.term
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="BlastTypes">
    <!-- For each project, show which BLAST databases are available for which
         species. Used in BLAST param queries. Propagated to portal instances.
      -->
    <internalDependency name="GeneAttributes"/>
    <internalDependency name="SequenceAttributes"/>
    <internalDependency name="EstAttributes"/>
    <internalDependency name="TaxonSpecies"/>
    <externalDependency name="apidb.Organism"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
       create table BlastTypes&1 nologging as
  -- Standard GENES
  select distinct organism, project_id, type 
  from GeneAttributes,
       (select 'AnnotatedTranscripts' as type from dual union select 'AnnotatedProteins' as type from dual)
  where organism not in ('Toxoplasma gondii RH') and gene_type = 'protein coding' 
  UNION
  -- TrichDB Repeat Genes
  select distinct organism || ' (Repeated Genes)', project_id, type 
  from GeneAttributes,
       (select 'AnnotatedTranscripts' as type from dual union select 'AnnotatedProteins' as type from dual)
  where project_id = 'TrichDB'
  UNION
  -- GiardiaDB Deprecated Genes
  select 'Giardia Assemblage A isolate WB (deprecated)' as organism, 'GiardiaDB' as project_id, type 
  from dual, (select 'AnnotatedTranscripts' as type from dual union select 'AnnotatedProteins' as type from dual)
  UNION
  -- GiardiaDB Scaffolds
  select 'Giardia Assemblage A isolate WB (scaffolds)' as organism, 'GiardiaDB' as project_id, type 
  from dual, (select 'Genome' as type from dual)
  UNION  
  -- Standard GENOME
  select distinct organism, project_id, type 
  from SequenceAttributes,
       (select 'ORFs_AA' as type from dual union select 'Genome' as type from dual)
  UNION
  -- Mitochondrial GENES and GENOME
  select distinct organism || ' mitochondrial', project_id, type 
  from SequenceAttributes,       
  (select 'ORFs_AA' as type from dual union select 'Genome' as type from dual union select 'AnnotatedTranscripts' as type from dual union select 'AnnotatedProteins' as type from dual)
  where so_id = 'SO:0000819'
  and not project_id='PlasmoDB' 
  UNION
  -- Plastid GENES and GENOME
  select distinct organism || ' plastid' as organism, project_id, type 
  from SequenceAttributes,       
  (select 'ORFs_AA' as type from dual union select 'Genome' as type from dual union select 'AnnotatedTranscripts' as type from dual union select 'AnnotatedProteins' as type from dual)
  where so_id = 'SO:0001259'
  and not project_id='PlasmoDB' 
  UNION
  -- Regular ESTs (all species from estattributes)
  select distinct sp.name as organism, ea.project_id, 'ESTs' as type
  from EstAttributes ea, sres.TaxonName tn, taxonspecies ts, sres.TaxonName sp
  where ea.organism = tn.name
  and (tn.taxon_id = ts.taxon_id or tn.taxon_id=ts.species_taxon_id)
  and ts.species_taxon_id = sp.taxon_id
  and sp.name_class = 'scientific name'
  UNION
  -- regular Isolates
  select distinct family_name_for_files || ' Popset/Genbank Isolates' as organism, project_name as project_id, 'Isolates'
  from apidb.Organism 
  where family_name_for_files is not null
  UNION
  -- isolates are hard coded
  select 'P. falciparum Barcode Isolates' as organism, 'PlasmoDB' as project_id, 'Isolates' as type from dual
  UNION
  select 'P. berghei Popset/Genbank Isolates' as organism,'PlasmoDB' as project_id, 'Isolates' as type from dual
  UNION
  select 'P. chabaudi Popset/Genbank Isolates' as organism,'PlasmoDB' as project_id, 'Isolates' as type from dual
  UNION
  select 'P. falciparum Popset/Genbank Isolates' as organism,'PlasmoDB' as project_id, 'Isolates' as type from dual
  UNION
  select 'P. knowlesi Popset/Genbank Isolates' as organism,'PlasmoDB' as project_id, 'Isolates' as type from dual
  UNION
  select 'P. reichenowi Popset/Genbank Isolates' as organism,'PlasmoDB' as project_id, 'Isolates' as type from dual
  UNION
  select 'P. vivax Popset/Genbank Isolates' as organism,'PlasmoDB' as project_id, 'Isolates' as type from dual
  UNION
  select 'P. yoelii Popset/Genbank Isolates' as organism,'PlasmoDB' as project_id, 'Isolates' as type from dual
  UNION
  select 'All Giardia Isolates' as organism, 'GiardiaDB' as project_id, 'Isolates' as type from dual
  UNION
  select 'Cryptosporidiidae Reference Isolates' as organism, 'CryptoDB' as project_id, 'Isolates' as type from dual
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="CompoundAttributes">
    <!-- The BFMV for the compound WDK record type. Used by the model for the
         compound record and queries, as well as in the creation of the
         PathwayCompounds tuning table. Propagated to portal instances.
      -->
    <externalDependency name="apidb.PubChemSubstance"/>
    <externalDependency name="apidb.PubChemCompound"/>
    <sql>
      <![CDATA[
CREATE TABLE CompoundAttributes&1 NOLOGGING AS
SELECT comp.compound_id,  'CID:' || comp.compound_id AS source_id, 
              apidb.tab_to_string(set(cast(COLLECT(to_char(nameTable.name)) AS apidb.varchartab)), ', ') AS name,
              apidb.tab_to_string(set(cast(COLLECT(to_char(substTable.substance_id)) AS apidb.varchartab)), ', ') AS substance_id,
              wtTable.mol_wt, REGEXP_REPLACE(formTable.formula,'(\d)','<sub>\1</sub>') AS formula
        FROM apidb.PubChemCompound comp,
                  (SELECT compound_id , value as name FROM apidb.PubChemCompound where property='Name') nameTable,
                  (SELECT compound_id , value as mol_wt FROM apidb.PubChemCompound where property='MolecularWeight') wtTable,
                  (SELECT compound_id , value as formula FROM apidb.PubChemCompound where property='MolecularFormula') formTable,
                  (SELECT substance_id, value as cid FROM apidb.PubChemSubstance where property='CID' )  substTable 
       WHERE comp.compound_id = nameTable.compound_id (+)
         AND comp.compound_id = wtTable.compound_id
         AND comp.compound_id = formTable.compound_id
         AND comp.compound_id = substTable.cid (+)
      GROUP BY comp.compound_id,wtTable.mol_wt,formTable.formula
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="PathwayCompounds">
    <!-- Each record represents a 5-tuple of (reaction, compound, pathway,
         enzyme, type). Used extensively in the model for pathway-related
         queries, as well as by getImageMap.pl.
      -->
    <internalDependency name="CompoundAttributes"/>
    <externalDependency name="dots.Transcript"/>
    <externalDependency name="dots.TranslatedAaFeature"/>
    <externalDependency name="dots.AaSequenceEnzymeClass"/>
    <externalDependency name="sres.EnzymeClass"/>
    <externalDependency name="apidb.Network"/>
    <externalDependency name="apidb.NetworkNode"/>
    <externalDependency name="apidb.NetworkRelationship"/>
    <externalDependency name="apidb.NetworkRelationshipType"/>
    <externalDependency name="apidb.NetworkContext"/>
    <externalDependency name="apidb.NetworkRelContext"/>
    <externalDependency name="apidb.NetworkRelContextLink"/>
    <externalDependency name="apidb.PubChemSubstance"/>
    <sql>
      <![CDATA[
CREATE TABLE PathwayCompounds&1 NOLOGGING AS
SELECT  '@PROJECT_ID@' AS project_id, ca.compound_id, ca.source_id AS compound_source_id, x.*
FROM   apidb.PubChemSubstance s1, apidb.PubChemSubstance s2, CompoundAttributes ca,
    (  -- CASE  A :  NOT reversible
      SELECT  CASE WHEN nn1.node_type_id = 2 THEN nn1.display_label
                 WHEN nn2.node_type_id = 2 THEN nn2.display_label
                 ELSE 'None' END AS compound,
            CASE WHEN nn1.node_type_id = 1 THEN REPLACE(nn1.display_label, '_X:_Y:','')
                 WHEN nn2.node_type_id = 1 THEN REPLACE(nn2.display_label, '_X:_Y:','')
                 ELSE 'None' END AS enzyme,
             CASE  WHEN (nrc.source_node = 0 and nn1.node_type_id = 1) THEN  'product' -- reaction from enzyme to compound
                      ELSE 'substrate' END AS type,
              nrt.display_name AS reaction,
              nc.description ||' ('||nc.name||')' AS pathway, nc.name AS name, nc.network_context_id
     FROM apidb.NetworkRelationshipType nrt, apidb.NetworkRelContext nrc, apidb.NetworkRelationship nr,
              apidb.NetworkRelContextLink nrl, apidb.NetworkContext nc,
              apidb.NetworkNode nn1, apidb.NetworkNode nn2
     WHERE nrc.network_relationship_type_id = nrt.network_relationship_type_id
           -- source_node = 1 means irreversible (this is an adjustment as network schema cant store reversibility)
            AND nrc.source_node = 1 
     	    AND nrc.network_relationship_id = nr.network_relationship_id
	    AND nr.node_id = nn1.network_node_id
      	    AND nr.associated_node_id = nn2.network_node_id
      	    AND  nrl.network_rel_context_id = nrc.network_rel_context_id
      	    AND  nc.network_context_id = nrc.network_context_id
     UNION
      -- CASE  B :   reversible
     SELECT  nn2.display_label as compound, REPLACE(nn1.display_label, '_X:_Y:','') AS enzyme, 
                  'substrate/product' AS type,
                  nrt.display_name AS reaction, 
                  nc.description ||' ('||nc.name||')' as pathway, nc.name AS name, nc.network_context_id
       FROM apidb.NetworkRelationshipType nrt, apidb.NetworkRelContext nrc, apidb.NetworkRelationship nr,
              apidb.NetworkRelContextLink nrl, apidb.NetworkContext nc,
              apidb.NetworkNode nn1, apidb.NetworkNode nn2
     WHERE nrc.network_relationship_type_id = nrt.network_relationship_type_id
           -- source_node = 0 means reversible (this is an adjustment as network schema cant store reversibility)
      	   AND nrc.source_node = 0 
      	   AND nrc.network_relationship_id = nr.network_relationship_id
      	   AND nr.node_id = nn1.network_node_id
      	   AND nr.associated_node_id = nn2.network_node_id
      	   AND  nrl.network_rel_context_id = nrc.network_rel_context_id
      	   AND  nc.network_context_id = nrc.network_context_id
      	   AND nn1.node_type_id = 1
     	   ) x
WHERE s1.property = 'CID'
      AND  s1.value = ca.compound_id 
      AND  s1.substance_id = s2.substance_id
      AND  (s2.value = x.compound)
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="MSPeptideSummary">
    <!-- Each row stores mass-spec. based expression evidence for one sample of
         one experiment for one gene. Used for mass spec queries in the model,
         GBrowse, and PBrowse, and also in the creation of the MSGeneSummary
         tuning table.
      -->
    <internalDependency name="GeneAttributes"/>
    <internalDependency name="MassSpecTerms"/>
    <internalDependency name="DatasetPresenter"/>
    <externalDependency name="dots.AAFeature"/>
    <externalDependency name="dots.AALocation"/>
    <externalDependency name="Sres.ExternalDatabase"/>
    <externalDependency name="Sres.ExternalDatabaseRelease"/>
    <intermediateTable name="MSExptTrustedSpectrum"/>
    <sql>
<![CDATA[
create table MSExptTrustedSpectrum&1 nologging as        
select distinct mss.external_database_release_id, mss.sample_file
from apidb.massspecsummary mss, dots.massspecfeature msf
where mss.mass_spec_summary_id = msf.source_id
      ]]>
    </sql>        
    <sql>
    <![CDATA[
create table MSPeptideSummary&1 nologging as
select dbms_lob.SUBSTR(seq.SEQUENCE,
                            pep.aa_end_max - pep.aa_start_min + 1,
                            pep.aa_start_min) as peptide_sequence,
       pep.*
from dots.aasequence seq, (
select ga.source_id, 
       mss.sample_file, 
       nvl(dsp.display_name, sample) as experiment,
       d.name as external_database_name,
       sum(msf.spectrum_count) as spectrum_count,
       mss.aa_sequence_id,
       l.start_min as aa_start_min,
       l.end_max as aa_end_max,
       mst.html_color, mst.internal_id, mst.organism, mst.project_id, mst.sample, mst.sort_order
from apidb.massspecsummary mss, dots.massspecfeature msf, dots.aalocation l, 
     geneattributes ga, Msexpttrustedspectrum&1 good, sres.externaldatabase d,
     sres.externaldatabaserelease r, massspecterms mst, datasetnametaxon dsnt, datasetpresenter dsp
where mss.mass_spec_summary_id = msf.source_id
and msf.aa_feature_id = l.aa_feature_id
and mss.aa_sequence_id = ga.aa_sequence_id (+)
and mss.external_database_release_id = r.external_database_release_id
and r.external_database_id = d.external_database_id
and d.name = dsnt.name (+)
and dsnt.dataset_presenter_id = dsp.dataset_presenter_id (+)
and (d.name || '|' || mss.sample_file = mst.internal_id OR d.name = mst.internal_id)
and mss.external_database_release_id = good.external_database_release_id (+)
and mss.sample_file = good.sample_file (+)
group by d.name, ga.source_id, mss.sample_file, dsp.display_name, 
         mss.aa_sequence_id, mss.spectrum_count, l.start_min, l.end_max, good.external_database_release_id, 
         mst.html_color, mst.internal_id, mst.organism, mst.project_id, mst.sample, mst.sort_order
) pep
where pep.aa_sequence_id = seq.aa_sequence_id
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="MSGeneSummary">
    <!-- Mass-spec experiment results for a gene. Used in the model for queries
         related to genes.
      -->
    <internalDependency name="MSPeptideSummary"/>
    <sql>
    <![CDATA[
create table MSGeneSummary&1 nologging as
select msps.source_id, msps.external_database_name, msps.experiment, msps.sample, msps.sample_file, msps.internal_id, msps.organism, msps.project_id, sum(msps.spectrum_count) as spectrum_count, count(*) as sequence_count
from mspeptidesummary msps
where source_id is not null
group by msps.source_id, msps.external_database_name, msps.experiment, msps.sample, msps.sample_file, msps.internal_id, msps.organism, msps.project_id
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="MSModifiedPeptideSummary">
    <!-- Mass-spec experiment results for a peptide. Used by the model, GBrowse,
         and PBrowse.
      -->
    <internalDependency name="GeneAttributes"/>
    <internalDependency name="MassSpecTerms"/>
    <internalDependency name="DatasetPresenter"/>
    <externalDependency name="dots.AAFeature"/>
    <externalDependency name="dots.AALocation"/>
    <externalDependency name="Sres.ExternalDatabase"/>
    <externalDependency name="Sres.ExternalDatabaseRelease"/>
    <externalDependency name="Sres.SequenceOntology"/>
    <externalDependency name="apidb.massSpecSummary"/>
    <externalDependency name="apidb.massSpecSummary"/>
    <sql>
    <![CDATA[
create table MSModifiedPeptideSummary&1 nologging as
select dbms_lob.substr(seq.sequence, pep.aa_end_max - pep.aa_start_min + 1,
              pep.aa_start_min)                                   as
       peptide_sequence,
       dbms_lob.substr(seq.sequence, 1, pep.residue_location + 1) as residue,
       pep.*
from   dots.aasequence seq,
       (select ga.source_id                     as source_id,
               so.term_name                     as modification_type,
               nvl(dsp.display_name, sample)    as experiment,
               ed.name                          as external_database_name,
               mss.external_database_release_id as external_database_release_id,
               mst.sample                       as Sample,
               mss.sample_file                  as sample_file,
               mss.aa_sequence_id               as aa_sequence_id,
               msf.aa_feature_id                as peptide_aa_feature_id,
               msf.spectrum_count               as spectrum_count,
               mst.html_color                   as html_color,
               aal.start_min                    as residue_location,
               aalp.start_min                   as aa_start_min,
               aalp.end_max                     as aa_end_max,
               pot.description                  as description
        from   dots.posttranslationalmodfeature pot,
               dots.massspecfeature msf,
               apidb.massspecsummary mss,
               dots.aalocation aal,
               dots.aalocation aalp,
               massspecterms mst,
               sres.sequenceontology so,
               geneattributes ga,
               sres.externaldatabase ed,
               sres.externaldatabaserelease edr,
               datasetnametaxon dsnt,
               datasetpresenter dsp
        where  pot.parent_id = msf.aa_feature_id
           and pot.aa_feature_id = aal.aa_feature_id
           and msf.aa_feature_id = aalp.aa_feature_id
           and msf.source_id = mss.mass_spec_summary_id
           and mss.aa_sequence_id = ga.aa_sequence_id
           and mss.external_database_release_id =
               edr.external_database_release_id
           and ed.name = dsnt.name (+)
           and dsnt.dataset_presenter_id = dsp.dataset_presenter_id (+)
           and ( ed.name || '|' || mss.sample_file = mst.internal_id
                 or ed.name = mst.internal_id )
           and edr.external_database_id = ed.external_database_id
           and pot.sequence_ontology_id = so.sequence_ontology_id) pep
where  pep.aa_sequence_id = seq.aa_sequence_id 
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="Ssgcid" alwaysUpdate="true">
    <!-- Data from the Seattle Structural Genomics Center for Infectious Disease,
         populated from their web service. Used in the gene record.
      -->
    <program commandLine="buildSsgcidTT"/>
  </tuningTable>


  <tuningTable name="MassSpecTerms" alwaysUpdate="true">
    <!-- Used by the model and GBrowse, as well as an input in the creation of
         the tuning tables MSModifiedPeptideSummary and MSPeptideSummary.
      -->
    <program commandLine="buildMassSpecTermsTT_trunk"/>
  </tuningTable>


  <tuningTable name="GbrowseTracksOrganism" alwaysUpdate="true">
    <!-- Associates an organism with the GBrowse and PBrowse tracks available
         for it. Used by the gene record.
      -->
    <program commandLine="buildGbrowseImageUrlTT"/>
  </tuningTable>


  <tuningTable name="DatasetPresenter" alwaysUpdate="true">
    <!-- Data for a dataset. Used widely in the model, and by GBrowse.
      -->
    <ancillaryTable name="DatasetContact"/>
    <ancillaryTable name="DatasetHyperLink"/>
    <ancillaryTable name="DatasetPublication"/>
    <ancillaryTable name="DatasetModelRef"/>
    <ancillaryTable name="DatasetNameTaxon"/>
    <program commandLine="buildDatasetPresentersTT"/>
  </tuningTable>


  <tuningTable name="DatasetDetail">
    <!-- Stores text associated with each dataset. Used by dataset queries.
      -->
    <internalDependency name="DatasetPresenter"/>
    <sql>
      <![CDATA[
      CREATE TABLE DATASETDETAIL&1
      as
            select dataset_presenter_id, 
      name||' '||category||' '||usage||' '|| 
      caveat||' '||acknowledgement||' '||type||' '||subtype
      ||' '| |summary||' '||description||' '||contact||' '||
      institution||' '||pubmed_id||' '||citation as search_string
      from (
      select
      sub.dataset_presenter_id as dataset_presenter_id, 
      sub.name as name, 
      sub.category as category,
      sub.usage as usage, 
      sub.caveat as caveat,
      sub.acknowledgement as acknowledgement, 
      sub.type as type, 
      sub.subtype as subtype,
      sub.contact,
      sub.institution,
      sub.pubmed_id,
      sub.citation,
      dp.summary,
      dp.description
      from ApidbTuning.datasetpresenter dp,
      (
      select distinct
      dp.dataset_presenter_id as dataset_presenter_id, 
      dp.display_name as name, 
      dp.display_category as category,
      dp.usage as usage, 
      dp.caveat as caveat,
      dp.acknowledgement as acknowledgement, 
      dp.type as type, 
      dp.subtype as subtype, 
      dc.name as contact,
      dc.affiliation as institution,
      LISTAGG(dpub.pmid, ' ') WITHIN GROUP (ORDER BY dpub.pmid) as pubmed_id,
      LISTAGG(dpub.citation, '  ') WITHIN GROUP (ORDER BY dpub.citation) as citation
      from apidbtuning.datasetpresenter dp, ApidbTuning.datasetcontact dc, 
      ApidbTuning.datasetpublication dpub  
      where dp.dataset_presenter_id = dc.dataset_presenter_id
      and   dp.dataset_presenter_id = dpub.dataset_presenter_id
      and   dc.is_primary_contact = 1
      group by dp.dataset_presenter_id, dp.display_name,dp.display_category,
               dp.usage,dp.caveat,dp.acknowledgement,dp.type,dp.subtype,dc.name,
               dc.affiliation
      ) sub
      
      where dp.dataset_presenter_id = sub.dataset_presenter_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
          CREATE INDEX DATASET_DETAIL_IDX&1 ON DATASETDETAIL&1 (search_string)
          INDEXTYPE IS CTXSYS.CONTEXT
      ]]>
    </sql>

  </tuningTable>


  <tuningTable name="TrackOldAnnotation" alwaysUpdate="true">
    <!-- Stores changes in gene annotation. Used by the model for gene ID and
         table queries.
      -->
    <program commandLine="buildTrackOldAnnotationTT"/>
  </tuningTable>


</tuningConfig>
