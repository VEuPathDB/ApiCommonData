<wdkModel>

  <querySet name="SnpsBy" queryType="id" includeProjects="PlasmoDB,ToxoDB,EuPathDB,CryptoDB">

    <!--++++++++++++++++++++++++++++++++++++++++++++++++-->
    <!-- ID -->
    <!--++++++++++++++++++++++++++++++++++++++++++++++++-->
      <sqlQuery name="SnpBySourceId" doNotTest="true" includeProjects="PlasmoDB,ToxoDB,CryptoDB"  isCacheable="true">
          <paramRef ref="snpParams.snp_id"/>
	  <column name="source_id"/>
	  <column name="project_id"/>
	  <sql>
	    <![CDATA[
	      SELECT distinct sf.source_id AS source_id, '@PROJECT_ID@' as project_id
	      FROM dots.SnpFeature sf, @WDK_ENGINE_SCHEMA@dataset_values@USER_DBLINK@ ds
	      WHERE ds.dataset_id = $$snp_id$$
              AND LOWER(source_id) LIKE LOWER(REPLACE(REPLACE(ds.dataset_value,' ',''), '*', '%'))
	    ]]>
	  </sql>
      </sqlQuery>

     <processQuery name="SnpBySourceId" includeProjects="EuPathDB" 
              isCacheable="true" 
              processName="org.apidb.apicomplexa.wsfplugin.apifed.ApiFedPlugin">
          <paramRef ref="snpParams.snp_id"/>
          <paramRef ref="sharedParams.signature" quote="false"/>
	  <wsColumn name="source_id" width="50" wsName="source_id"/>
          <wsColumn name="project_id" width="32" wsName="project_id"/>
      </processQuery>

    <!--++++++++++++++++++++++++++++++++++++++++++++++++-->
    <!-- Gene ID -->
    <!--++++++++++++++++++++++++++++++++++++++++++++++++-->
      <sqlQuery name="SnpsByGeneId" doNotTest="true" includeProjects="PlasmoDB,ToxoDB,CryptoDB"
             isCacheable="true">
        <paramRef ref="sharedParams.ds_gene_ids" excludeProjects="CryptoDB"/>
        <paramRef ref="sharedParams.ds_gene_ids" default="cgd3_510" includeProjects="CryptoDB"/>
        <paramRef ref="sharedParams.snp_strain_a"/>
        <paramRef ref="sharedParams.snp_strain_m"/>
        <column name="source_id"/>
        <column name="project_id"/>
        <column name="snp_location"/>
        <column name="ref_strain"/>
        <column name="comp_strains"/>
        <column name="ref_allele"/>
        <column name="comp_alleles"/>
        <column name="phenotype"/>
        <column name="prot_pos"/>
        <column name="ref_product"/>
        <column name="comp_products"/>

        <sqlParamValue name="providers" includeProjects="PlasmoDB">
           AND ed.name in ('Sanger reichenowi SNPs','PlasmoDB combined SNPs')
        </sqlParamValue>
        <sqlParamValue name="providers" includeProjects="ToxoDB">
          AND ed.name in ('Genomic Sequence SNPs','Genetic Markers - David Sibley','John Boothroyd lab at Stanford')
        </sqlParamValue>
        <sqlParamValue name="providers" includeProjects="CryptoDB"></sqlParamValue>

        <sql>
            <![CDATA[
select * from (
SELECT snpq.source_id, '@PROJECT_ID@' as project_id,snpq.snp_location,snpq.prot_pos,snpq.ref_allele,snpq.ref_product,                              
  apidb.tab_to_string(CAST(COLLECT(distinct CASE WHEN snpq.allele_a != snpq.allele_b THEN snpq.comp_all END) AS apidb.varchartab), ', ') as comp_alleles,                
  apidb.tab_to_string(CAST(COLLECT(distinct CASE WHEN snpq.allele_a != snpq.allele_b THEN snpq.comp_product END) AS apidb.varchartab), ', ') as comp_products,                
  apidb.tab_to_string(CAST(COLLECT(distinct CASE WHEN snpq.allele_a != snpq.allele_b THEN snpq.phenotype END) AS apidb.varchartab), ', ') as phenotype,                  
  apidb.tab_to_string(CAST(COLLECT(CASE WHEN snpq.allele_a = snpq.allele_b THEN snpq.strain_b END) AS apidb.varchartab), ', ') as ref_strain,              
  apidb.tab_to_string(CAST(COLLECT(CASE WHEN snpq.allele_a != snpq.allele_b THEN snpq.strain_b END) AS apidb.varchartab), ', ') as comp_strains 
FROM                 
  (SELECT hits.source_id as source_id,nas.source_id || ':' || trim(to_char(l.start_min,'999,999,999')) as snp_location,                               
    sva.strain as ref_strain, svb.strain as comp_strain,                               
    CASE WHEN gene_loc.is_reversed = 1 THEN apidb.reverse_complement(sva.allele)                                  
    ELSE sva.allele END as ref_allele,                 
    CASE WHEN gene_loc.is_reversed = 1 THEN apidb.reverse_complement(svb.allele)                                 
    ELSE svb.allele END as comp_all,                 
    CASE WHEN sva.product = svb.product then 'syn' WHEN sva.product != svb.product then 'non-syn' ELSE 'non-coding' END as phenotype,                               
    sva.product as ref_product, svb.product as comp_product,                           
    hits.position_in_protein as prot_pos,
    sva.allele as allele_a, svb.allele as allele_b, svb.strain as strain_b
  FROM   dots.SeqVariation sva, dots.SeqVariation svb, dots.NALocation l,                               
    dots.NaSequence nas,dots.NALocation gene_loc,
    (SELECT distinct gf.na_feature_id as gene_na_feature_id, gf.na_sequence_id, sf.na_feature_id as snp_na_feature_id,
      sf.position_in_protein,sf.source_id
     FROM dots.GeneFeature gf, dots.SnpFeature sf, dots.SeqVariation isva, dots.SeqVariation isvb, 
        sres.ExternalDatabase ed,sres.ExternalDatabaseRelease edr,apidb.GeneId gi, @WDK_ENGINE_SCHEMA@dataset_values@USER_DBLINK@ ds
      WHERE ds.dataset_id = $$ds_gene_ids$$
      AND gi.id = lower(ds.dataset_value)
      AND gf.source_id = gi.gene 
      AND gf.na_feature_id = sf.parent_id                               
      AND edr.external_database_release_id = sf.external_database_release_id                               
      AND edr.external_database_id = ed.external_database_id                               
      &&providers&& 
      AND sf.na_feature_id = isva.parent_id                               
      AND sf.na_feature_id = isvb.parent_id                               
      AND lower(isva.strain) = $$snp_strain_a$$                               
      AND lower(isvb.strain) in ($$snp_strain_m$$)
      AND isva.allele != isvb.allele ) hits
  WHERE hits.na_sequence_id = nas.na_sequence_id
    AND hits.gene_na_feature_id = gene_loc.na_feature_id
    AND hits.snp_na_feature_id = l.na_feature_id
    AND hits.snp_na_feature_id = sva.parent_id 
    AND hits.snp_na_feature_id = svb.parent_id 
    AND lower(sva.strain) = $$snp_strain_a$$                               
    AND lower(svb.strain) in ($$snp_strain_a$$,$$snp_strain_m$$)                             
    ) snpq                              
GROUP BY snpq.source_id,snpq.snp_location,snpq.prot_pos,snpq.ref_allele,snpq.ref_product
)
           ]]>
       </sql>

    </sqlQuery>

    <processQuery name="SnpsByGeneId" includeProjects="EuPathDB" 
             isCacheable="true" processName="org.apidb.apicomplexa.wsfplugin.apifed.ApiFedPlugin">
        <paramRef ref="sharedParams.ds_gene_ids"  default="cgd3_510" quote="false"/>
        <paramRef ref="sharedParams.snp_strain_a" default="Cp-IOWA II" quote="false"/>
        <paramRef ref="sharedParams.snp_strain_m" default="Cp-TU114" quote="false"/>
        <paramRef ref="sharedParams.signature" quote="false"/>
        <wsColumn name="source_id"  width="50" wsName="source_id"/>
        <wsColumn name="project_id" width="32" wsName="project_id"/>
        <wsColumn name="snp_location" width="32"/>
        <wsColumn name="ref_strain" width="32"/>
        <wsColumn name="comp_strains" width="32"/>
        <wsColumn name="ref_allele" width="32"/>
        <wsColumn name="comp_alleles" width="32"/>
        <wsColumn name="phenotype" width="32"/>
        <wsColumn name="prot_pos" width="32"/>
        <wsColumn name="ref_product" width="32"/>
        <wsColumn name="comp_products" width="32"/> 
    </processQuery>

    <!--++++++++++++++++++++++++++++++++++++++++++++++++-->
    <!-- Location -->
    <!-- 
         This query contains two nested inline views.  The 
         inner, named "hits", identifies SNPs within the given 
         genomic region for which the reference strain has a 
         different allele from at least one of the others.  The 
         outer inline view, "snpq", has one row for each SNP for 
         each strain (e.g. (100 SNPs) x (1 reference + 3 other 
         strains) = 400 records).  At the top level, the query 
         itself then groups all rows of a SNP into a single row 
         (which, for the above example, would mean grouping four 
         rows into one).
         
         It seems necessary to have these three levels in the 
         query's structure, but it might be possible to optimize 
         within each level.  For instance, the innermost query must 
         join dots.SnpFeature to dots.NaLocation.  A big 
         materialized view could precompute this join. -->
    <!--++++++++++++++++++++++++++++++++++++++++++++++++-->
    <sqlQuery name="SnpsByLocation" includeProjects="PlasmoDB,ToxoDB,CryptoDB" isCacheable="true">
 
        <testParamValues includeProjects="CryptoDB">
            <paramValue name="snp_strain_m">Cp-MD</paramValue>
            <paramValue name="chromosomeOptional">chromosome 2</paramValue>
        </testParamValues>
        <testParamValues includeProjects="ToxoDB">
            <paramValue name="snp_strain_m">Tg-VEG (type III)</paramValue>
            <paramValue name="chromosomeOptional">III</paramValue>
        </testParamValues>
       <testParamValues includeProjects="PlasmoDB">
            <paramValue name="snp_strain_m">Pf-Dd2</paramValue>
            <paramValue name="chromosomeOptional">chromosome 1</paramValue>
        </testParamValues>

        <paramRef ref="organismParams.organism" queryRef="organismVQ.withChromosomesSNPs"/>
         <paramRef ref="sharedParams.chromosomeOptional" multiPick="false"/>
          <paramRef ref="sharedParams.start_point"/>
          <paramRef ref="sharedParams.end_point"/>
          <paramRef ref="sharedParams.snp_strain_a"/>
          <paramRef ref="sharedParams.snp_strain_m"/>
          <column name="source_id"/>
	  <column name="project_id"/>
          <column name="gene"/>
          <column name="snp_location"/>
          <column name="ref_strain"/>
          <column name="comp_strains"/>
          <column name="ref_allele"/>
          <column name="comp_alleles"/>
          <column name="phenotype"/>
          <column name="prot_pos"/>
          <column name="ref_product"/>
          <column name="comp_products"/>


        <sqlParamValue name="providers" includeProjects="PlasmoDB">
           AND ed.name in ('Sanger reichenowi SNPs','PlasmoDB combined SNPs')
        </sqlParamValue>
        <sqlParamValue name="providers" includeProjects="ToxoDB">
          AND ed.name in ('Genomic Sequence SNPs','Genetic Markers - David Sibley','John Boothroyd lab at Stanford','Lindstrom 454 SNPs')
        </sqlParamValue>
        <sqlParamValue name="providers" includeProjects="CryptoDB"></sqlParamValue>

        <sql includeProjects="PlasmoDB,ToxoDB">
            <![CDATA[
              select * from (
            SELECT snpq.source_id, '@PROJECT_ID@' as project_id,snpq.gene,snpq.snp_location,snpq.prot_pos,snpq.ref_allele,snpq.ref_product,
              apidb.tab_to_string(CAST(COLLECT(distinct snpq.comp_all) AS apidb.varchartab), ', ') as comp_alleles,
              apidb.tab_to_string(CAST(COLLECT(distinct snpq.comp_product) AS apidb.varchartab), ', ') as comp_products,
              apidb.tab_to_string(CAST(COLLECT(distinct snpq.phenotype) AS apidb.varchartab), ', ') as phenotype,
              apidb.tab_to_string(CAST(COLLECT(distinct snpq.ref_strain) AS apidb.varchartab), ', ') as ref_strain,
              apidb.tab_to_string(CAST(COLLECT(distinct snpq.comp_strain) AS apidb.varchartab), ', ') as comp_strains
            FROM
              (-- records in apid.polymorphism are constrained that
               -- strain_a < strain_b, so this subquery is the union of two
               -- possibilities:
               -- first, when ref strain name < comp strain name
               -- (i.e. ref is strain a, comp is strain b)
               SELECT 
                       p.snp_source_id as source_id,
                      seq.source_id || ':' || trim(to_char(p.start_min,'999,999,999')) as snp_location,
                p.strain_a AS ref_strain, p.strain_b AS comp_strain,
                CASE WHEN p.gene_is_reversed = 1 THEN apidb.reverse_complement(p.allele_a)
                     ELSE p.allele_a END as ref_allele,
                CASE WHEN p.gene_is_reversed = 1 THEN apidb.reverse_complement(p.allele_b)
                     ELSE p.allele_b END as comp_all,
                CASE WHEN p.product_a = p.product_b then 'syn' WHEN p.product_a != p.product_b THEN 'non-syn'
                     ELSE 'non-coding' END as phenotype,
                p.product_a AS ref_product, p.product_b AS comp_product,
                p.position_in_protein as prot_pos,
                p.gene_source_id as gene
               FROM apidb.Polymorphism p, apidb.sequenceAttributes seq,
                    sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed
               WHERE seq.na_sequence_id = p.na_sequence_id
                 AND p.external_database_release_id = edr.external_database_release_id
                 AND edr.external_database_id = ed.external_database_id
                 AND seq.chromosome = $$chromosomeOptional$$
                 AND lower(p.strain_a) = $$snp_strain_a$$ -- ref
                 AND lower(p.strain_b) in ($$snp_strain_m$$) -- comp
                 AND $$snp_strain_a$$ < lower(p.strain_b)
                 AND p.start_min >=  REGEXP_REPLACE('$$start_point$$', ',| ','')
                 AND (REGEXP_REPLACE('$$end_point$$', ',| ','') = 0 OR p.start_min < REGEXP_REPLACE('$$end_point$$', ',| ',''))
                   &&providers&&
              UNION
               -- second, when comp strain name < ref strain name
               -- (ref is strain b, comp is strain a)
               SELECT p.snp_source_id as source_id,
                      seq.source_id || ':' || trim(to_char(p.start_min,'999,999,999')) as snp_location,
                p.strain_b AS ref_strain, p.strain_a AS comp_strain,
                CASE WHEN p.gene_is_reversed = 1 THEN apidb.reverse_complement(p.allele_b)
                     ELSE p.allele_b END as ref_allele,
                CASE WHEN p.gene_is_reversed = 1 THEN apidb.reverse_complement(p.allele_a)
                     ELSE p.allele_a END as comp_all,
                CASE WHEN p.product_a = p.product_b then 'syn' WHEN p.product_a != p.product_b THEN 'non-syn'
                     ELSE 'non-coding' END as phenotype,
                p.product_b AS ref_product, p.product_a AS comp_product,
                p.position_in_protein as prot_pos, p.gene_source_id as gene
               FROM apidb.Polymorphism p, apidb.sequenceAttributes seq,
                    sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed
               WHERE seq.na_sequence_id = p.na_sequence_id
                 AND p.external_database_release_id = edr.external_database_release_id
                 AND edr.external_database_id = ed.external_database_id
                 AND seq.chromosome = $$chromosomeOptional$$
                 AND lower(p.strain_b) = $$snp_strain_a$$ -- ref
                 AND lower(p.strain_a) in ($$snp_strain_m$$) -- comp
                 AND lower(p.strain_a) < $$snp_strain_a$$
                 AND p.start_min >=  REGEXP_REPLACE('$$start_point$$', ',| ','')
                 AND (REGEXP_REPLACE('$$end_point$$', ',| ','') = 0 OR p.start_min < REGEXP_REPLACE('$$end_point$$', ',| ',''))
                 &&providers&&) snpq
            GROUP BY snpq.source_id,snpq.gene,snpq.snp_location,snpq.prot_pos,snpq.ref_allele,snpq.ref_product)
           ]]>
       </sql>
        <sql includeProjects="CryptoDB">
            <![CDATA[
              select * from (
              SELECT snpq.source_id, '@PROJECT_ID@' as project_id,snpq.gene,snpq.snp_location,snpq.prot_pos,snpq.ref_allele,snpq.ref_product,
                apidb.tab_to_string(CAST(COLLECT(distinct snpq.comp_all) AS apidb.varchartab), ', ') as comp_alleles,
                apidb.tab_to_string(CAST(COLLECT(distinct snpq.comp_product) AS apidb.varchartab), ', ') as comp_products,
                apidb.tab_to_string(CAST(COLLECT(distinct snpq.phenotype) AS apidb.varchartab), ', ') as phenotype,
                apidb.tab_to_string(CAST(COLLECT(distinct snpq.ref_strain) AS apidb.varchartab), ', ') as ref_strain,
                apidb.tab_to_string(CAST(COLLECT(distinct snpq.comp_strain) AS apidb.varchartab), ', ') as comp_strains
              FROM
                (-- records in apid.polymorphism are constrained that
                 -- strain_a < strain_b, so this subquery is the union of two
                 -- possibilities:
                 -- first, when ref strain name < comp strain name
                 -- (i.e. ref is strain a, comp is strain b)
                 SELECT p.snp_source_id as source_id,
                        seq.source_id || ':' || trim(to_char(p.start_min,'999,999,999')) as snp_location,
                  p.strain_a AS ref_strain, p.strain_b AS comp_strain,
                  CASE WHEN gene_loc.is_reversed = 1 THEN apidb.reverse_complement(ref.allele)
                       ELSE ref.allele END as ref_allele,
                  CASE WHEN gene_loc.is_reversed = 1 THEN apidb.reverse_complement(comp.allele)
                       ELSE comp.allele END as comp_all,
                  CASE WHEN ref.product = comp.product then 'syn' WHEN ref.product != comp.product THEN 'non-syn'
                       ELSE 'non-coding' END as phenotype,
                  ref.product AS ref_product, comp.product AS comp_product,
                  snp.position_in_protein as prot_pos,
                  ref.allele as allele_a, comp.allele as allele_b, p.strain_b, gene.source_id as gene
                 FROM apidb.Polymorphism p, dots.SnpFeature snp, apidb.sequenceattributes seq,
                      dots.SeqVariation ref, dots.SeqVariation comp,
                      dots.NaLocation gene_loc, sres.ExternalDatabaseRelease edr,
                      sres.ExternalDatabase ed, dots.GeneFeature gene
                 WHERE seq.na_sequence_id = p.na_sequence_id
                   AND p.gene_na_feature_id = gene_loc.na_feature_id(+)
                   AND p.external_database_release_id = edr.external_database_release_id
                   AND edr.external_database_id = ed.external_database_id
                   AND p.snp_na_feature_id = snp.na_feature_id
                   AND seq.chromosome = $$chromosomeOptional$$
                   AND lower(p.strain_a) = $$snp_strain_a$$ -- ref
                   AND lower(p.strain_b) in ($$snp_strain_m$$) -- comp
                   AND $$snp_strain_a$$ < lower(p.strain_b)
                   AND p.start_min >=  REGEXP_REPLACE('$$start_point$$', ',| ','')
                   AND (REGEXP_REPLACE('$$end_point$$', ',| ','') = 0 OR p.start_min < REGEXP_REPLACE('$$end_point$$', ',| ',''))
                   AND p.na_feature_id_b = comp.na_feature_id
                   AND p.na_feature_id_a = ref.na_feature_id
                   AND p.gene_na_feature_id = gene.na_feature_id(+)
                   &&providers&&
                UNION
                 -- second, when comp strain name < ref strain name
                 -- (ref is strain b, comp is strain a)
                 SELECT p.snp_source_id as source_id,
                        seq.source_id || ':' || trim(to_char(p.start_min,'999,999,999')) as snp_location,
                  p.strain_b AS ref_strain, p.strain_a AS comp_strain,
                  CASE WHEN gene_loc.is_reversed = 1 THEN apidb.reverse_complement(ref.allele)
                       ELSE ref.allele END as ref_allele,
                  CASE WHEN gene_loc.is_reversed = 1 THEN apidb.reverse_complement(comp.allele)
                       ELSE comp.allele END as comp_all,
                  CASE WHEN ref.product = comp.product then 'syn' WHEN ref.product != comp.product THEN 'non-syn'
                       ELSE 'non-coding' END as phenotype,
                  ref.product AS ref_product, comp.product AS comp_product,
                  snp.position_in_protein as prot_pos,
                  ref.allele as allele_a, comp.allele as allele_b, p.strain_b, gene.source_id as gene
                 FROM apidb.Polymorphism p, dots.SnpFeature snp, apidb.sequenceattributes seq,
                      dots.SeqVariation ref, dots.SeqVariation comp,
                      dots.NaLocation gene_loc, sres.ExternalDatabaseRelease edr,
                      sres.ExternalDatabase ed, dots.GeneFeature gene, apidb.featurelocation fl
                 WHERE seq.na_sequence_id = p.na_sequence_id
                   AND p.gene_na_feature_id = gene_loc.na_feature_id(+)
                   AND p.external_database_release_id = edr.external_database_release_id
                   AND edr.external_database_id = ed.external_database_id
                   AND p.snp_na_feature_id = snp.na_feature_id
                   AND seq.chromosome = $$chromosomeOptional$$
                   AND lower(p.strain_b) = $$snp_strain_a$$ -- ref
                   AND lower(p.strain_a) in ($$snp_strain_m$$) -- comp
                   AND lower(p.strain_a) < $$snp_strain_a$$
                   AND p.start_min >=  REGEXP_REPLACE('$$start_point$$', ',| ','')
                   AND (REGEXP_REPLACE('$$end_point$$', ',| ','') = 0 OR p.start_min < REGEXP_REPLACE('$$end_point$$', ',| ',''))
                   AND p.na_feature_id_a = comp.na_feature_id
                   AND p.na_feature_id_b = ref.na_feature_id
                   AND p.gene_na_feature_id = gene.na_feature_id(+)
                   &&providers&&) snpq
              GROUP BY snpq.source_id,snpq.gene,snpq.snp_location,snpq.prot_pos,snpq.ref_allele,snpq.ref_product)
           ]]>
       </sql>
    </sqlQuery>

    <processQuery name="SnpsByLocation" includeProjects="EuPathDB"
             isCacheable="true" processName="org.apidb.apicomplexa.wsfplugin.apifed.ApiFedPlugin" >

        <testParamValues includeProjects="CryptoDB">
            <paramValue name="snp_strain_m">Cp-MD</paramValue>
            <paramValue name="chromosomeOptional">C.p. AAEE01000005 (Chromosome 2)</paramValue>
        </testParamValues>

          <!--<paramRef ref="organismParams.organism" queryRef="organismVQ.tg-pf"/>-->
          <paramRef ref="organismParams.organism" queryRef="organismVQ.withChromosomesSNPs"/>
          <paramRef ref="sharedParams.chromosomeOptional" quote="false" />
          <paramRef ref="sharedParams.start_point"/>
          <paramRef ref="sharedParams.end_point"/>
          <paramRef ref="sharedParams.snp_strain_a" quote="false"/>
          <paramRef ref="sharedParams.snp_strain_m" quote="false"/>
          <wsColumn name="source_id" width="50" wsName="source_id"/>
          <wsColumn name="project_id" width="32" wsName="project_id"/>
          <wsColumn name="gene" width="32"/>
          <wsColumn name="snp_location" width="32"/>
          <wsColumn name="ref_strain" width="32"/>
          <wsColumn name="comp_strains" width="32"/>
          <wsColumn name="ref_allele" width="32"/>
          <wsColumn name="comp_alleles" width="32"/>
          <wsColumn name="phenotype" width="32"/>
          <wsColumn name="prot_pos" width="32"/>
          <wsColumn name="ref_product" width="32"/>
          <wsColumn name="comp_products" width="32"/>
      </processQuery>

    <!--++++++++++++++++++++++++++++++++++++++++++++++++-->
    <!-- Allele Frequency -->
    <!--++++++++++++++++++++++++++++++++++++++++++++++++-->
    <sqlQuery name="SnpsByAlleleFrequency" includeProjects="PlasmoDB" 
          isCacheable="true">
        <paramRef ref="snpParams.minor_allele_min"/>
        <paramRef ref="snpParams.minor_allele_max"/>
        <paramRef ref="snpParams.min_strain_count"/>
        <column name="source_id"/> 
        <column name="project_id"/>
        <sql>
            <![CDATA[
              select source_id,project_id
              from apidb.SNPATTRIBUTES 
              where dataset = 'PlasmoDB combined SNPs'
              and minor_allele_frequency >= $$minor_allele_min$$
              and minor_allele_frequency <= $$minor_allele_max$$
              and strain_count >= $$min_strain_count$$
           ]]>
       </sql>
    </sqlQuery>

    <processQuery name="SnpsByAlleleFrequency" includeProjects="EuPathDB"
             isCacheable="true" processName="org.apidb.apicomplexa.wsfplugin.apifed.ApiFedPlugin">
        <paramRef ref="organismParams.organism" default="Plasmodium falciparum" visible="false" />
        <paramRef ref="snpParams.min_strain_count" quote="false"/>
        <paramRef ref="snpParams.minor_allele_min"  quote="false"/>
        <paramRef ref="snpParams.minor_allele_max"  quote="false"/>
        <wsColumn name="source_id" width="32" wsName="source_id"/>
        <wsColumn name="project_id" width="32" wsName="project_id"/>
        <wsColumn name="minor_alleles"/>
        <wsColumn name="minor_products"/>
        <wsColumn name="minor_strains"/>
        <wsColumn name="major_strains"/>
    </processQuery>

    <!--++++++++++++++++++++++++++++++++++++++++++++++++-->
    <!-- Isolate Pattern -->
    <!--++++++++++++++++++++++++++++++++++++++++++++++++-->

    <sqlQuery name="SnpsByIsolatePattern" doNotTest="true" includeProjects="PlasmoDB" 
          isCacheable="true">
        <paramRef ref="snpParams.isolate_set_a"/>
        <paramRef ref="snpParams.set_a_percent"/>
        <paramRef ref="snpParams.isolate_set_b"/>
        <paramRef ref="snpParams.set_b_percent"/>
        <column name="source_id"/> 
        <column name="project_id"/>
        <column name="set_a_allele"/>
        <column name="set_b_allele"/>
        <column name="set_a_count"/>
        <column name="set_b_count"/>
        <sql>
            <![CDATA[
              select seta.snp_source_id as source_id,'@PROJECT_ID@' as project_id,
              seta.allele as set_a_allele,setb.allele as set_b_allele,
              seta.total as set_a_count, setb.total as set_b_count
              from (select isnp.snp_source_id,isnp.allele,count(*) as total
              from apidb.isolatesnps isnp, @WDK_ENGINE_SCHEMA@dataset_values@USER_DBLINK@ ds
              where ds.dataset_id = $$isolate_set_a$$
              and isnp.is_source_id = ds.dataset_value
              and isnp.allele is not null
              and isnp.snp_db_name = 'PlasmoDB combined SNPs'
              group by isnp.snp_source_id,isnp.allele
              having count(*) >= (select count(*) from  @WDK_ENGINE_SCHEMA@dataset_values@USER_DBLINK@
                  where dataset_id = $$isolate_set_a$$) * $$set_a_percent$$ / 100) seta,
              (select isnp.snp_source_id,isnp.allele, count(*) as total
              from apidb.isolatesnps isnp, @WDK_ENGINE_SCHEMA@dataset_values@USER_DBLINK@ ds
              where ds.dataset_id = $$isolate_set_b$$
              and isnp.is_source_id = ds.dataset_value
              and isnp.allele is not null
              and isnp.snp_db_name = 'PlasmoDB combined SNPs'
              group by isnp.snp_source_id,isnp.allele
              having count(*) >= (select count(*) from  @WDK_ENGINE_SCHEMA@dataset_values@USER_DBLINK@
                  where dataset_id = $$isolate_set_b$$) * $$set_b_percent$$ / 100) setb
              where seta.snp_source_id = setb.snp_source_id
              and seta.allele != setb.allele
           ]]>
       </sql>
    </sqlQuery>

    <processQuery name="SnpsByIsolatePattern" includeProjects="EuPathDB"
             isCacheable="true" processName="org.apidb.apicomplexa.wsfplugin.apifed.ApiFedPlugin">
        <paramRef ref="organismParams.organism" queryRef="organismVQ.pf"/>
 <paramRef ref="sharedParams.signature" quote="false"/>
        <paramRef ref="snpParams.isolate_set_a"/>
        <paramRef ref="snpParams.set_a_percent"/>
        <paramRef ref="snpParams.isolate_set_b"/>
        <paramRef ref="snpParams.set_b_percent"/>
   
        <wsColumn name="source_id" width="32" wsName="source_id"/>
        <wsColumn name="project_id" width="32" wsName="project_id"/>
        <wsColumn name="set_a_allele"/>
        <wsColumn name="set_b_allele"/>
        <wsColumn name="set_a_count"/>
        <wsColumn name="set_b_count"/>
    </processQuery>
  <!--++++++++++++++++++++++++++++++++++++++++++++++++-->
    <!-- Isolate Pattern by history id -->
    <!--++++++++++++++++++++++++++++++++++++++++++++++++-->

    <sqlQuery name="SnpsByIsolatePatternHistory" includeProjects="PlasmoDB" 
          isCacheable="true">
        <paramRef ref="sharedParams.isolateHistoryIdA"/>
        <paramRef ref="snpParams.set_a_count"/>
        <paramRef ref="sharedParams.isolateHistoryIdB"/>
        <paramRef ref="snpParams.set_b_count"/>
        <column name="source_id"/> 
        <column name="project_id"/>
        <column name="set_a_allele"/>
        <column name="set_b_allele"/>
        <sql>
            <![CDATA[
              select seta.snp_source_id as source_id,'@PROJECT_ID@' as project_id,
              seta.allele as set_a_allele,setb.allele as set_b_allele
              from (select isnp.snp_source_id,isnp.allele
              from apidb.isolatesnps isnp
              where isnp.is_source_id in (select distinct source_id from $$isolateHitoryIdA$$)
              and isnp.allele is not null
              and isnp.snp_db_name = 'PlasmoDB combined SNPs'
              group by isnp.snp_source_id,isnp.allele
              having count(*) >= $$set_a_count$$) seta,
              (select isnp.snp_source_id,isnp.allele
              from apidb.isolatesnps isnp
              where isnp.is_source_id in (select distinct source_id from $$isolateHitoryIdB$$)
              and isnp.allele is not null
              and isnp.snp_db_name = 'PlasmoDB combined SNPs'
              group by isnp.snp_source_id,isnp.allele
              having count(*) >= $$set_b_count$$) setb
              where seta.snp_source_id = setb.snp_source_id
              and seta.allele != setb.allele
           ]]>
       </sql>
    </sqlQuery>

    <processQuery name="SnpsByIsolatePatternHistory" includeProjects="EuPathDB"
             isCacheable="true" processName="org.apidb.apicomplexa.wsfplugin.apifed.ApiFedPlugin">
        <paramRef ref="organismParams.organism" queryRef="organismVQ.pf"/>
        <paramRef ref="sharedParams.isolateHistoryIdA"/>
        <paramRef ref="snpParams.set_a_count"/>
        <paramRef ref="sharedParams.isolateHistoryIdB"/>
        <paramRef ref="snpParams.set_b_count"/>
        <wsColumn name="source_id" width="32" wsName="source_id"/>
        <wsColumn name="project_id" width="32" wsName="project_id"/>
        <wsColumn name="set_a_allele"/>
        <wsColumn name="set_b_allele"/>
    </processQuery>

    <!--++++++++++++++++++++++++++++++++++++++++++++++++-->
    <!-- Isolate assay type -->
    <!--++++++++++++++++++++++++++++++++++++++++++++++++-->

    <sqlQuery name="SnpsByIsolateType" includeProjects="PlasmoDB" 
          isCacheable="true">
        <paramRef ref="isolateParams.snp_assay_type"/>
        <column name="source_id"/> 
        <column name="project_id"/>
        <sql>
            <![CDATA[
              select distinct snp_source_id as source_id, '@PROJECT_ID@' as project_id
              from apidb.isolatesnps isnp, apidb.isolateattributes atr
              where atr.source_id = isnp.is_source_id
              and atr.data_type in ($$snp_assay_type$$)
              and isnp.snp_db_name = 'PlasmoDB combined SNPs'
           ]]>
       </sql>
    </sqlQuery>

    <processQuery name="SnpsByIsolateType" includeProjects="EuPathDB"
             isCacheable="true" processName="org.apidb.apicomplexa.wsfplugin.apifed.ApiFedPlugin">
        <paramRef ref="organismParams.organism" queryRef="organismVQ.pf"/>
        <paramRef ref="isolateParams.snp_assay_type"/>
        <wsColumn name="source_id" width="32" wsName="source_id"/>
        <wsColumn name="project_id" width="32" wsName="project_id"/>
    </processQuery>

    <!--++++++++++++++++++++++++++++++++++++++++++++++++-->
    <!-- Isolate source id -->
    <!--++++++++++++++++++++++++++++++++++++++++++++++++-->

    <sqlQuery name="SnpsByIsolateId" includeProjects="PlasmoDB" 
          isCacheable="true">

        <testParamValues>
            <paramValue name="isolate_id">CP3.911227</paramValue>
        </testParamValues>

        <paramRef ref="snpParams.isolate_id"/>
        <column name="source_id"/> 
        <column name="project_id"/>
        <column name="isolate_allele"/>
        <column name="is_source_id"/>
        <sql>
            <![CDATA[
              select isnp.snp_source_id as source_id, $$isolate_id$$ as is_source_id, 
                     isnp.allele as isolate_allele, '@PROJECT_ID@' as project_id
              from apidb.ISOLATESNPS isnp, apidb.SNPATTRIBUTES sa
              where isnp.is_source_id = $$isolate_id$$
              and isnp.allele is not null
              and isnp.snp_db_name = 'PlasmoDB combined SNPs'
              and isnp.snp_source_id = sa.source_id
           ]]>
       </sql>
    </sqlQuery>

  </querySet>

</wdkModel>
